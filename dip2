<!DOCTYPE html>
<html lang="en">
<head>
<title>Dive Into Python</title>
<link rel="stylesheet" href="diveintopython3.css" type="text/css">
</head>
<h1>Dive Into Python</h1>
<p class=pubdate>20 May 2004
<p class=copyright>Copyright &copy; 2000, 2001, 2002, 2003, 2004 <a href="mailto:mark@diveintopython3.org">Mark Pilgrim</a>
<p>This book lives at <a href="http://diveintopython3.org/">http://diveintopython3.org/</a>. If you're reading it somewhere else, you may not have the latest version.
<div class=toc>
<p><b>Table of Contents</b>
<ul>
<li><a href="#install">1. Installing Python</a><ul>
<li><a href="#install.choosing">1.1. Which Python is right for you?</a>
<li><a href="#install.windows">1.2. Python on Windows</a>
<li><a href="#install.macosx">1.3. Python on Mac OS X</a>
<li><a href="#install.macos9">1.4. Python on Mac OS 9</a>
<li><a href="#install.redhat">1.5. Python on RedHat Linux</a>
<li><a href="#install.debian">1.6. Python on Debian GNU/Linux</a>
<li><a href="#install.source">1.7. Python Installation from Source</a>
<li><a href="#install.shell">1.8. The Interactive Shell</a>
<li><a href="#install.summary">1.9. Summary</a>
</ul>

<li><a href="#odbchelper.tuple">3.3. Introducing Tuples</a>
<li><a href="#odbchelper.vardef">3.4. Declaring variables</a><ul>
<li><a href="#d0e6873">3.4.1. Referencing Variables</a>
<li><a href="#odbchelper.multiassign">3.4.2. Assigning Multiple Values at Once</a>
</ul>

<li><a href="#apihelper">4. The Power Of Introspection</a><ul>
<li><a href="#apihelper.divein">4.1. Diving In</a>
<li><a href="#apihelper.optional">4.2. Using Optional and Named Arguments</a>
<li><a href="#apihelper.builtin">4.3. Using type, str, dir, and Other Built-In Functions</a><ul>
<li><a href="#d0e8510">4.3.1. The type Function</a>
<li><a href="#d0e8609">4.3.2. The str Function</a>
<li><a href="#d0e8958">4.3.3. Built-In Functions</a>
</ul>

<li><a href="#apihelper.getattr">4.4. Getting Object References With getattr</a><ul>
<li><a href="#d0e9194">4.4.1. getattr with Modules</a>
<li><a href="#d0e9362">4.4.2. getattr As a Dispatcher</a>
</ul>

<li><a href="#apihelper.filter">4.5. Filtering Lists</a>
<li><a href="#apihelper.andor">4.6. The Peculiar Nature of and and or</a><ul>
<li><a href="#d0e9975">4.6.1. Using the and-or Trick</a>
</ul>

<li><a href="#apihelper.lambda">4.7. Using lambda Functions</a><ul>
<li><a href="#d0e10403">4.7.1. Real-World lambda Functions</a>
</ul>

<li><a href="#apihelper.alltogether">4.8. Putting It All Together</a>
<li><a href="#apihelper.summary">4.9. Summary</a>
</ul>

<li><a href="#fileinfo">5. Objects and Object-Orientation</a><ul>
<li><a href="#fileinfo.divein">5.1. Diving In</a>
<li><a href="#fileinfo.fromimport">5.2. Importing Modules Using from module import</a>
<li><a href="#fileinfo.class">5.3. Defining Classes</a><ul>
<li><a href="#d0e11720">5.3.1. Initializing and Coding Classes</a>
<li><a href="#d0e11896">5.3.2. Knowing When to Use self and __init__</a>
</ul>

<li><a href="#fileinfo.create">5.4. Instantiating Classes</a><ul>
<li><a href="#d0e12165">5.4.1. Garbage Collection</a>
</ul>

<li><a href="#fileinfo.userdict">5.5. Exploring UserDict: A Wrapper Class</a>
<li><a href="#fileinfo.specialmethods">5.6. Special Class Methods</a><ul>
<li><a href="#d0e12822">5.6.1. Getting and Setting Items</a>
</ul>

<li><a href="#fileinfo.morespecial">5.7. Advanced Special Class Methods</a>
<li><a href="#fileinfo.classattributes">5.8. Introducing Class Attributes</a>
<li><a href="#fileinfo.private">5.9. Private Functions</a>
<li><a href="#fileinfo.summary">5.10. Summary</a>
</ul>

<li><a href="#filehandling">6. Exceptions and File Handling</a><ul>
<li><a href="#fileinfo.exception">6.1. Handling Exceptions</a><ul>
<li><a href="#d0e14344">6.1.1. Using Exceptions For Other Purposes</a>
</ul>

<li><a href="#fileinfo.files">6.2. Working with File Objects</a><ul>
<li><a href="#d0e14670">6.2.1. Reading Files</a>
<li><a href="#d0e14800">6.2.2. Closing Files</a>
<li><a href="#d0e14928">6.2.3. Handling I/O Errors</a>
<li><a href="#d0e15055">6.2.4. Writing to Files</a>
</ul>

<li><a href="#fileinfo.for">6.3. Iterating with for Loops</a>
<li><a href="#fileinfo.modules">6.4. Using sys.modules</a>
<li><a href="#fileinfo.os">6.5. Working with Directories</a>
<li><a href="#fileinfo.alltogether">6.6. Putting It All Together</a>
<li><a href="#fileinfo.summary2">6.7. Summary</a>
</ul>

<li><a href="#dialect">8. HTML Processing</a><ul>
<li><a href="#dialect.divein">8.1. Diving in</a>
<li><a href="#dialect.sgmllib">8.2. Introducing sgmllib.py</a>
<li><a href="#dialect.extract">8.3. Extracting data from HTML documents</a>
<li><a href="#dialect.basehtml">8.4. Introducing BaseHTMLProcessor.py</a>
<li><a href="#dialect.locals">8.5. locals and globals</a>
<li><a href="#dialect.dictsub">8.6. Dictionary-based string formatting</a>
<li><a href="#dialect.quoting">8.7. Quoting attribute values</a>
<li><a href="#dialect.dialectizer">8.8. Introducing dialect.py</a>
<li><a href="#dialect.alltogether">8.9. Putting it all together</a>
<li><a href="#dialect.summary">8.10. Summary</a>
</ul>

<li><a href="#kgp">9. XML Processing</a><ul>
<li><a href="#kgp.divein">9.1. Diving in</a>
<li><a href="#kgp.packages">9.2. Packages</a>
<li><a href="#kgp.parse">9.3. Parsing XML</a>
<li><a href="#kgp.search">9.5. Searching for elements</a>
<li><a href="#kgp.attributes">9.6. Accessing element attributes</a>
<li><a href="#kgp.segue">9.7. Segue</a>
</ul>

<li><a href="#streams">10. Scripts and Streams</a><ul>
<li><a href="#kgp.openanything">10.1. Abstracting input sources</a>
<li><a href="#kgp.stdio">10.2. Standard input, output, and error</a>
<li><a href="#kgp.cache">10.3. Caching node lookups</a>
<li><a href="#kgp.child">10.4. Finding direct children of a node</a>
<li><a href="#kgp.handler">10.5. Creating separate handlers by node type</a>
<li><a href="#kgp.commandline">10.6. Handling command-line arguments</a>
<li><a href="#kgp.alltogether">10.7. Putting it all together</a>
<li><a href="#kgp.summary">10.8. Summary</a>
</ul>

<li><a href="#oa">11. HTTP Web Services</a><ul>
<li><a href="#oa.divein">11.1. Diving in</a>
<li><a href="#oa.review">11.2. How not to fetch data over HTTP</a>
<li><a href="#oa.features">11.3. Features of HTTP</a><ul>
<li><a href="#d0e27596">11.3.1. User-Agent</a>
<li><a href="#d0e27616">11.3.2. Redirects</a>
<li><a href="#d0e27689">11.3.3. Last-Modified/If-Modified-Since</a>
<li><a href="#d0e27724">11.3.4. ETag/If-None-Match</a>
<li><a href="#d0e27752">11.3.5. Compression</a>
</ul>

<li><a href="#oa.debug">11.4. Debugging HTTP web services</a>
<li><a href="#oa.useragent">11.5. Setting the User-Agent</a>
<li><a href="#oa.etags">11.6. Handling Last-Modified and ETag</a>
<li><a href="#oa.redirect">11.7. Handling redirects</a>
<li><a href="#oa.gzip">11.8. Handling compressed data</a>
<li><a href="#oa.alltogether">11.9. Putting it all together</a>
<li><a href="#oa.summary">11.10. Summary</a>
</ul>

<li><a href="#roman">13. Unit Testing</a><ul>
<li><a href="#roman.intro">13.1. Introduction to Roman numerals</a>
<li><a href="#roman.divein">13.2. Diving in</a>
<li><a href="#roman.romantest">13.3. Introducing romantest.py</a>
<li><a href="#roman.success">13.4. Testing for success</a>
<li><a href="#roman.failure">13.5. Testing for failure</a>
<li><a href="#roman.sanity">13.6. Testing for sanity</a>
</ul>

<li><a href="#roman1.5">14. Test-First Programming</a><ul>
<li><a href="#roman.stage1">14.1. roman.py, stage 1</a>
<li><a href="#roman.stage2">14.2. roman.py, stage 2</a>
<li><a href="#roman.stage3">14.3. roman.py, stage 3</a>
<li><a href="#roman.stage4">14.4. roman.py, stage 4</a>
<li><a href="#roman.stage5">14.5. roman.py, stage 5</a>
</ul>

<li><a href="#roman2">15. Refactoring</a><ul>
<li><a href="#roman.bugs">15.1. Handling bugs</a>
<li><a href="#roman.change">15.2. Handling changing requirements</a>
<li><a href="#roman.refactoring">15.3. Refactoring</a>
<li><a href="#roman.postscript">15.4. Postscript</a>
<li><a href="#roman.summary">15.5. Summary</a>
</ul>

<li><a href="#regression">16. Functional Programming</a><ul>
<li><a href="#regression.divein">16.1. Diving in</a>
<li><a href="#regression.path">16.2. Finding the path</a>
<li><a href="#regression.filter">16.3. Filtering lists revisited</a>
<li><a href="#regression.map">16.4. Mapping lists revisited</a>
<li><a href="#regression.datacentric">16.5. Data-centric programming</a>
<li><a href="#regression.import">16.6. Dynamically importing modules</a>
<li><a href="#regression.alltogether">16.7. Putting it all together</a>
<li><a href="#regression.summary">16.8. Summary</a>
</ul>

<li><a href="#plural">17. Dynamic functions</a><ul>
<li><a href="#plural.divein">17.1. Diving in</a>
<li><a href="#plural.stage1">17.2. plural.py, stage 1</a>
<li><a href="#plural.stage2">17.3. plural.py, stage 2</a>
<li><a href="#plural.stage3">17.4. plural.py, stage 3</a>
<li><a href="#plural.stage4">17.5. plural.py, stage 4</a>
<li><a href="#plural.stage5">17.6. plural.py, stage 5</a>
<li><a href="#plural.stage6">17.7. plural.py, stage 6</a>
<li><a href="#plural.summary">17.8. Summary</a>
</ul>

<li><a href="#soundex">18. Performance Tuning</a><ul>
<li><a href="#soundex.divein">18.1. Diving in</a>
<li><a href="#soundex.timeit">18.2. Using the timeit Module</a>
<li><a href="#soundex.stage1">18.3. Optimizing Regular Expressions</a>
<li><a href="#soundex.stage2">18.4. Optimizing Dictionary Lookups</a>
<li><a href="#soundex.stage3">18.5. Optimizing List Operations</a>
<li><a href="#soundex.stage4">18.6. Optimizing String Manipulation</a>
<li><a href="#soundex.summary">18.7. Summary</a>
</ul></ul>

</ul>
<div class=chapter>
<h2 id="install">Chapter 1. Installing Python</h2>
<p>Welcome to Python. Let's dive in. In this chapter, you'll install the version of Python that's right for you.
<h2 id="install.choosing">1.1. Which Python is right for you?</h2>
<p>The first thing you need to do with Python is install it. Or do you?
<p>If you're using an account on a hosted server, your ISP may have already installed Python. Most popular Linux distributions come with Python in the default installation. Mac OS X 10.2 and later includes a command-line version of Python, although you'll probably want to install a version that includes a more Mac-like graphical interface.
<p>Windows does not come with any version of Python, but don't despair!  There are several ways to point-and-click your way to Python on Windows.
<p>As you can see already, Python runs on a great many operating systems. The full list includes Windows, Mac OS, Mac OS X, and all varieties of free <abbr>UNIX</abbr>-compatible systems like Linux. There are also versions that run on Sun Solaris, AS/400, Amiga, OS/2, BeOS, and a plethora
of other platforms you've probably never even heard of.
<p>What's more, Python programs written on one platform can, with a little care, run on <em>any</em> supported platform. For instance, I regularly develop Python programs on Windows and later deploy them on Linux.
<p>So back to the question that started this section, &#8220;Which Python is right for you?&#8221;  The answer is whichever one runs on the computer you already have.
<h2 id="install.windows">1.2. Python on Windows</h2>
<p>On Windows, you have a couple choices for installing Python.
<p>ActiveState makes a Windows installer for Python called ActivePython, which includes a complete version of Python, an <abbr>IDE</abbr> with a Python-aware code editor, plus some Windows extensions for Python that allow complete access to Windows-specific services, <abbr>API</abbr>s, and the Windows Registry.
<p>ActivePython is freely downloadable, although it is not open source. It is the <abbr>IDE</abbr> I used to learn Python, and I recommend you try it unless you have a specific reason not to. One such reason might be that ActiveState is generally
several months behind in updating their ActivePython installer when new version of Python are released. If you absolutely need the latest version of Python and ActivePython is still a version behind as you read this, you'll want to use the second option for installing Python on Windows.
<p>The second option is the &#8220;official&#8221; Python installer, distributed by the people who develop Python itself. It is freely downloadable and open source, and it is always current with the latest version of Python.
<div class=procedure>
<h3>Procedure 1.1. Option 1: Installing ActivePython</h3>
<p>Here is the procedure for installing ActivePython:
<ol>
<li>
<p>Download ActivePython from <a href="http://www.activestate.com/Products/ActivePython/">http://www.activestate.com/Products/ActivePython/</a>.

<li>
<p>If you are using Windows 95, Windows 98, or Windows ME, you will also need to download and install <a href="http://download.microsoft.com/download/WindowsInstaller/Install/2.0/W9XMe/EN-US/InstMsiA.exe">Windows Installer 2.0</a> before installing ActivePython.

<li>
<p>Double-click the installer, <code>ActivePython-2.2.2-224-win32-ix86.msi</code>.

<li>
<p>Step through the installer program.

<li>
<p>If space is tight, you can do a custom installation and deselect the documentation, but I don't recommend this unless you
         absolutely can't spare the 14MB.

<li>
<p>After the installation is complete, close the installer and choose Start->Programs->ActiveState ActivePython 2.2->PythonWin IDE. You'll see something like the following:

</ol>
<pre class=screen>
<samp>PythonWin 2.2.2 (#37, Nov 26 2002, 10:24:37) [MSC 32 bit (Intel)] on win32.
Portions Copyright 1994-2001 Mark Hammond (mhammond@skippinet.com.au) -
see 'Help/About PythonWin' for further copyright information.</samp>
<samp class=prompt>>>> </samp><kbd></kbd>
</pre><div class=procedure>
<h3>Procedure 1.2. Option 2: Installing Python from <a href="http://www.python.org/" title="Python language home page">Python.org</a></h3>
<ol>
<li>
<p>Download the latest Python Windows installer by going to <a href="http://www.python.org/ftp/python/">http://www.python.org/ftp/python/</a> and selecting the highest version number listed, then downloading the <code>.exe</code> installer.

<li>
<p>Double-click the installer, <code>Python-2.xxx.yyy.exe</code>. The name will depend on the version of Python available when you read this.

<li>
<p>Step through the installer program.

<li>
<p>If disk space is tight, you can deselect the HTMLHelp file, the utility scripts (<code>Tools/</code>), and/or the test suite (<code>Lib/test/</code>).

<li>
<p>If you do not have administrative rights on your machine, you can select Advanced Options, then choose Non-Admin Install. This just affects where Registry entries and Start menu shortcuts are created.

<li>
<p>After the installation is complete, close the installer and select Start->Programs->Python 2.3->IDLE (Python GUI). You'll see something like the following:

</ol>
<pre class=screen>
<samp>Python 2.3.2 (#49, Oct  2 2003, 20:02:00) [MSC v.1200 32 bit (Intel)] on win32
Type "copyright", "credits" or "license()" for more information.

    ****************************************************************
    Personal firewall software may warn about the connection IDLE
    makes to its subprocess using this computer's internal loopback
    interface.  This connection is not visible on any external
    interface and no data is sent to or received from the Internet.
    ****************************************************************
    
IDLE 1.0</samp>
<samp class=prompt>>>> </samp><kbd></kbd>
</pre><h2 id="install.macosx">1.3. Python on Mac OS X</h2>
<p>On Mac OS X, you have two choices for installing Python: install it, or don't install it. You probably want to install it.
<p>Mac OS X 10.2 and later comes with a command-line version of Python preinstalled. If you are comfortable with the command line, you can use this version for the first third of the book. However,
the preinstalled version does not come with an <abbr>XML</abbr> parser, so when you get to the <abbr>XML</abbr> chapter, you'll need to install the full version.
<p>Rather than using the preinstalled version, you'll probably want to install the latest version, which also comes with a graphical
interactive shell.
<div class=procedure>
<h3>Procedure 1.3. Running the Preinstalled Version of Python on Mac OS X</h3>
<p>To use the preinstalled version of Python, follow these steps:
<ol>
<li>
<p>Open the <code>/Applications</code> folder.

<li>
<p>Open the <code>Utilities</code> folder.

<li>
<p>Double-click <code>Terminal</code> to open a terminal window and get to a command line.

<li>
<p>Type <kbd>python</kbd> at the command prompt.

</ol>
<p>Try it out:
<pre class=screen>
Welcome to Darwin!
<samp class=prompt>[localhost:~] you% </samp>python
<samp>Python 2.2 (#1, 07/14/02, 23:25:09)
[GCC Apple cpp-precomp 6.14] on darwin
Type "help", "copyright", "credits", or "license" for more information.</samp>
<samp class=prompt>>>> </samp><kbd>[press Ctrl+D to get back to the command prompt]</kbd>
<samp class=prompt>[localhost:~] you% </samp>
</pre><div class=procedure>
<h3>Procedure 1.4. Installing the Latest Version of Python on Mac OS X</h3>
<p>Follow these steps to download and install the latest version of Python:
<ol>
<li>
<p>Download the <code>MacPython-OSX</code> disk image from <a href="http://homepages.cwi.nl/~jack/macpython/download.html">http://homepages.cwi.nl/~jack/macpython/download.html</a>.

<li>
<p>If your browser has not already done so, double-click <code>MacPython-OSX-2.3-1.dmg</code> to mount the disk image on your desktop.

<li>
<p>Double-click the installer, <code>MacPython-OSX.pkg</code>.

<li>
<p>The installer will prompt you for your administrative username and password.

<li>
<p>Step through the installer program.

<li>
<p>After installation is complete, close the installer and open the <code>/Applications</code> folder.

<li>
<p>Open the <code>MacPython-2.3</code> folder

<li>
<p>Double-click <code>PythonIDE</code> to launch Python.

</ol>
<p>The MacPython <abbr>IDE</abbr> should display a splash screen, then take you to the interactive shell. If the interactive shell does not appear, select
Window->Python Interactive (<kbd class=shortcut>Cmd-0</kbd>). The opening window will look something like this:
<pre class=screen>
<samp>Python 2.3 (#2, Jul 30 2003, 11:45:28)
[GCC 3.1 20020420 (prerelease)]
Type "copyright", "credits" or "license" for more information.
MacPython IDE 1.0.1</samp>
<samp class=prompt>>>> </samp><kbd></kbd>
</pre><p>Note that once you install the latest version, the pre-installed version is still present. If you are running scripts from
the command line, you need to be aware which version of Python you are using.
<div class=example><h3>Example 1.1. Two versions of Python</h3><pre class=screen>
<samp class=prompt>[localhost:~] you% </samp>python
<samp>Python 2.2 (#1, 07/14/02, 23:25:09)
[GCC Apple cpp-precomp 6.14] on darwin
Type "help", "copyright", "credits", or "license" for more information.</samp>
<samp class=prompt>>>> </samp><kbd>[press Ctrl+D to get back to the command prompt]</kbd>
<samp class=prompt>[localhost:~] you% </samp>/usr/local/bin/python
<samp>Python 2.3 (#2, Jul 30 2003, 11:45:28)
[GCC 3.1 20020420 (prerelease)] on darwin
Type "help", "copyright", "credits", or "license" for more information.</samp>
<samp class=prompt>>>> </samp><kbd>[press Ctrl+D to get back to the command prompt]</kbd>
<samp class=prompt>[localhost:~] you% </samp>
</pre><h2 id="install.macos9">1.4. Python on Mac OS 9</h2>
<p>Mac OS 9 does not come with any version of Python, but installation is very simple, and there is only one choice.
<div class=procedure>
<p>Follow these steps to install Python on Mac OS 9:
<ol>
<li>
<p>Download the <code>MacPython23full.bin</code> file from <a href="http://homepages.cwi.nl/~jack/macpython/download.html">http://homepages.cwi.nl/~jack/macpython/download.html</a>.

<li>
<p>If your browser does not decompress the file automatically, double-click <code>MacPython23full.bin</code> to decompress the file with Stuffit Expander.

<li>
<p>Double-click the installer, <code>MacPython23full</code>.

<li>
<p>Step through the installer program.

<li>
<p>AFter installation is complete, close the installer and open the <code>/Applications</code> folder.

<li>
<p>Open the <code>MacPython-OS9 2.3</code> folder.

<li>
<p>Double-click <code>Python IDE</code> to launch Python.

</ol>
<p>The MacPython <abbr>IDE</abbr> should display a splash screen, and then take you to the interactive shell. If the interactive shell does not appear, select
Window->Python Interactive (<kbd class=shortcut>Cmd-0</kbd>). You'll see a screen like this:
<pre class=screen>
<samp>Python 2.3 (#2, Jul 30 2003, 11:45:28)
[GCC 3.1 20020420 (prerelease)]
Type "copyright", "credits" or "license" for more information.
MacPython IDE 1.0.1</samp>
<samp class=prompt>>>> </samp><kbd></kbd>
</pre><h2 id="install.redhat">1.5. Python on RedHat Linux</h2>
<p>Installing under UNIX-compatible operating systems such as Linux is easy if you're willing to install a binary package. Pre-built
binary packages are available for most popular Linux distributions. Or you can always compile from source.
<p>Download the latest Python <abbr>RPM</abbr> by going to <a href="http://www.python.org/ftp/python/">http://www.python.org/ftp/python/</a> and selecting the highest version number listed, then selecting the <code>rpms/</code> directory within that. Then download the <abbr>RPM</abbr> with the highest version number. You can install it with the <kbd>rpm</kbd> command, as shown here:
<div class=example><h3>Example 1.2. Installing on RedHat Linux 9</h3><pre class=screen>
<samp class=prompt>localhost:~$ </samp>su -
<samp class=prompt>Password: </samp>[enter your root password]
<samp class=prompt>[root@localhost root]# </samp>wget http://python.org/ftp/python/2.3/rpms/redhat-9/python2.3-2.3-5pydotorg.i386.rpm
<samp>Resolving python.org... done.
Connecting to python.org[194.109.137.226]:80... connected.
HTTP request sent, awaiting response... 200 OK
Length: 7,495,111 [application/octet-stream]
...</samp>
<samp class=prompt>[root@localhost root]# </samp>rpm -Uvh python2.3-2.3-5pydotorg.i386.rpm
<samp>Preparing...                ########################################### [100%]
   1:python2.3              ########################################### [100%]</samp>
<samp class=prompt>[root@localhost root]# </samp>python          <span>&#x2460;</span>
<samp>Python 2.2.2 (#1, Feb 24 2003, 19:13:11)
[GCC 3.2.2 20030222 (Red Hat Linux 3.2.2-4)] on linux2
Type "help", "copyright", "credits", or "license" for more information.</samp>
<samp class=prompt>>>> </samp><kbd>[press Ctrl+D to exit]</kbd>
<samp class=prompt>[root@localhost root]# </samp>python2.3       <span>&#x2461;</span>
<samp>Python 2.3 (#1, Sep 12 2003, 10:53:56)
[GCC 3.2.2 20030222 (Red Hat Linux 3.2.2-5)] on linux2
Type "help", "copyright", "credits", or "license" for more information.</samp>
<samp class=prompt>>>> </samp><kbd>[press Ctrl+D to exit]</kbd>
<samp class=prompt>[root@localhost root]# </samp>which python2.3 <span>&#x2462;</span>
/usr/bin/python2.3
</pre><div class=calloutlist>
<ol>
<li>Whoops!  Just typing <kbd>python</kbd> gives you the older version of Python -- the one that was installed by default. That's not the one you want.
<li>At the time of this writing, the newest version is called <kbd>python2.3</kbd>. You'll probably want to change the path on the first line of the sample scripts to point to the newer version.
<li>This is the complete path of the newer version of Python that you just installed. Use this on the <code>#!</code> line (the first line of each script) to ensure that scripts are running under the latest version of Python, and be sure to type <kbd>python2.3</kbd> to get into the interactive shell.
<h2 id="install.debian">1.6. Python on Debian <abbr>GNU</abbr>/Linux</h2>
<p>If you are lucky enough to be running Debian <abbr>GNU</abbr>/Linux, you install Python through the <kbd>apt</kbd> command.
<div class=example><h3>Example 1.3. Installing on Debian <abbr>GNU</abbr>/Linux</h3><pre class=screen>
<samp class=prompt>localhost:~$ </samp>su -
<samp class=prompt>Password: </samp>[enter your root password]
<samp class=prompt>localhost:~# </samp>apt-get install python
<samp>Reading Package Lists... Done
Building Dependency Tree... Done
The following extra packages will be installed:
  python2.3
Suggested packages:
  python-tk python2.3-doc
The following NEW packages will be installed:
  python python2.3
0 upgraded, 2 newly installed, 0 to remove and 3 not upgraded.
Need to get 0B/2880kB of archives.
After unpacking 9351kB of additional disk space will be used.</samp>
<samp class=prompt>Do you want to continue? [Y/n] </samp>Y
<samp>Selecting previously deselected package python2.3.
(Reading database ... 22848 files and directories currently installed.)
Unpacking python2.3 (from .../python2.3_2.3.1-1_i386.deb) ...
Selecting previously deselected package python.
Unpacking python (from .../python_2.3.1-1_all.deb) ...
Setting up python (2.3.1-1) ...
Setting up python2.3 (2.3.1-1) ...
Compiling python modules in /usr/lib/python2.3 ...
Compiling optimized python modules in /usr/lib/python2.3 ...</samp>
<samp class=prompt>localhost:~# </samp>exit
logout
<samp class=prompt>localhost:~$ </samp>python
<samp>Python 2.3.1 (#2, Sep 24 2003, 11:39:14)
[GCC 3.3.2 20030908 (Debian prerelease)] on linux2
Type "help", "copyright", "credits" or "license" for more information.</samp>
<samp class=prompt>>>> </samp><kbd>[press Ctrl+D to exit]</kbd>
</pre><h2 id="install.source">1.7. Python Installation from Source</h2>
<p>If you prefer to build from source, you can download the Python source code from <a href="http://www.python.org/ftp/python/">http://www.python.org/ftp/python/</a>. Select the highest version number listed, download the <code>.tgz</code> file), and then do the usual <kbd>configure</kbd>, <kbd>make</kbd>, <kbd>make install</kbd> dance.
<div class=example><h3>Example 1.4. Installing from source</h3><pre class=screen>
<samp class=prompt>localhost:~$ </samp>su -
<samp class=prompt>Password: </samp>[enter your root password]
<samp class=prompt>localhost:~# </samp>wget http://www.python.org/ftp/python/2.3/Python-2.3.tgz
<samp>Resolving www.python.org... done.
Connecting to www.python.org[194.109.137.226]:80... connected.
HTTP request sent, awaiting response... 200 OK
Length: 8,436,880 [application/x-tar]
...</samp>
<samp class=prompt>localhost:~# </samp>tar xfz Python-2.3.tgz
<samp class=prompt>localhost:~# </samp>cd Python-2.3
<samp class=prompt>localhost:~/Python-2.3# </samp>./configure
<samp>checking MACHDEP... linux2
checking EXTRAPLATDIR...
checking for --without-gcc... no
...</samp>
<samp class=prompt>localhost:~/Python-2.3# </samp>make
<samp>gcc -pthread -c -fno-strict-aliasing -DNDEBUG -g -O3 -Wall -Wstrict-prototypes
-I. -I./Include  -DPy_BUILD_CORE -o Modules/python.o Modules/python.c
gcc -pthread -c -fno-strict-aliasing -DNDEBUG -g -O3 -Wall -Wstrict-prototypes
-I. -I./Include  -DPy_BUILD_CORE -o Parser/acceler.o Parser/acceler.c
gcc -pthread -c -fno-strict-aliasing -DNDEBUG -g -O3 -Wall -Wstrict-prototypes
-I. -I./Include  -DPy_BUILD_CORE -o Parser/grammar1.o Parser/grammar1.c
...</samp>
<samp class=prompt>localhost:~/Python-2.3# </samp>make install
<samp>/usr/bin/install -c python /usr/local/bin/python2.3
...</samp>
<samp class=prompt>localhost:~/Python-2.3# </samp>exit
logout
<samp class=prompt>localhost:~$ </samp>which python
/usr/local/bin/python
<samp class=prompt>localhost:~$ </samp>python
<samp>Python 2.3.1 (#2, Sep 24 2003, 11:39:14)
[GCC 3.3.2 20030908 (Debian prerelease)] on linux2
Type "help", "copyright", "credits" or "license" for more information.</samp>
<samp class=prompt>>>> </samp><kbd>[press Ctrl+D to get back to the command prompt]</kbd>
<samp class=prompt>localhost:~$ </samp>
</pre><h2 id="install.shell">1.8. The Interactive Shell</h2>
<p>Now that you have Python installed, what's this interactive shell thing you're running?
<p>It's like this: Python leads a double life. It's an interpreter for scripts that you can run from the command line or run like applications, by
double-clicking the scripts. But it's also an interactive shell that can evaluate arbitrary statements and expressions. 
This is extremely useful for debugging, quick hacking, and testing. I even know some people who use the Python interactive shell in lieu of a calculator!
<p>Launch the Python interactive shell in whatever way works on your platform, and let's dive in with the steps shown here:
<div class=example><h3>Example 1.5. First Steps in the Interactive Shell</h3><pre class=screen>
<samp class=prompt>>>> </samp><kbd>1 + 1</kbd>               <span>&#x2460;</span>
2
<samp class=prompt>>>> </samp><kbd>print 'hello world'</kbd> <span>&#x2461;</span>
hello world
<samp class=prompt>>>> </samp><kbd>x = 1</kbd>               <span>&#x2462;</span>
<samp class=prompt>>>> </samp><kbd>y = 2</kbd>
<samp class=prompt>>>> </samp><kbd>x + y</kbd>
3
</pre><div class=calloutlist>
<ol>
<li>The Python interactive shell can evaluate arbitrary Python expressions, including any basic arithmetic expression.
<li>The interactive shell can execute arbitrary Python statements, including the <kbd>print</kbd> statement.
<li>You can also assign values to variables, and the values will be remembered as long as the shell is open (but not any longer
            than that).
<h2 id="install.summary">1.9. Summary</h2>
<p>You should now have a version of Python installed that works for you.
<p>Depending on your platform, you may have more than one version of Python intsalled. If so, you need to be aware of your paths. If simply typing <kbd>python</kbd> on the command line doesn't run the version of Python that you want to use, you may need to enter the full pathname of your preferred version.
<p>Congratulations, and welcome to Python.



<h2 id="odbchelper.docstring">2.3. Documenting Functions</h2>
<p>You can document a Python function by giving it a <code>docstring</code>.
<div class=example><h3 id="odbchelper.triplequotes">Example 2.2. Defining the <code>buildConnectionString</code> Function's <code>docstring</code></h3><pre><code>
def buildConnectionString(params):
    """Build a connection string from a dictionary of parameters.

    Returns string."""</pre><p>Triple quotes signify a multi-line string. Everything between the start and end quotes is part of a single string, including
   carriage returns and other quote characters. You can use them anywhere, but you'll see them most often used when defining
   a <code>docstring</code>.
<table id="compare.quoting.perl" class=note border="0" summary="">

<td rowspan="2" align="center" valign="top" width="1%"><img src="images/note.png" alt="Note" title="" width="24" height="24"><td colspan="2" align="left" valign="top" width="99%">Triple quotes are also an easy way to define a string with both single and double quotes, like <code>qq/.../</code> in Perl.
<p>Everything between the triple quotes is the function's <code>docstring</code>, which documents what the function does. A <code>docstring</code>, if it exists, must be the first thing defined in a function (that is, the first thing after the colon). You don't technically
need to give your function a <code>docstring</code>, but you always should. I know you've heard this in every programming class you've ever taken, but Python gives you an added incentive: the <code>docstring</code> is available at runtime as an attribute of the function.
<table id="tip.docstring" class=note border="0" summary="">

<td rowspan="2" align="center" valign="top" width="1%"><img src="images/note.png" alt="Note" title="" width="24" height="24"><td colspan="2" align="left" valign="top" width="99%">Many Python <abbr>IDE</abbr>s use the <code>docstring</code> to provide context-sensitive documentation, so that when you type a function name, its <code>docstring</code> appears as a tooltip. This can be incredibly helpful, but it's only as good as the <code>docstring</code>s you write.





<h2 id="odbchelper.objects">2.4. Everything Is an Object</h2>
<h2 id="odbchelper.testing">2.6. Testing Modules</h2>
<p>Python modules are objects and have several useful attributes. You can use this to easily test your modules as you write them.
   Here's an example that uses the <code>if</code> <code>__name__</code> trick.
<pre id="odbchelper.ifnametrick" class=programlisting>
if __name__ == "__main__":</pre><p>Some quick observations before you get to the good stuff. First, parentheses are not required around the <code>if</code> expression. Second, the <code>if</code> statement ends with a colon, and is followed by <a href="#odbchelper.indenting" title="2.5. Indenting Code">indented code</a>.
<table id="compare.equals.c" class=note border="0" summary="">

<td rowspan="2" align="center" valign="top" width="1%"><img src="images/note.png" alt="Note" title="" width="24" height="24"><td colspan="2" align="left" valign="top" width="99%">Like <abbr>C</abbr>, Python uses <code>==</code> for comparison and <code>=</code> for assignment. Unlike <abbr>C</abbr>, Python does not support in-line assignment, so there's no chance of accidentally assigning the value you thought you were comparing.
<p>So why is this particular <code>if</code> statement a trick?  Modules are objects, and all modules have a built-in attribute <code>__name__</code>. A module's <code>__name__</code> depends on how you're using the module. If you <code>import</code> the module, then <code>__name__</code> is the module's filename, without a directory path or file extension. But you can also run the module directly as a standalone
program, in which case <code>__name__</code> will be a special default value, <code>__main__</code>.
<pre class=screen><samp class=prompt>>>> </samp><kbd>import odbchelper</kbd>
<samp class=prompt>>>> </samp>odbchelper.<code>__name__</code>
'odbchelper'</pre><p>Knowing this, you can design a test suite for your module within the module itself by putting it in this <code>if</code> statement. When you run the module directly, <code>__name__</code> is <code>__main__</code>, so the test suite executes. When you import the module, <code>__name__</code> is something else, so the test suite is ignored. This makes it easier to develop and debug new modules before integrating
them into a larger program.
<table id="tip.mac.runasmain" class=tip border="0" summary="">

<td rowspan="2" align="center" valign="top" width="1%"><img src="images/tip.png" alt="Tip" title="" width="24" height="24"><td colspan="2" align="left" valign="top" width="99%">On MacPython, there is an additional step to make the <code>if</code> <code>__name__</code> trick work. Pop up the module's options menu by clicking the black triangle in the upper-right corner of the window, and
      make sure Run as __main__ is checked.
<div class=itemizedlist>
<h3>Further Reading on Importing Modules</h3>
<ul>
<li><a href="http://www.python.org/doc/current/ref/"><i class=citetitle>Python Reference Manual</i></a> discusses the low-level details of <a href="http://www.python.org/doc/current/ref/import.html">importing modules</a>.

</ul>












<h2 id="odbchelper.vardef">3.4. Declaring variables</h2>
<p>Now that you know something about dictionaries, tuples, and lists (oh my!), let's get back to the sample program from <a href="#odbchelper">Chapter 2</a>, <code>odbchelper.py</code>.
<p>Python has local and global variables like most other languages, but it has no explicit variable declarations. Variables spring
   into existence by being assigned a value, and they are automatically destroyed when they go out of scope.
<div class=example><h3 id="myparamsdef">Example 3.17. Defining the <var>myParams</var> Variable</h3><pre><code>
if __name__ == "__main__":
    myParams = {"server":"mpilgrim", \
                "database":"master", \
                "uid":"sa", \
                "pwd":"secret" \
                }</pre><p>Notice the indentation. An <code>if</code> statement is a code block and needs to be indented just like a function.
<p>Also notice that the variable assignment is one command split over several lines, with a backslash (&#8220;<code>\</code>&#8221;) serving as a line-continuation marker.
<table id="tip.multiline" class=note border="0" summary="">

<td rowspan="2" align="center" valign="top" width="1%"><img src="images/note.png" alt="Note" title="" width="24" height="24"><td colspan="2" align="left" valign="top" width="99%">When a command is split among several lines with the line-continuation marker (&#8220;<code>\</code>&#8221;), the continued lines can be indented in any manner; Python's normally stringent indentation rules do not apply. If your Python <abbr>IDE</abbr> auto-indents the continued line, you should probably accept its default unless you have a burning reason not to.
<p><a name="tip.implicitmultiline"></a>Strictly speaking, expressions in parentheses, straight brackets, or curly braces (like <a href="#myparamsdef" title="Example 3.17. Defining the myParams Variable">defining a dictionary</a>) can be split into multiple lines with or without the line continuation character (&#8220;<code>\</code>&#8221;). I like to include the backslash even when it's not required because I think it makes the code easier to read, but that's
a matter of style.
<p>Third, you never declared the variable <var>myParams</var>, you just assigned a value to it. This is like VBScript without the <code>option explicit</code> option. Luckily, unlike VBScript, Python will not allow you to reference a variable that has never been assigned a value; trying to do so will raise an exception.
<h3>3.4.1. Referencing Variables</h3>
<div class=example><h3 id="odbchelper.unboundvariable">Example 3.18. Referencing an Unbound Variable</h3><pre class=screen><samp class=prompt>>>> </samp><kbd>x</kbd>
<samp class=traceback>Traceback (innermost last):
  File "&lt;interactive input>", line 1, in ?
NameError: There is no variable named 'x'</samp>
<samp class=prompt>>>> </samp><kbd>x = 1</kbd>
<samp class=prompt>>>> </samp><kbd>x</kbd>
1</pre><p>You will thank Python for this one day.
<h3 id="odbchelper.multiassign">3.4.2. Assigning Multiple Values at Once</h3>
<p>One of the cooler programming shortcuts in Python is using sequences to assign multiple values at once.
<div class=example><h3>Example 3.19. Assigning multiple values at once</h3><pre class=screen><samp class=prompt>>>> </samp><kbd>v = ('a', 'b', 'e')</kbd>
<samp class=prompt>>>> </samp><kbd>(x, y, z) = v</kbd>     <span>&#x2460;</span>
<samp class=prompt>>>> </samp><kbd>x</kbd>
'a'
<samp class=prompt>>>> </samp><kbd>y</kbd>
'b'
<samp class=prompt>>>> </samp><kbd>z</kbd>
'e'</pre><div class=calloutlist>
<ol>
<li><var>v</var> is a tuple of three elements, and <code>(x, y, z)</code> is a tuple of three variables. Assigning one to the other assigns each of the values of <var>v</var> to each of the variables, in order.
<p>This has all sorts of uses. I often want to assign names to a range of values. In <abbr>C</abbr>, you would use <code>enum</code> and manually list each constant and its associated value, which seems especially tedious when the values are consecutive.
   In Python, you can use the built-in <code>range</code> function with multi-variable assignment to quickly assign consecutive values.
<div class=example><h3 id="odbchelper.multiassign.range">Example 3.20. Assigning Consecutive Values</h3><pre class=screen><samp class=prompt>>>> </samp><kbd>range(7)</kbd>              <span>&#x2460;</span>
[0, 1, 2, 3, 4, 5, 6]
<samp class=prompt>>>> </samp><kbd>(MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY) = range(7)</kbd> <span>&#x2461;</span>
<samp class=prompt>>>> </samp><kbd>MONDAY</kbd>                <span>&#x2462;</span>
0
<samp class=prompt>>>> </samp><kbd>TUESDAY</kbd>
1
<samp class=prompt>>>> </samp><kbd>SUNDAY</kbd>
6</pre><div class=calloutlist>
<ol>
<li>The built-in <code>range</code> function returns a list of integers. In its simplest form, it takes an upper limit and returns a zero-based list counting
               up to but not including the upper limit. (If you like, you can pass other parameters to specify a base other than <code>0</code> and a step other than <code>1</code>. You can <code>print range.__doc__</code> for details.)
<li><var>MONDAY</var>, <var>TUESDAY</var>, <var>WEDNESDAY</var>, <var>THURSDAY</var>, <var>FRIDAY</var>, <var>SATURDAY</var>, and <var>SUNDAY</var> are the variables you're defining. (This example came from the <code>calendar</code> module, a fun little module that prints calendars, like the <abbr>UNIX</abbr> program <code>cal</code>. The <code>calendar</code> module defines integer constants for days of the week.)
<li>Now each variable has its value: <var>MONDAY</var> is <code>0</code>, <var>TUESDAY</var> is <code>1</code>, and so forth.
<p>You can also use multi-variable assignment to build functions that return multiple values, simply by returning a tuple of
   all the values. The caller can treat it as a tuple, or assign the values to individual variables. Many standard Python libraries do this, including the <code>os</code> module, which you'll discuss in <a href="#filehandling">Chapter 6</a>.
<div class=itemizedlist>
<h3>Further Reading on Variables</h3>
<ul>
<li><a href="http://www.python.org/doc/current/ref/"><i class=citetitle>Python Reference Manual</i></a> shows examples of <a href="http://www.python.org/doc/current/ref/implicit-joining.html">when you can skip the line continuation character</a> and <a href="http://www.python.org/doc/current/ref/explicit-joining.html">when you need to use it</a>.

<li><a href="http://www.ibiblio.org/obp/thinkCSpy/" title="Python book for computer science majors"><i class=citetitle>How to Think Like a Computer Scientist</i></a> shows how to use multi-variable assignment to <a href="http://www.ibiblio.org/obp/thinkCSpy/chap09.htm">swap the values of two variables</a>.

</ul>
<h2 id="odbchelper.map">3.6. Mapping Lists</h2>
<p>One of the most powerful features of Python is the list comprehension, which provides a compact way of mapping a list into another list by applying a function to each
   of the elements of the list.
<div class=example><h3>Example 3.24. Introducing List Comprehensions</h3><pre class=screen><samp class=prompt>>>> </samp><kbd>li = [1, 9, 8, 4]</kbd>
<samp class=prompt>>>> </samp><kbd>[elem*2 for elem in li]</kbd>      <span>&#x2460;</span>
[2, 18, 16, 8]
<samp class=prompt>>>> </samp><kbd>li</kbd>         <span>&#x2461;</span>
[1, 9, 8, 4]
<samp class=prompt>>>> </samp><kbd>li = [elem*2 for elem in li]</kbd> <span>&#x2462;</span>
<samp class=prompt>>>> </samp><kbd>li</kbd>
[2, 18, 16, 8]</pre><div class=calloutlist>
<ol>
<li>To make sense of this, look at it from right to left. <var>li</var> is the list you're mapping. Python loops through <var>li</var> one element at a time, temporarily assigning the value of each element to the variable <var>elem</var>. Python then applies the function <code><var>elem</var>*2</code> and appends that result to the returned list.
<li>Note that list comprehensions do not change the original list.
<li>It is safe to assign the result of a list comprehension to the variable that you're mapping. Python constructs the new list in memory, and when the list comprehension is complete, it assigns the result to the variable.

<p>Here are the list comprehensions in the <code>buildConnectionString</code> function that you declared in <a href="#odbchelper">Chapter 2</a>:<pre><code>
["%s=%s" % (k, v) for k, v in params.items()]</pre><p>First, notice that you're calling the <code>items</code> function of the <var>params</var> dictionary. This function returns a list of tuples of all the data in the dictionary.
<div class=example><h3 id="odbchelper.items">Example 3.25. The <code>keys</code>, <code>values</code>, and <code>items</code> Functions</h3><pre class=screen><samp class=prompt>>>> </samp><kbd>params = {"server":"mpilgrim", "database":"master", "uid":"sa", "pwd":"secret"}</kbd>
<samp class=prompt>>>> </samp><kbd>params.keys()</kbd>   <span>&#x2460;</span>
['server', 'uid', 'database', 'pwd']
<samp class=prompt>>>> </samp><kbd>params.values()</kbd> <span>&#x2461;</span>
['mpilgrim', 'sa', 'master', 'secret']
<samp class=prompt>>>> </samp><kbd>params.items()</kbd>  <span>&#x2462;</span>
[('server', 'mpilgrim'), ('uid', 'sa'), ('database', 'master'), ('pwd', 'secret')]</pre><div class=calloutlist>
<ol>
<li>The <code>keys</code> method of a dictionary returns a list of all the keys. The list is not in the order in which the dictionary was defined
            (remember that elements in a dictionary are unordered), but it is a list.
<li>The <code>values</code> method returns a list of all the values. The list is in the same order as the list returned by <code>keys</code>, so <code>params.values()[n] == params[params.keys()[n]]</code> for all values of <var>n</var>.
<li>The <code>items</code> method returns a list of tuples of the form <code>(<var>key</var>, <var>value</var>)</code>. The list contains all the data in the dictionary.
<p>Now let's see what <code>buildConnectionString</code> does. It takes a list, <code><var>params</var>.<code>items</code>()</code>, and maps it to a new list by applying string formatting to each element. The new list will have the same number of elements
as <code><var>params</var>.<code>items</code>()</code>, but each element in the new list will be a string that contains both a key and its associated value from the <var>params</var> dictionary.
<div class=example><h3>Example 3.26. List Comprehensions in <code>buildConnectionString</code>, Step by Step</h3><pre class=screen><samp class=prompt>>>> </samp><kbd>params = {"server":"mpilgrim", "database":"master", "uid":"sa", "pwd":"secret"}</kbd>
<samp class=prompt>>>> </samp><kbd>params.items()</kbd>
[('server', 'mpilgrim'), ('uid', 'sa'), ('database', 'master'), ('pwd', 'secret')]
<samp class=prompt>>>> </samp><kbd>[k for k, v in params.items()]</kbd>                <span>&#x2460;</span>
['server', 'uid', 'database', 'pwd']
<samp class=prompt>>>> </samp><kbd>[v for k, v in params.items()]</kbd>                <span>&#x2461;</span>
['mpilgrim', 'sa', 'master', 'secret']
<samp class=prompt>>>> </samp><kbd>["%s=%s" % (k, v) for k, v in params.items()]</kbd> <span>&#x2462;</span>
['server=mpilgrim', 'uid=sa', 'database=master', 'pwd=secret']</pre><div class=calloutlist>
<ol>
<li>Note that you're using two variables to iterate through the <code>params.items()</code> list. This is another use of <a href="#odbchelper.multiassign" title="3.4.2. Assigning Multiple Values at Once">multi-variable assignment</a>. The first element of <code>params.items()</code> is <code>('server', 'mpilgrim')</code>, so in the first iteration of the list comprehension, <var>k</var> will get <code>'server'</code> and <var>v</var> will get <code>'mpilgrim'</code>. In this case, you're ignoring the value of <var>v</var> and only including the value of <var>k</var> in the returned list, so this list comprehension ends up being equivalent to <code><var>params</var>.<code>keys</code>()</code>.
<li>Here you're doing the same thing, but ignoring the value of <var>k</var>, so this list comprehension ends up being equivalent to <code><var>params</var>.<code>values</code>()</code>.
<li>Combining the previous two examples with some simple <a href="#odbchelper.stringformatting" title="3.5. Formatting Strings">string formatting</a>, you get a list of strings that include both the key and value of each element of the dictionary. This looks suspiciously
            like the <a href="#odbchelper.output">output</a> of the program. All that remains is to join the elements in this list into a single string.
<div class=itemizedlist>
<h3>Further Reading on List Comprehensions</h3>
<ul>
<li><a href="http://www.python.org/doc/current/tut/tut.html"><i class=citetitle>Python Tutorial</i></a> discusses another way to map lists <a href="http://www.python.org/doc/current/tut/node7.html#SECTION007130000000000000000">using the built-in <code>map</code> function</a>.

<li><a href="http://www.python.org/doc/current/tut/tut.html"><i class=citetitle>Python Tutorial</i></a> shows how to <a href="http://www.python.org/doc/current/tut/node7.html#SECTION007140000000000000000">do nested list comprehensions</a>.

</ul>







(String splitting stuff was here)









<p>Before diving into the next chapter, make sure you're comfortable doing all of these things:
<div class=itemizedlist>
<ul>
<li>Using the Python <abbr>IDE</abbr> to test expressions interactively

<li>Writing Python programs and <a href="#odbchelper.testing" title="2.6. Testing Modules">running them from within your <abbr>IDE</abbr></a>, or from the command line

<li><a href="#odbchelper.import" title="Example 2.3. Accessing the buildConnectionString Function's docstring">Importing modules</a> and calling their functions

<li><a href="#odbchelper.funcdef" title="2.2. Declaring Functions">Declaring functions</a> and using <a href="#odbchelper.docstring" title="2.3. Documenting Functions"><code>docstring</code>s</a>, <a href="#odbchelper.vardef" title="3.4. Declaring variables">local variables</a>, and <a href="#odbchelper.indenting" title="2.5. Indenting Code">proper indentation</a>
<li>Defining <a href="#odbchelper.dict" title="3.1. Introducing Dictionaries">dictionaries</a>, <a href="#odbchelper.tuple" title="3.3. Introducing Tuples">tuples</a>, and <a href="#odbchelper.list" title="3.2. Introducing Lists">lists</a>
<li>Accessing attributes and methods of <a href="#odbchelper.objects" title="2.4. Everything Is an Object">any object</a>, including strings, lists, dictionaries, functions, and modules

<li>Concatenating values through <a href="#odbchelper.stringformatting" title="3.5. Formatting Strings">string formatting</a>
<li><a href="#odbchelper.map" title="3.6. Mapping Lists">Mapping lists</a> into other lists using list comprehensions

<li><a href="#odbchelper.join" title="3.7. Joining Lists and Splitting Strings">Splitting strings</a> into lists and joining lists into strings

</ul>
<div class=chapter>
<h2 id="apihelper">Chapter 4. The Power Of Introspection</h2>
<p>This chapter covers one of Python's strengths: introspection. As you know, <a href="#odbchelper.objects" title="2.4. Everything Is an Object">everything in Python is an object</a>, and introspection is code looking at other modules and functions in memory as objects, getting information about them, and
manipulating them. Along the way, you'll define functions with no name, call functions with arguments out of order, and reference
functions whose names you don't even know ahead of time.
<h2 id="apihelper.divein">4.1. Diving In</h2>
<p>Here is a complete, working Python program. You should understand a good deal about it just by looking at it. The numbered lines illustrate concepts covered
   in <a href="#odbchelper" title="Chapter 2. Your First Python Program">Chapter 2, <i>Your First Python Program</i></a>. Don't worry if the rest of the code looks intimidating; you'll learn all about it throughout this chapter.
<div class=example><h3>Example 4.1. <code>apihelper.py</code></h3>
<p>If you have not already done so, you can <a href="http://diveintopython3.org/download/diveintopython3-examples-5.4.zip" title="Download example scripts">download this and other examples</a> used in this book.
<pre><code>
def info(object, spacing=10, collapse=1): <span>&#x2460;</span> <span>&#x2461;</span> <span>&#x2462;</span>
    """Print methods and docstrings.
    
    Takes module, class, list, dictionary, or string."""
    methodList = [method for method in dir(object) if callable(getattr(object, method))]
    processFunc = collapse and (lambda s: " ".join(s.split())) or (lambda s: s)
    print "\n".join(["%s %s" %
    (method.ljust(spacing),
     processFunc(str(getattr(object, method).__doc__)))
   for method in methodList])

if __name__ == "__main__":                <span>&#x2463;</span> <span>&#x2464;</span>
    print info.__doc__</pre><div class=calloutlist>
<ol>
<li>This module has one function, <code>info</code>. According to its <a href="#odbchelper.funcdef" title="2.2. Declaring Functions">function declaration</a>, it takes three parameters: <var>object</var>, <var>spacing</var>, and <var>collapse</var>. The last two are actually optional parameters, as you'll see shortly.
<li>The <code>info</code> function has a multi-line <a href="#odbchelper.docstring" title="2.3. Documenting Functions"><code>docstring</code></a> that succinctly describes the function's purpose. Note that no return value is mentioned; this function will be used solely
            for its effects, rather than its value.
<li>Code within the function is <a href="#odbchelper.indenting" title="2.5. Indenting Code">indented</a>.
<li>The <code>if __name__</code> <a href="#odbchelper.ifnametrick">trick</a> allows this program do something useful when run by itself, without interfering with its use as a module for other programs.
             In this case, the program simply prints out the <code>docstring</code> of the <code>info</code> function.
<li><a href="#odbchelper.ifnametrick"><code>if</code> statements</a> use <code>==</code> for comparison, and parentheses are not required.
<p>The <code>info</code> function is designed to be used by you, the programmer, while working in the Python <abbr>IDE</abbr>. It takes any object that has functions or methods (like a module, which has functions, or a list, which has methods) and
prints out the functions and their <code>docstring</code>s.
<div class=example><h3>Example 4.2. Sample Usage of <code>apihelper.py</code></h3><pre class=screen><samp class=prompt>>>> </samp><kbd>from apihelper import info</kbd>
<samp class=prompt>>>> </samp><kbd>li = []</kbd>
<samp class=prompt>>>> </samp><kbd>info(li)</kbd>
<samp>append     L.append(object) -- append object to end
count      L.count(value) -> integer -- return number of occurrences of value
extend     L.extend(list) -- extend list by appending list elements
index      L.index(value) -> integer -- return index of first occurrence of value
insert     L.insert(index, object) -- insert object before index
pop        L.pop([index]) -> item -- remove and return item at index (default last)
remove     L.remove(value) -- remove first occurrence of value
reverse    L.reverse() -- reverse *IN PLACE*
sort       L.sort([cmpfunc]) -- sort *IN PLACE*; if given, cmpfunc(x, y) -> -1, 0, 1</span></pre><p>By default the output is formatted to be easy to read. Multi-line <code>docstring</code>s are collapsed into a single long line, but this option can be changed by specifying <code>0</code> for the <i class=parameter><code>collapse</code></i> argument. If the function names are longer than 10 characters, you can specify a larger value for the <i class=parameter><code>spacing</code></i> argument to make the output easier to read.
<div class=example><h3>Example 4.3. Advanced Usage of <code>apihelper.py</code></h3><pre class=screen><samp class=prompt>>>> </samp><kbd>import odbchelper</kbd>
<samp class=prompt>>>> </samp><kbd>info(odbchelper)</kbd>
buildConnectionString Build a connection string from a dictionary Returns string.
<samp class=prompt>>>> </samp><kbd>info(odbchelper, 30)</kbd>
buildConnectionString          Build a connection string from a dictionary Returns string.
<samp class=prompt>>>> </samp><kbd>info(odbchelper, 30, 0)</kbd>
<samp>buildConnectionString          Build a connection string from a dictionary
    
    Returns string.
</span></pre><h2 id="apihelper.optional">4.2. Using Optional and Named Arguments</h2>
<p>Python allows function arguments to have default values; if the function is called without the argument, the argument gets its default
   value. Futhermore, arguments can be specified in any order by using named arguments. Stored procedures in SQL Server Transact/<abbr>SQL</abbr> can do this, so if you're a SQL Server scripting guru, you can skim this part.

<p>Here is an example of <code>info</code>, a function with two optional arguments:<pre><code>
def info(object, spacing=10, collapse=1):</pre><p><var>spacing</var> and <var>collapse</var> are optional, because they have default values defined. <var>object</var> is required, because it has no default value. If <code>info</code> is called with only one argument, <var>spacing</var> defaults to <code>10</code> and <var>collapse</var> defaults to <code>1</code>. If <code>info</code> is called with two arguments, <var>collapse</var> still defaults to <code>1</code>.
<p>Say you want to specify a value for <var>collapse</var> but want to accept the default value for <var>spacing</var>. In most languages, you would be out of luck, because you would need to call the function with three arguments. But in
Python, arguments can be specified by name, in any order.
<div class=example><h3>Example 4.4. Valid Calls of <code>info</code></h3><pre><code>
info(odbchelper)  <span>&#x2460;</span>
info(odbchelper, 12)                <span>&#x2461;</span>
info(odbchelper, collapse=0)        <span>&#x2462;</span>
info(spacing=15, object=odbchelper) <span>&#x2463;</span></pre><div class=calloutlist>
<ol>
<li>With only one argument, <var>spacing</var> gets its default value of <code>10</code> and <var>collapse</var> gets its default value of <code>1</code>.
<li>With two arguments, <var>collapse</var> gets its default value of <code>1</code>.
<li>Here you are naming the <var>collapse</var> argument explicitly and specifying its value. <var>spacing</var> still gets its default value of <code>10</code>.
<li>Even required arguments (like <var>object</var>, which has no default value) can be named, and named arguments can appear in any order.
<p>This looks totally whacked until you realize that arguments are simply a dictionary. The &#8220;normal&#8221; method of calling functions without argument names is actually just a shorthand where Python matches up the values with the argument names in the order they're specified in the function declaration. And most of the
time, you'll call functions the &#8220;normal&#8221; way, but you always have the additional flexibility if you need it.
<table id="tip.arguments" class=note border="0" summary="">

<td rowspan="2" align="center" valign="top" width="1%"><img src="images/note.png" alt="Note" title="" width="24" height="24"><td colspan="2" align="left" valign="top" width="99%">The only thing you need to do to call a function is specify a value (somehow) for each required argument; the manner and order
      in which you do that is up to you.
<div class=itemizedlist>
<h3>Further Reading on Optional Arguments</h3>
<ul>
<li><a href="http://www.python.org/doc/current/tut/tut.html"><i class=citetitle>Python Tutorial</i></a> discusses exactly <a href="http://www.python.org/doc/current/tut/node6.html#SECTION006710000000000000000">when and how default arguments are evaluated</a>, which matters when the default value is a list or an expression with side effects.

</ul>
<h2 id="apihelper.builtin">4.3. Using <code>type</code>, <code>str</code>, <code>dir</code>, and Other Built-In Functions</h2>
<p>Python has a small set of extremely useful built-in functions. All other functions are partitioned off into modules. This was
   actually a conscious design decision, to keep the core language from getting bloated like other scripting languages (cough
   cough, Visual Basic).
<h3>4.3.1. The <code>type</code> Function</h3>
<p>The <code>type</code> function returns the datatype of any arbitrary object. The possible types are listed in the <code>types</code> module. This is useful for helper functions that can handle several types of data.
<div class=example><h3 id="apihelper.type.intro">Example 4.5. Introducing <code>type</code></h3><pre class=screen><samp class=prompt>>>> </samp><kbd>type(1)</kbd>           <span>&#x2460;</span>
&lt;type 'int'>
<samp class=prompt>>>> </samp><kbd>li = []</kbd>
<samp class=prompt>>>> </samp><kbd>type(li)</kbd>          <span>&#x2461;</span>
&lt;type 'list'>
<samp class=prompt>>>> </samp><kbd>import odbchelper</kbd>
<samp class=prompt>>>> </samp><kbd>type(odbchelper)</kbd>  <span>&#x2462;</span>
&lt;type 'module'>
<samp class=prompt>>>> </samp><kbd>import types</kbd>      <span>&#x2463;</span>
<samp class=prompt>>>> </samp><kbd>type(odbchelper) == types.ModuleType</kbd>
True</pre><div class=calloutlist>
<ol>
<li><code>type</code> takes anything -- and I mean anything -- and returns its datatype. Integers, strings, lists, dictionaries, tuples, functions,
               classes, modules, even types are acceptable.
<li><code>type</code> can take a variable and return its datatype.
<li><code>type</code> also works on modules.
<li>You can use the constants in the <code>types</code> module to compare types of objects. This is what the <code>info</code> function does, as you'll see shortly.
<h3>4.3.2. The <code>str</code> Function</h3>
<p>The <code>str</code> coerces data into a string. Every datatype can be coerced into a string.
<div class=example><h3 id="apihelper.str.intro">Example 4.6. Introducing <code>str</code></h3><pre class=screen>
<samp class=prompt>>>> </samp><kbd>str(1)</kbd>          <span>&#x2460;</span>
'1'
<samp class=prompt>>>> </samp><kbd>horsemen = ['war', 'pestilence', 'famine']</kbd>
<samp class=prompt>>>> </samp><kbd>horsemen</kbd>
['war', 'pestilence', 'famine']
<samp class=prompt>>>> </samp><kbd>horsemen.append('Powerbuilder')</kbd>
<samp class=prompt>>>> </samp><kbd>str(horsemen)</kbd>   <span>&#x2461;</span>
"['war', 'pestilence', 'famine', 'Powerbuilder']"
<samp class=prompt>>>> </samp><kbd>str(odbchelper)</kbd> <span>&#x2462;</span>
"&lt;module 'odbchelper' from 'c:\\docbook\\dip\\py\\odbchelper.py'>"
<samp class=prompt>>>> </samp><kbd>str(None)</kbd>       <span>&#x2463;</span>
'None'</pre><div class=calloutlist>
<ol>
<li>For simple datatypes like integers, you would expect <code>str</code> to work, because almost every language has a function to convert an integer to a string.
<li>However, <code>str</code> works on any object of any type. Here it works on a list which you've constructed in bits and pieces.
<li><code>str</code> also works on modules. Note that the string representation of the module includes the pathname of the module on disk, so
               yours will be different.
<li>A subtle but important behavior of <code>str</code> is that it works on <code>None</code>, the Python null value. It returns the string <code>'None'</code>. You'll use this to your advantage in the <code>info</code> function, as you'll see shortly.
<p>At the heart of the <code>info</code> function is the powerful <code>dir</code> function. <code>dir</code> returns a list of the attributes and methods of any object: modules, functions, strings, lists, dictionaries... pretty much
   anything.
<div class=example><h3 id="apihelper.dir.intro">Example 4.7. Introducing <code>dir</code></h3><pre class=screen><samp class=prompt>>>> </samp><kbd>li = []</kbd>
<samp class=prompt>>>> </samp><kbd>dir(li)</kbd>           <span>&#x2460;</span>
<samp>['append', 'count', 'extend', 'index', 'insert',
'pop', 'remove', 'reverse', 'sort']</samp>
<samp class=prompt>>>> </samp><kbd>d = {}</kbd>
<samp class=prompt>>>> </samp><kbd>dir(d)</kbd>            <span>&#x2461;</span>
['clear', 'copy', 'get', 'has_key', 'items', 'keys', 'setdefault', 'update', 'values']
<samp class=prompt>>>> </samp><kbd>import odbchelper</kbd>
<samp class=prompt>>>> </samp><kbd>dir(odbchelper)</kbd>   <span>&#x2462;</span>
['__builtins__', '__doc__', '__file__', '__name__', 'buildConnectionString']</pre><div class=calloutlist>
<ol>
<li><var>li</var> is a list, so <code><code>dir</code>(<var>li</var>)</code> returns a list of all the methods of a list. Note that the returned list contains the names of the methods as strings, not
               the methods themselves.
<li><var>d</var> is a dictionary, so <code><code>dir</code>(<var>d</var>)</code> returns a list of the names of dictionary methods. At least one of these, <a href="#odbchelper.items" title="Example 3.25. The keys, values, and items Functions"><code>keys</code></a>, should look familiar.
<li>This is where it really gets interesting. <code>odbchelper</code> is a module, so <code><code>dir</code>(<code>odbchelper</code>)</code> returns a list of all kinds of stuff defined in the module, including built-in attributes, like <a href="#odbchelper.ifnametrick"><code>__name__</code></a>, <a href="#odbchelper.import" title="Example 2.3. Accessing the buildConnectionString Function's docstring"><code>__doc__</code></a>, and whatever other attributes and methods you define. In this case, <code>odbchelper</code> has only one user-defined method, the <code>buildConnectionString</code> function described in <a href="#odbchelper">Chapter 2</a>.
<p>Finally, the <code>callable</code> function takes any object and returns <code>True</code> if the object can be called, or <code>False</code> otherwise. Callable objects include functions, class methods, even classes themselves. (More on classes in the next chapter.)
<div class=example><h3 id="apihelper.builtin.callable">Example 4.8. Introducing <code>callable</code></h3><pre class=screen>
<samp class=prompt>>>> </samp><kbd>import string</kbd>
<samp class=prompt>>>> </samp><kbd>string.punctuation</kbd>           <span>&#x2460;</span>
'!"#$%&amp;\'()*+,-./:;&lt;=>?@[\\]^_`{|}~'
<samp class=prompt>>>> </samp><kbd>string.join</kbd><span>&#x2461;</span><!-- " -->
&lt;function join at 00C55A7C>
<samp class=prompt>>>> </samp><kbd>callable(string.punctuation)</kbd> <span>&#x2462;</span>
False
<samp class=prompt>>>> </samp><kbd>callable(string.join)</kbd>        <span>&#x2463;</span>
True
<samp class=prompt>>>> </samp><kbd>print string.join.__doc__</kbd>    <span>&#x2464;</span>
<samp>join(list [,sep]) -> string

    Return a string composed of the words in list, with
    intervening occurrences of sep. The default separator is a
    single space.

    (joinfields and join are synonymous)</span></pre><div class=calloutlist>
<ol>
<li>The functions in the <code>string</code> module are deprecated (although many people still use the <code>join</code> function), but the module contains a lot of useful constants like this <var>string.punctuation</var>, which contains all the standard punctuation characters.
<li><a href="#odbchelper.join" title="3.7. Joining Lists and Splitting Strings"><code>string.join</code></a> is a function that joins a list of strings.
<li><var>string.punctuation</var> is not callable; it is a string. (A string does have callable methods, but the string itself is not callable.)
<li><code>string.join</code> is callable; it's a function that takes two arguments.
<li>Any callable object may have a <code>docstring</code>. By using the <code>callable</code> function on each of an object's attributes, you can determine which attributes you care about (methods, functions, classes)
               and which you want to ignore (constants and so on) without knowing anything about the object ahead of time.
<h3>4.3.3. Built-In Functions</h3>
<p><code>type</code>, <code>str</code>, <code>dir</code>, and all the rest of Python's built-in functions are grouped into a special module called <code>__builtin__</code>. (That's two underscores before and after.)  If it helps, you can think of Python automatically executing <code>from __builtin__ import *</code> on startup, which imports all the &#8220;built-in&#8221; functions into the namespace so you can use them directly.
<p>The advantage of thinking like this is that you can access all the built-in functions and attributes as a group by getting
   information about the <code>__builtin__</code> module. And guess what, Python has a function called <code>info</code>. Try it yourself and skim through the list now. We'll dive into some of the more important functions later. (Some of the
   built-in error classes, like <a href="#odbchelper.tuplemethods" title="Example 3.16. Tuples Have No Methods"><code>AttributeError</code></a>, should already look familiar.)
<div class=example><h3 id="apihelper.builtin.list">Example 4.9. Built-in Attributes and Functions</h3><pre class=screen><samp class=prompt>>>> </samp><kbd>from apihelper import info</kbd>
<samp class=prompt>>>> </samp><kbd>import __builtin__</kbd>
<samp class=prompt>>>> </samp><kbd>info(__builtin__, 20)</kbd>
<samp>ArithmeticError      Base class for arithmetic errors.
AssertionError       Assertion failed.
AttributeError       Attribute not found.
EOFError             Read beyond end of file.
EnvironmentError     Base class for I/O related errors.
Exception            Common base class for all exceptions.
FloatingPointError   Floating point operation failed.
IOError              I/O operation failed.

[...snip...]</span></pre><table id="tip.manuals" class=note border="0" summary="">

<td rowspan="2" align="center" valign="top" width="1%"><img src="images/note.png" alt="Note" title="" width="24" height="24"><td colspan="2" align="left" valign="top" width="99%">Python comes with excellent reference manuals, which you should peruse thoroughly to learn all the modules Python has to offer. But unlike most languages, where you would find yourself referring back to the manuals or man pages to remind
         yourself how to use these modules, Python is largely self-documenting.
<div class=itemizedlist>
<h3>Further Reading on Built-In Functions</h3>
<ul>
<li><a href="http://www.python.org/doc/current/lib/"><i class=citetitle>Python Library Reference</i></a> documents <a href="http://www.python.org/doc/current/lib/built-in-funcs.html">all the built-in functions</a> and <a href="http://www.python.org/doc/current/lib/module-exceptions.html">all the built-in exceptions</a>.

</ul>
<h2 id="apihelper.getattr">4.4. Getting Object References With <code>getattr</code></h2>
<p>You already know that <a href="#odbchelper.objects" title="2.4. Everything Is an Object">Python functions are objects</a>. What you don't know is that you can get a reference to a function without knowing its name until run-time, by using the
<code>getattr</code> function.
<div class=example><h3 id="apihelper.getattr.intro">Example 4.10. Introducing <code>getattr</code></h3><pre class=screen><samp class=prompt>>>> </samp><kbd>li = ["Larry", "Curly"]</kbd>
<samp class=prompt>>>> </samp><kbd>li.pop</kbd>     <span>&#x2460;</span>
&lt;built-in method pop of list object at 010DF884>
<samp class=prompt>>>> </samp><kbd>getattr(li, "pop")</kbd>           <span>&#x2461;</span>
&lt;built-in method pop of list object at 010DF884>
<samp class=prompt>>>> </samp><kbd>getattr(li, "append")("Moe")</kbd> <span>&#x2462;</span>
<samp class=prompt>>>> </samp><kbd>li</kbd>
["Larry", "Curly", "Moe"]
<samp class=prompt>>>> </samp><kbd>getattr({}, "clear")</kbd>         <span>&#x2463;</span>
&lt;built-in method clear of dictionary object at 00F113D4>
<samp class=prompt>>>> </samp><kbd>getattr((), "pop")</kbd>           <span>&#x2464;</span>
<samp class=traceback>Traceback (innermost last):
  File "&lt;interactive input>", line 1, in ?
AttributeError: 'tuple' object has no attribute 'pop'</span></pre><div class=calloutlist>
<ol>
<li>This gets a reference to the <code>pop</code> method of the list. Note that this is not calling the <code>pop</code> method; that would be <code>li.pop()</code>. This is the method itself.
<li>This also returns a reference to the <code>pop</code> method, but this time, the method name is specified as a string argument to the <code>getattr</code> function. <code>getattr</code> is an incredibly useful built-in function that returns any attribute of any object. In this case, the object is a list,
            and the attribute is the <code>pop</code> method.
<li>In case it hasn't sunk in just how incredibly useful this is, try this: the return value of <code>getattr</code> <em>is</em> the method, which you can then call just as if you had said <code>li.append("Moe")</code> directly. But you didn't call the function directly; you specified the function name as a string instead.
<li><code>getattr</code> also works on dictionaries.
<li>In theory, <code>getattr</code> would work on tuples, except that <a href="#odbchelper.tuplemethods" title="Example 3.16. Tuples Have No Methods">tuples have no methods</a>, so <code>getattr</code> will raise an exception no matter what attribute name you give.
<h3>4.4.1. <code>getattr</code> with Modules</h3>
<p><code>getattr</code> isn't just for built-in datatypes. It also works on modules.
<div class=example><h3 id="apihelper.getattr.example">Example 4.11. The <code>getattr</code> Function in <code>apihelper.py</code></h3><pre class=screen><samp class=prompt>>>> </samp><kbd>import odbchelper</kbd>
<samp class=prompt>>>> </samp><kbd>odbchelper.buildConnectionString</kbd>             <span>&#x2460;</span>
&lt;function buildConnectionString at 00D18DD4>
<samp class=prompt>>>> </samp><kbd>getattr(odbchelper, "buildConnectionString")</kbd> <span>&#x2461;</span>
&lt;function buildConnectionString at 00D18DD4>
<samp class=prompt>>>> </samp><kbd>object = odbchelper</kbd>
<samp class=prompt>>>> </samp><kbd>method = "buildConnectionString"</kbd>
<samp class=prompt>>>> </samp><kbd>getattr(object, method)</kbd>    <span>&#x2462;</span>
&lt;function buildConnectionString at 00D18DD4>
<samp class=prompt>>>> </samp><kbd>type(getattr(object, method))</kbd>                <span>&#x2463;</span>
&lt;type 'function'>
<samp class=prompt>>>> </samp><kbd>import types</kbd>
<samp class=prompt>>>> </samp><kbd>type(getattr(object, method)) == types.FunctionType</kbd>
True
<samp class=prompt>>>> </samp><kbd>callable(getattr(object, method))</kbd>            <span>&#x2464;</span>
True</pre><div class=calloutlist>
<ol>
<li>This returns a reference to the <code>buildConnectionString</code> function in the <code>odbchelper</code> module, which you studied in <a href="#odbchelper" title="Chapter 2. Your First Python Program">Chapter 2, <i>Your First Python Program</i></a>. (The hex address you see is specific to my machine; your output will be different.)
<li>Using <code>getattr</code>, you can get the same reference to the same function. In general, <code><code>getattr</code>(<var>object</var>, "<var>attribute</var>")</code> is equivalent to <code><var>object</var>.<var>attribute</var></code>. If <var><code>object</code></var> is a module, then <var><code>attribute</code></var> can be anything defined in the module: a function, class, or global variable.
<li>And this is what you actually use in the <code>info</code> function. <var>object</var> is passed into the function as an argument; <var>method</var> is a string which is the name of a method or function.
<li>In this case, <var>method</var> is the name of a function, which you can prove by getting its <a href="#apihelper.type.intro" title="Example 4.5. Introducing type"><code>type</code></a>.
<li>Since <var>method</var> is a function, it is <a href="#apihelper.builtin.callable" title="Example 4.8. Introducing callable">callable</a>.
<h3>4.4.2. <code>getattr</code> As a Dispatcher</h3>
<p>A common usage pattern of <code>getattr</code> is as a dispatcher. For example, if you had a program that could output data in a variety of different formats, you could
   define separate functions for each output format and use a single dispatch function to call the right one.
<p>For example, let's imagine a program that prints site statistics in <abbr>HTML</abbr>, <abbr>XML</abbr>, and plain text formats. The choice of output format could be specified on the command line, or stored in a configuration
   file. A <code>statsout</code> module defines three functions, <code>output_html</code>, <code>output_xml</code>, and <code>output_text</code>. Then the main program defines a single output function, like this:
<div class=example><h3 id="apihelper.getattr.dispatch">Example 4.12. Creating a Dispatcher with <code>getattr</code></h3><pre><code>
import statsout

def output(data, format="text"):            <span>&#x2460;</span>
    output_function = getattr(statsout, "output_%s" % format) <span>&#x2461;</span>
    return output_function(data)            <span>&#x2462;</span>
</pre><div class=calloutlist>
<ol>
<li>The <code>output</code> function takes one required argument, <var>data</var>, and one optional argument, <var>format</var>. If <var>format</var> is not specified, it defaults to <code>text</code>, and you will end up calling the plain text output function.
<li>You concatenate the <var>format</var> argument with "output_" to produce a function name, and then go get that function from the <code>statsout</code> module. This allows you to easily extend the program later to support other output formats, without changing this dispatch
            function. Just add another function to <code>statsout</code> named, for instance, <code>output_pdf</code>, and pass "pdf" as the <var>format</var> into the <code>output</code> function.
<li>Now you can simply call the output function in the same way as any other function. The <var>output_function</var> variable is a reference to the appropriate function from the <code>statsout</code> module.
<p>Did you see the bug in the previous example?  This is a very loose coupling of strings and functions, and there is no error
   checking. What happens if the user passes in a format that doesn't have a corresponding function defined in <code>statsout</code>?  Well, <code>getattr</code> will return <code>None</code>, which will be assigned to <var>output_function</var> instead of a valid function, and the next line that attempts to call that function will crash and raise an exception. That's
   bad.
<p>Luckily, <code>getattr</code> takes an optional third argument, a default value.
<div class=example><h3 id="apihelper.getattr.default">Example 4.13. <code>getattr</code> Default Values</h3><pre><code>
import statsout

def output(data, format="text"):
    output_function = getattr(statsout, "output_%s" % format, statsout.output_text)
    return output_function(data) <span>&#x2460;</span>
</pre><div class=calloutlist>
<ol>
<li>This function call is guaranteed to work, because you added a third argument to the call to <code>getattr</code>. The third argument is a default value that is returned if the attribute or method specified by the second argument wasn't
               found.
<p>As you can see, <code>getattr</code> is quite powerful. It is the heart of introspection, and you'll see even more powerful examples of it in later chapters.
<h2 id="apihelper.filter">4.5. Filtering Lists</h2>
<p>As you know, Python has powerful capabilities for mapping lists into other lists, via list comprehensions (<a href="#odbchelper.map" title="3.6. Mapping Lists">Section 3.6, &#8220;Mapping Lists&#8221;</a>). This can be combined with a filtering mechanism, where some elements in the list are mapped while others are skipped entirely.

<p>Here is the list filtering syntax:<pre><code>
[<var><code>mapping-expression</code></var> for <var><code>element</code></var> in <var><code>source-list</code></var> if <var><code>filter-expression</code></var>]</pre><p>This is an extension of the <a href="#odbchelper.map" title="3.6. Mapping Lists">list comprehensions</a> that you know and love. The first two thirds are the same; the last part, starting with the <code>if</code>, is the filter expression. A filter expression can be any expression that evaluates true or false (which in Python can be <a href="#tip.boolean">almost anything</a>). Any element for which the filter expression evaluates true will be included in the mapping. All other elements are ignored,
so they are never put through the mapping expression and are not included in the output list.
<div class=example><h3>Example 4.14. Introducing List Filtering</h3><pre class=screen><samp class=prompt>>>> </samp><kbd>li = ["a", "mpilgrim", "foo", "b", "c", "b", "d", "d"]</kbd>
<samp class=prompt>>>> </samp><kbd>[elem for elem in li if len(elem) > 1]</kbd>       <span>&#x2460;</span>
['mpilgrim', 'foo']
<samp class=prompt>>>> </samp><kbd>[elem for elem in li if elem != "b"]</kbd>         <span>&#x2461;</span>
['a', 'mpilgrim', 'foo', 'c', 'd', 'd']
<samp class=prompt>>>> </samp><kbd>[elem for elem in li if li.count(elem) == 1]</kbd> <span>&#x2462;</span>
['a', 'mpilgrim', 'foo', 'c']</pre><div class=calloutlist>
<ol>
<li>The mapping expression here is simple (it just returns the value of each element), so concentrate on the filter expression.
             As Python loops through the list, it runs each element through the filter expression. If the filter expression is true, the element
            is mapped and the result of the mapping expression is included in the returned list. Here, you are filtering out all the
            one-character strings, so you're left with a list of all the longer strings.
<li>Here, you are filtering out a specific value, <code>b</code>. Note that this filters all occurrences of <code>b</code>, since each time it comes up, the filter expression will be false.
<li><code>count</code> is a list method that returns the number of times a value occurs in a list. You might think that this filter would eliminate
            duplicates from a list, returning a list containing only one copy of each value in the original list. But it doesn't, because
            values that appear twice in the original list (in this case, <code>b</code> and <code>d</code>) are excluded completely. There are ways of eliminating duplicates from a list, but filtering is not the solution.
<p>Let's id="apihelper.filter.care" get back to this line from <code>apihelper.py</code>:<pre><code>
    methodList = [method for method in dir(object) if callable(getattr(object, method))]</pre><p>This looks complicated, and it is complicated, but the basic structure is the same. The whole filter expression returns a
list, which is assigned to the <var>methodList</var> variable. The first half of the expression is the list mapping part. The mapping expression is an identity expression,
which it returns the value of each element. <code><code>dir</code>(<var>object</var>)</code> returns a list of <var>object</var>'s attributes and methods -- that's the list you're mapping. So the only new part is the filter expression after the <code>if</code>.
<p>The filter expression looks scary, but it's not. You already know about <a href="#apihelper.builtin.callable" title="Example 4.8. Introducing callable"><code>callable</code></a>, <a href="#apihelper.getattr.intro" title="Example 4.10. Introducing getattr"><code>getattr</code></a>, and <a href="#odbchelper.tuplemethods" title="Example 3.16. Tuples Have No Methods"><code>in</code></a>. As you saw in the <a href="#apihelper.getattr" title="4.4. Getting Object References With getattr">previous section</a>, the expression <code>getattr(object, method)</code> returns a function object if <var>object</var> is a module and <var>method</var> is the name of a function in that module.
<p>So this expression takes an object (named <var>object</var>). Then it gets a list of the names of the object's attributes, methods, functions, and a few other things. Then it filters
that list to weed out all the stuff that you don't care about. You do the weeding out by taking the name of each attribute/method/function
and getting a reference to the real thing, via the <code>getattr</code> function. Then you check to see if that object is callable, which will be any methods and functions, both built-in (like
the <code>pop</code> method of a list) and user-defined (like the <code>buildConnectionString</code> function of the <code>odbchelper</code> module). You don't care about other attributes, like the <code>__name__</code> attribute that's built in to every module.
<div class=itemizedlist>
<h3>Further Reading on Filtering Lists</h3>
<ul>
<li><a href="http://www.python.org/doc/current/tut/tut.html"><i class=citetitle>Python Tutorial</i></a> discusses another way to filter lists <a href="http://www.python.org/doc/current/tut/node7.html#SECTION007130000000000000000">using the built-in <code>filter</code> function</a>.

</ul>
<h2 id="apihelper.andor">4.6. The Peculiar Nature of <code>and</code> and <code>or</code></h2>
<p>In Python, <code>and</code> and <code>or</code> perform boolean logic as you would expect, but they do not return boolean values; instead, they return one of the actual
   values they are comparing.
<div class=example><h3 id="apihelper.andor.intro.example">Example 4.15. Introducing <code>and</code></h3><pre class=screen><samp class=prompt>>>> </samp><kbd>'a' and 'b'</kbd>         <span>&#x2460;</span>
'b'
<samp class=prompt>>>> </samp><kbd>'' and 'b'</kbd>          <span>&#x2461;</span>
''
<samp class=prompt>>>> </samp><kbd>'a' and 'b' and 'c'</kbd> <span>&#x2462;</span>
'c'</pre><div class=calloutlist>
<ol>
<li>When using <code>and</code>, values are evaluated in a boolean context from left to right. <code>0</code>, <code>''</code>, <code>[]</code>, <code>()</code>, <code>{}</code>, and <code>None</code> are false in a boolean context; everything else is true. Well, almost everything. By default, instances of classes are
            true in a boolean context, but you can define special methods in your class to make an instance evaluate to false. You'll
            learn all about classes and special methods in <a href="#fileinfo">Chapter 5</a>. If all values are true in a boolean context, <code>and</code> returns the last value. In this case, <code>and</code> evaluates <code>'a'</code>, which is true, then <code>'b'</code>, which is true, and returns <code>'b'</code>.
<li>If any value is false in a boolean context, <code>and</code> returns the first false value. In this case, <code>''</code> is the first false value.
<li>All values are true, so <code>and</code> returns the last value, <code>'c'</code>.
<div class=example><h3>Example 4.16. Introducing <code>or</code></h3><pre class=screen><samp class=prompt>>>> </samp><kbd>'a' or 'b'</kbd>          <span>&#x2460;</span>
'a'
<samp class=prompt>>>> </samp><kbd>'' or 'b'</kbd>           <span>&#x2461;</span>
'b'
<samp class=prompt>>>> </samp><kbd>'' or [] or {}</kbd>      <span>&#x2462;</span>
{}
<samp class=prompt>>>> </samp><kbd>def sidefx():</kbd>
<samp class=prompt>...    </samp>print "in sidefx()"
<samp class=prompt>...    </samp>return 1
<samp class=prompt>>>> </samp><kbd>'a' or sidefx()</kbd>     <span>&#x2463;</span>
'a'</pre><div class=calloutlist>
<ol>
<li>When using <code>or</code>, values are evaluated in a boolean context from left to right, just like <code>and</code>. If any value is true, <code>or</code> returns that value immediately. In this case, <code>'a'</code> is the first true value.
<li><code>or</code> evaluates <code>''</code>, which is false, then <code>'b'</code>, which is true, and returns <code>'b'</code>.
<li>If all values are false, <code>or</code> returns the last value. <code>or</code> evaluates <code>''</code>, which is false, then <code>[]</code>, which is false, then <code>{}</code>, which is false, and returns <code>{}</code>.
<li>Note that <code>or</code> evaluates values only until it finds one that is true in a boolean context, and then it ignores the rest. This distinction
            is important if some values can have side effects. Here, the function <code>sidefx</code> is never called, because <code>or</code> evaluates <code>'a'</code>, which is true, and returns <code>'a'</code> immediately.
<p>If you're a <abbr>C</abbr> hacker, you are certainly familiar with the <code><var>bool</var> ? <var>a</var> : <var>b</var></code> expression, which evaluates to <var>a</var> if <var><code>bool</code></var> is true, and <var>b</var> otherwise. Because of the way <code>and</code> and <code>or</code> work in Python, you can accomplish the same thing.
<h3>4.6.1. Using the <code>and-or</code> Trick</h3>
<div class=example><h3 id="apihelper.andortrick.intro">Example 4.17. Introducing the <code>and-or</code> Trick</h3><pre class=screen><samp class=prompt>>>> </samp><kbd>a = "first"</kbd>
<samp class=prompt>>>> </samp><kbd>b = "second"</kbd>
<samp class=prompt>>>> </samp><kbd>1 and a or b</kbd> <span>&#x2460;</span>
'first'
<samp class=prompt>>>> </samp><kbd>0 and a or b</kbd> <span>&#x2461;</span>
'second'
</pre><div class=calloutlist>
<ol>
<li>This syntax looks similar to the <code><var>bool</var> ? <var>a</var> : <var>b</var></code> expression in <abbr>C</abbr>. The entire expression is evaluated from left to right, so the <code>and</code> is evaluated first. <code>1 and 'first'</code> evalutes to <code>'first'</code>, then <code>'first' or 'second'</code> evalutes to <code>'first'</code>.
<li><code>0 and 'first'</code> evalutes to <code>False</code>, and then <code>0 or 'second'</code> evaluates to <code>'second'</code>.
<p>However, since this Python expression is simply boolean logic, and not a special construct of the language, there is one extremely important difference
   between this <code>and-or</code> trick in Python and the <code><var>bool</var> ? <var>a</var> : <var>b</var></code> syntax in <abbr>C</abbr>. If the value of <var>a</var> is false, the expression will not work as you would expect it to. (Can you tell I was bitten by this?  More than once?)
<div class=example><h3>Example 4.18. When the <code>and-or</code> Trick Fails</h3><pre class=screen><samp class=prompt>>>> </samp><kbd>a = ""</kbd>
<samp class=prompt>>>> </samp><kbd>b = "second"</kbd>
<samp class=prompt>>>> </samp><kbd>1 and a or b</kbd>         <span>&#x2460;</span>
'second'</pre><div class=calloutlist>
<ol>
<li>Since <var>a</var> is an empty string, which Python considers false in a boolean context, <code>1 and ''</code> evalutes to <code>''</code>, and then <code>'' or 'second'</code> evalutes to <code>'second'</code>. Oops!  That's not what you wanted.
<p>The <code>and-or</code> trick, <code><var>bool</var> and <var>a</var> or <var>b</var></code>, will not work like the <abbr>C</abbr> expression <code><var>bool</var> ? <var>a</var> : <var>b</var></code> when <var>a</var> is false in a boolean context.
<p>The real trick behind the <code>and-or</code> trick, then, is to make sure that the value of <var>a</var> is never false. One common way of doing this is to turn <var>a</var> into <code>[<var>a</var>]</code> and <var>b</var> into <code>[<var>b</var>]</code>, then taking the first element of the returned list, which will be either <var>a</var> or <var>b</var>.
<div class=example><h3>Example 4.19. Using the <code>and-or</code> Trick Safely</h3><pre class=screen><samp class=prompt>>>> </samp><kbd>a = ""</kbd>
<samp class=prompt>>>> </samp><kbd>b = "second"</kbd>
<samp class=prompt>>>> </samp><kbd>(1 and [a] or [b])[0]</kbd> <span>&#x2460;</span>
''</pre><div class=calloutlist>
<ol>
<li>Since <code>[<var>a</var>]</code> is a non-empty list, it is never false. Even if <var>a</var> is <code>0</code> or <code>''</code> or some other false value, the list <code>[<var>a</var>]</code> is true because it has one element.
<p>By now, this trick may seem like more trouble than it's worth. You could, after all, accomplish the same thing with an <code>if</code> statement, so why go through all this fuss?  Well, in many cases, you are choosing between two constant values, so you can
   use the simpler syntax and not worry, because you know that the <var>a</var> value will always be true. And even if you need to use the more complicated safe form, there are good reasons to do so.
   For example, there are some cases in Python where <code>if</code> statements are not allowed, such as in <code>lambda</code> functions.
<div class=itemizedlist>
<h3>Further Reading on the <code>and-or</code> Trick</h3>
<ul>
<li><a href="http://www.activestate.com/ASPN/Python/Cookbook/" title="growing archive of annotated code samples">Python Cookbook</a> discusses <a href="http://www.activestate.com/ASPN/Python/Cookbook/Recipe/52310">alternatives to the <code>and-or</code> trick</a>.

</ul>
<h2 id="apihelper.lambda">4.7. Using <code>lambda</code> Functions</h2>
<p>Python supports an interesting syntax that lets you define one-line mini-functions on the fly. Borrowed from Lisp, these so-called <code>lambda</code> functions can be used anywhere a function is required.
<div class=example><h3>Example 4.20. Introducing <code>lambda</code> Functions</h3><pre class=screen><samp class=prompt>>>> </samp><kbd>def f(x):</kbd>
<samp class=prompt>...    </samp>return x*2
<samp class=prompt>...    </samp>
<samp class=prompt>>>> </samp><kbd>f(3)</kbd>
6
<samp class=prompt>>>> </samp><kbd>g = lambda x: x*2</kbd>  <span>&#x2460;</span>
<samp class=prompt>>>> </samp><kbd>g(3)</kbd>
6
<samp class=prompt>>>> </samp><kbd>(lambda x: x*2)(3)</kbd> <span>&#x2461;</span>
6</pre><div class=calloutlist>
<ol>
<li>This is a <code>lambda</code> function that accomplishes the same thing as the normal function above it. Note the abbreviated syntax here: there are no
            parentheses around the argument list, and the <code>return</code> keyword is missing (it is implied, since the entire function can only be one expression). Also, the function has no name,
            but it can be called through the variable it is assigned to.
<li>You can use a <code>lambda</code> function without even assigning it to a variable. This may not be the most useful thing in the world, but it just goes to
            show that a lambda is just an in-line function.
<p>To generalize, a <code>lambda</code> function is a function that takes any number of arguments (including <a href="#apihelper.optional" title="4.2. Using Optional and Named Arguments">optional arguments</a>) and returns the value of a single expression. <code>lambda</code> functions can not contain commands, and they can not contain more than one expression. Don't try to squeeze too much into
a <code>lambda</code> function; if you need something more complex, define a normal function instead and make it as long as you want.
<table id="tip.lambda" class=note border="0" summary="">

<td rowspan="2" align="center" valign="top" width="1%"><img src="images/note.png" alt="Note" title="" width="24" height="24"><td colspan="2" align="left" valign="top" width="99%"><code>lambda</code> functions are a matter of style. Using them is never required; anywhere you could use them, you could define a separate
      normal function and use that instead. I use them in places where I want to encapsulate specific, non-reusable code without
      littering my code with a lot of little one-line functions.
<h3>4.7.1. Real-World <code>lambda</code> Functions</h3>

<p>Here are the <code>lambda</code> functions in <code>apihelper.py</code>:<pre><code>
    processFunc = collapse and (lambda s: " ".join(s.split())) or (lambda s: s)</pre><p>Notice that this uses the simple form of the <a href="#apihelper.andor" title="4.6. The Peculiar Nature of and and or"><code>and-or</code></a> trick, which is okay, because a <code>lambda</code> function is always true <a href="#tip.boolean">in a boolean context</a>. (That doesn't mean that a <code>lambda</code> function can't return a false value. The function is always true; its return value could be anything.)
<p>Also notice that you're using the <code>split</code> function with no arguments. You've already seen it used with <a href="#odbchelper.split.example" title="Example 3.28. Splitting a String">one or two arguments</a>, but without any arguments it splits on whitespace.
<div class=example><h3>Example 4.21. <code>split</code> With No Arguments</h3><pre class=screen><samp class=prompt>>>> </samp><kbd>s = "this   is\na\ttest"</kbd>  <span>&#x2460;</span>
<samp class=prompt>>>> </samp><kbd>print s</kbd>
<samp>this   is
a	test</samp>
<samp class=prompt>>>> </samp><kbd>print s.split()</kbd>           <span>&#x2461;</span>
['this', 'is', 'a', 'test']
<samp class=prompt>>>> </samp><kbd>print " ".join(s.split())</kbd> <span>&#x2462;</span>
'this is a test'</pre><div class=calloutlist>
<ol>
<li>This is a multiline string, defined by escape characters instead of <a href="#odbchelper.triplequotes" title="Example 2.2. Defining the buildConnectionString Function's docstring">triple quotes</a>. <code>\n</code> is a carriage return, and <code>\t</code> is a tab character.
<li><code>split</code> without any arguments splits on whitespace. So three spaces, a carriage return, and a tab character are all the same.
<li>You can normalize whitespace by splitting a string with <code>split</code> and then rejoining it with <code>join</code>, using a single space as a delimiter. This is what the <code>info</code> function does to collapse multi-line <code>docstring</code>s into a single line.
<p>So what is the <code>info</code> function actually doing with these <code>lambda</code> functions, <code>split</code>s, and <code>and-or</code> tricks?
<pre id="apihelper.funcassign" class=programlisting>
    processFunc = collapse and (lambda s: " ".join(s.split())) or (lambda s: s)</pre><p><var>processFunc</var> is now a function, but which function it is depends on the value of the <var>collapse</var> variable. If <var>collapse</var> is true, <code><var>processFunc</var>(<var>string</var>)</code> will collapse whitespace; otherwise, <code><var>processFunc</var>(<var>string</var>)</code> will return its argument unchanged.
<p>To do this in a less robust language, like Visual Basic, you would probably create a function that took a string and a <i class=parameter><code>collapse</code></i> argument and used an <code>if</code> statement to decide whether to collapse the whitespace or not, then returned the appropriate value. This would be inefficient,
   because the function would need to handle every possible case. Every time you called it, it would need to decide whether
   to collapse whitespace before it could give you what you wanted. In Python, you can take that decision logic out of the function and define a <code>lambda</code> function that is custom-tailored to give you exactly (and only) what you want. This is more efficient, more elegant, and
   less prone to those nasty oh-I-thought-those-arguments-were-reversed kinds of errors.
<div class=itemizedlist>
<h3>Further Reading on <code>lambda</code> Functions</h3>
<ul>
<li><a href="http://www.faqts.com/knowledge-base/index.phtml/fid/199/">Python Knowledge Base</a> discusses using <code>lambda</code> to <a href="http://www.faqts.com/knowledge-base/view.phtml/aid/6081/fid/241">call functions indirectly</a>.

<li><a href="http://www.python.org/doc/current/tut/tut.html"><i class=citetitle>Python Tutorial</i></a> shows how to <a href="http://www.python.org/doc/current/tut/node6.html#SECTION006740000000000000000">access outside variables from inside a <code>lambda</code> function</a>. (<a href="http://python.sourceforge.net/peps/pep-0227.html"><abbr>PEP</abbr> 227</a> explains how this will change in future versions of Python.)

<li><a href="http://www.python.org/doc/FAQ.html"><i class=citetitle>The Whole Python <abbr>FAQ</abbr></i></a> has examples of <a href="http://www.python.org/cgi-bin/faqw.py?query=4.15&amp;querytype=simple&amp;casefold=yes&amp;req=search">obfuscated one-liners using <code>lambda</code></a>.

</ul>
<h2 id="apihelper.alltogether">4.8. Putting It All Together</h2>
<p>The last line of code, the only one you haven't deconstructed yet, is the one that does all the work. But by now the work
   is easy, because everything you need is already set up just the way you need it. All the dominoes are in place; it's time
   to knock them down.

<p>This is the meat of <code>apihelper.py</code>:<pre><code>
    print "\n".join(["%s %s" %
    (method.ljust(spacing),
     processFunc(str(getattr(object, method).__doc__)))
   for method in methodList])</pre><p>Note that this is one command, split over multiple lines, but it doesn't use the line continuation character (<code>\</code>). Remember when I said that <a href="#tip.implicitmultiline">some expressions can be split into multiple lines</a> without using a backslash?  A list comprehension is one of those expressions, since the entire expression is contained in
square brackets.
<p>Now, let's take it from the end and work backwards. The <pre><code>
for method in methodList</pre><p>shows that this is a <a href="#odbchelper.map" title="3.6. Mapping Lists">list comprehension</a>. As you know, <var>methodList</var> is a list of <a href="#apihelper.filter.care">all the methods you care about</a> in <var>object</var>. So you're looping through that list with <var>method</var>.
<div class=example><h3>Example 4.22. Getting a <code>docstring</code> Dynamically</h3><pre class=screen><samp class=prompt>>>> </samp><kbd>import odbchelper</kbd>
<samp class=prompt>>>> </samp><kbd>object = odbchelper</kbd> <span>&#x2460;</span>
<samp class=prompt>>>> </samp><kbd>method = 'buildConnectionString'</kbd>      <span>&#x2461;</span>
<samp class=prompt>>>> </samp><kbd>getattr(object, method)</kbd>               <span>&#x2462;</span>
&lt;function buildConnectionString at 010D6D74>
<samp class=prompt>>>> </samp><kbd>print getattr(object, method).__doc__</kbd> <span>&#x2463;</span>
<samp>Build a connection string from a dictionary of parameters.

    Returns string.</span></pre><div class=calloutlist>
<ol>
<li>In the <code>info</code> function, <var>object</var> is the object you're getting help on, passed in as an argument.
<li>As you're looping through <var>methodList</var>, <var>method</var> is the name of the current method.
<li>Using the <a href="#apihelper.getattr" title="4.4. Getting Object References With getattr"><code>getattr</code></a> function, you're getting a reference to the <var><code>method</code></var> function in the <var><code>object</code></var> module.
<li>Now, printing the actual <code>docstring</code> of the method is easy.
<p>The next piece of the puzzle is the use of <code>str</code> around the <code>docstring</code>. As you may recall, <code>str</code> is a built-in function that <a href="#apihelper.builtin" title="4.3. Using type, str, dir, and Other Built-In Functions">coerces data into a string</a>. But a <code>docstring</code> is always a string, so why bother with the <code>str</code> function?  The answer is that not every function has a <code>docstring</code>, and if it doesn't, its <code>__doc__</code> attribute is <code>None</code>.
<div class=example><h3>Example 4.23. Why Use <code>str</code> on a <code>docstring</code>?</h3><pre class=screen><samp class=prompt>>>> </samp><kbd>>>> def foo(): print 2</kbd>
<samp class=prompt>>>> </samp><kbd>>>> foo()</kbd>
2
<samp class=prompt>>>> </samp><kbd>>>> foo.__doc__</kbd>     <span>&#x2460;</span>
<samp class=prompt>>>> </samp><kbd>foo.__doc__ == None</kbd> <span>&#x2461;</span>
True
<samp class=prompt>>>> </samp><kbd>str(foo.__doc__)</kbd>    <span>&#x2462;</span>
'None'
</pre><div class=calloutlist>
<ol>
<li>You can easily define a function that has no <code>docstring</code>, so its <code>__doc__</code> attribute is <code>None</code>. Confusingly, if you evaluate the <code>__doc__</code> attribute directly, the Python <abbr>IDE</abbr> prints nothing at all, which makes sense if you think about it, but is still unhelpful.
<li>You can verify that the value of the <code>__doc__</code> attribute is actually <code>None</code> by comparing it directly.
<li>The <code>str</code> function takes the null value and returns a string representation of it, <code>'None'</code>.
<table id="compare.isnull.sql" class=note border="0" summary="">

<td rowspan="2" align="center" valign="top" width="1%"><img src="images/note.png" alt="Note" title="" width="24" height="24"><td colspan="2" align="left" valign="top" width="99%">In <abbr>SQL</abbr>, you must use <code>IS NULL</code> instead of <code>= NULL</code> to compare a null value. In Python, you can use either <code>== None</code> or <code>is None</code>, but <code>is None</code> is faster.
<p>Now that you are guaranteed to have a string, you can pass the string to <var>processFunc</var>, which you have <a href="#apihelper.lambda" title="4.7. Using lambda Functions">already defined</a> as a function that either does or doesn't collapse whitespace. Now you see why it was important to use <code>str</code> to convert a <code>None</code> value into a string representation. <var>processFunc</var> is assuming a string argument and calling its <code>split</code> method, which would crash if you passed it <code>None</code> because <code>None</code> doesn't have a <code>split</code> method.
<p>Stepping back even further, you see that you're using string formatting again to concatenate the return value of <var>processFunc</var> with the return value of <var>method</var>'s <code>ljust</code> method. This is a new string method that you haven't seen before.
<div class=example><h3>Example 4.24. Introducing <code>ljust</code></h3><pre class=screen><samp class=prompt>>>> </samp><kbd>s = 'buildConnectionString'</kbd>
<samp class=prompt>>>> </samp><kbd>s.ljust(30)</kbd> <span>&#x2460;</span>
'buildConnectionString         '
<samp class=prompt>>>> </samp><kbd>s.ljust(20)</kbd> <span>&#x2461;</span>
'buildConnectionString'</pre><div class=calloutlist>
<ol>
<li><code>ljust</code> pads the string with spaces to the given length. This is what the <code>info</code> function uses to make two columns of output and line up all the <code>docstring</code>s in the second column.
<li>If the given length is smaller than the length of the string, <code>ljust</code> will simply return the string unchanged. It never truncates the string.
<p>You're almost finished. Given the padded method name from the <code>ljust</code> method and the (possibly collapsed) <code>docstring</code> from the call to <var>processFunc</var>, you concatenate the two and get a single string. Since you're mapping <var>methodList</var>, you end up with a list of strings. Using the <code>join</code> method of the string <code>"\n"</code>, you join this list into a single string, with each element of the list on a separate line, and print the result.
<div class=example><h3>Example 4.25. Printing a List</h3><pre class=screen><samp class=prompt>>>> </samp><kbd>li = ['a', 'b', 'c']</kbd>
<samp class=prompt>>>> </samp><kbd>print "\n".join(li)</kbd> <span>&#x2460;</span>
<samp>a
b
c</span></pre><div class=calloutlist>
<ol>
<li>This is also a useful debugging trick when you're working with lists. And in Python, you're always working with lists.
<p>That's the last piece of the puzzle. You should now understand this code.
<pre><code>
    print "\n".join(["%s %s" %
    (method.ljust(spacing),
     processFunc(str(getattr(object, method).__doc__)))
   for method in methodList])</pre><h2 id="apihelper.summary">4.9. Summary</h2>
<p>The <code>apihelper.py</code> program and its output should now make perfect sense.
<pre><code>
def info(object, spacing=10, collapse=1):
    """Print methods and docstrings.
    
    Takes module, class, list, dictionary, or string."""
    methodList = [method for method in dir(object) if callable(getattr(object, method))]
    processFunc = collapse and (lambda s: " ".join(s.split())) or (lambda s: s)
    print "\n".join(["%s %s" %
    (method.ljust(spacing),
     processFunc(str(getattr(object, method).__doc__)))
   for method in methodList])

if __name__ == "__main__":
    print info.__doc__</pre>
<p>Here is the output of <code>apihelper.py</code>:<pre class=screen><samp class=prompt>>>> </samp><kbd>from apihelper import info</kbd>
<samp class=prompt>>>> </samp><kbd>li = []</kbd>
<samp class=prompt>>>> </samp><kbd>info(li)</kbd>
<samp>append     L.append(object) -- append object to end
count      L.count(value) -> integer -- return number of occurrences of value
extend     L.extend(list) -- extend list by appending list elements
index      L.index(value) -> integer -- return index of first occurrence of value
insert     L.insert(index, object) -- insert object before index
pop        L.pop([index]) -> item -- remove and return item at index (default last)
remove     L.remove(value) -- remove first occurrence of value
reverse    L.reverse() -- reverse *IN PLACE*
sort       L.sort([cmpfunc]) -- sort *IN PLACE*; if given, cmpfunc(x, y) -> -1, 0, 1</span></pre><div class=highlights>
<p>Before diving into the next chapter, make sure you're comfortable doing all of these things:
<div class=itemizedlist>
<ul>
<li>Defining and calling functions with <a href="#apihelper.optional" title="4.2. Using Optional and Named Arguments">optional and named arguments</a>
<li>Using <a href="#apihelper.str.intro" title="Example 4.6. Introducing str"><code>str</code></a> to coerce any arbitrary value into a string representation

<li>Using <a href="#apihelper.getattr" title="4.4. Getting Object References With getattr"><code>getattr</code></a> to get references to functions and other attributes dynamically

<li>Extending the list comprehension syntax to do <a href="#apihelper.filter" title="4.5. Filtering Lists">list filtering</a>
<li>Recognizing <a href="#apihelper.andor" title="4.6. The Peculiar Nature of and and or">the <code>and-or</code> trick</a> and using it safely

<li>Defining <a href="#apihelper.lambda" title="4.7. Using lambda Functions"><code>lambda</code> functions</a>
<li><a href="#apihelper.funcassign">Assigning functions to variables</a> and calling the function by referencing the variable. I can't emphasize this enough, because this mode of thought is vital
         to advancing your understanding of Python. You'll see more complex applications of this concept throughout this book.

</ul>
<div class=chapter>
<h2 id="fileinfo">Chapter 5. Objects and Object-Orientation</h2>
<p>This chapter, and pretty much every chapter after this, deals with object-oriented Python programming.
<h2 id="fileinfo.divein">5.1. Diving In</h2>
<p>Here is a complete, working Python program. Read the <a href="#odbchelper.docstring" title="2.3. Documenting Functions"><code>docstring</code>s</a> of the module, the classes, and the functions to get an overview of what this program does and how it works. As usual, don't
   worry about the stuff you don't understand; that's what the rest of the chapter is for.
<div class=example><h3>Example 5.1. <code>fileinfo.py</code></h3>
<p>If you have not already done so, you can <a href="http://diveintopython3.org/download/diveintopython3-examples-5.4.zip" title="Download example scripts">download this and other examples</a> used in this book.
<pre><code>
"""Framework for getting filetype-specific metadata.

Instantiate appropriate class with filename. Returned object acts like a
dictionary, with key-value pairs for each piece of metadata.
    import fileinfo
    info = fileinfo.MP3FileInfo("/music/ap/mahadeva.mp3")
    print "\\n".join(["%s=%s" % (k, v) for k, v in info.items()])

Or use listDirectory function to get info on all files in a directory.
    for info in fileinfo.listDirectory("/music/ap/", [".mp3"]):
        ...

Framework can be extended by adding classes for particular file types, e.g.
HTMLFileInfo, MPGFileInfo, DOCFileInfo. Each class is completely responsible for
parsing its files appropriately; see MP3FileInfo for example.
"""
import os
import sys
from UserDict import UserDict

def stripnulls(data):
    "strip whitespace and nulls"
    return data.replace("\00", "").strip()

class FileInfo(UserDict):
    "store file metadata"
    def __init__(self, filename=None):
        UserDict.__init__(self)
        self["name"] = filename

class MP3FileInfo(FileInfo):
    "store ID3v1.0 MP3 tags"
    tagDataMap = {"title"   : (  3,  33, stripnulls),
"artist"  : ( 33,  63, stripnulls),
"album"   : ( 63,  93, stripnulls),
"year"    : ( 93,  97, stripnulls),
"comment" : ( 97, 126, stripnulls),
"genre"   : (127, 128, ord)}

    def __parse(self, filename):
        "parse ID3v1.0 tags from MP3 file"
        self.clear()
        try:             
            fsock = open(filename, "rb", 0)
            try:         
                fsock.seek(-128, 2)        
                tagdata = fsock.read(128)  
            finally:     
                fsock.close()              
            if tagdata[:3] == "TAG":
                for tag, (start, end, parseFunc) in self.tagDataMap.items():
  self[tag] = parseFunc(tagdata[start:end])               
        except IOError:  
            pass         

    def __setitem__(self, key, item):
        if key == "name" and item:
            self.__parse(item)
        FileInfo.__setitem__(self, key, item)

def listDirectory(directory, fileExtList):    
    "get list of file info objects for files of particular extensions"
    fileList = [os.path.normcase(f)
                for f in os.listdir(directory)]           
    fileList = [os.path.join(directory, f) 
               for f in fileList
                if os.path.splitext(f)[1] in fileExtList] 
    def getFileInfoClass(filename, module=sys.modules[FileInfo.__module__]):      
        "get file info class from filename extension"           
        subclass = "%sFileInfo" % os.path.splitext(filename)[1].upper()[1:]       
        return hasattr(module, subclass) and getattr(module, subclass) or FileInfo
    return [getFileInfoClass(f)(f) for f in fileList]           

if __name__ == "__main__":
    for info in listDirectory("/music/_singles/", [".mp3"]): <span>&#x2460;</span>
        print "\n".join(["%s=%s" % (k, v) for k, v in info.items()])
        print</pre><div class=calloutlist>
<ol>
<li>This program's output depends on the files on your hard drive. To get meaningful output, you'll need to change the directory
            path to point to a directory of MP3 files on your own machine.

<p>This is the output I got on my machine. Your output will be different, unless, by some startling coincidence, you share my
   exact taste in music.
<pre class=screen><samp>album=
artist=Ghost in the Machine
title=A Time Long Forgotten (Concept
genre=31
name=/music/_singles/a_time_long_forgotten_con.mp3
year=1999
comment=http://mp3.com/ghostmachine

album=Rave Mix
artist=***DJ MARY-JANE***
title=HELLRAISER****Trance from Hell
genre=31
name=/music/_singles/hellraiser.mp3
year=2000
comment=http://mp3.com/DJMARYJANE

album=Rave Mix
artist=***DJ MARY-JANE***
title=KAIRO****THE BEST GOA
genre=31
name=/music/_singles/kairo.mp3
year=2000
comment=http://mp3.com/DJMARYJANE

album=Journeys
artist=Masters of Balance
title=Long Way Home
genre=31
name=/music/_singles/long_way_home1.mp3
year=2000
comment=http://mp3.com/MastersofBalan

album=
artist=The Cynic Project
title=Sidewinder
genre=18
name=/music/_singles/sidewinder.mp3
year=2000
comment=http://mp3.com/cynicproject

album=Digitosis@128k
artist=VXpanded
title=Spinning
genre=255
name=/music/_singles/spinning.mp3
year=2000
comment=http://mp3.com/artists/95/vxp</span></pre><h2 id="fileinfo.fromimport">5.2. Importing Modules Using <code>from <var>module</var> import</code></h2>
<p>Python has two ways of importing modules. Both are useful, and you should know when to use each. One way, <code>import <var>module</var></code>, you've already seen in <a href="#odbchelper.objects" title="2.4. Everything Is an Object">Section 2.4, &#8220;Everything Is an Object&#8221;</a>. The other way accomplishes the same thing, but it has subtle and important differences.

<p>Here is the basic <code>from <var>module</var> import</code> syntax:<pre><code>
from UserDict import UserDict
</pre><p>This is similar to the <a href="#odbchelper.import" title="Example 2.3. Accessing the buildConnectionString Function's docstring"><code>import <var>module</var></code></a> syntax that you know and love, but with an important difference: the attributes and methods of the imported module <code>types</code> are imported directly into the local namespace, so they are available directly, without qualification by module name. You
can import individual items or use <code>from <var>module</var> import *</code> to import everything.
<table id="compare.fromimport.perl" class=note border="0" summary="">

<td rowspan="2" align="center" valign="top" width="1%"><img src="images/note.png" alt="Note" title="" width="24" height="24"><td colspan="2" align="left" valign="top" width="99%"><code>from <var>module</var> import *</code> in Python is like <code>use <var>module</var></code> in Perl; <code>import <var>module</var></code> in Python is like <code>require <var>module</var></code> in Perl.
<table id="compare.fromimport.java" class=note border="0" summary="">

<td rowspan="2" align="center" valign="top" width="1%"><img src="images/note.png" alt="Note" title="" width="24" height="24"><td colspan="2" align="left" valign="top" width="99%"><code>from <var>module</var> import *</code> in Python is like <code>import <var>module</var>.*</code> in Java; <code>import <var>module</var></code> in Python is like <code>import <var>module</var></code> in Java.
<div class=example><h3>Example 5.2. <code>import <var>module</var></code> <i class=foreignphrase><abbr>vs.</abbr></i> <code>from <var>module</var> import</code></h3><pre class=screen><samp class=prompt>>>> </samp><kbd>import types</kbd>
<samp class=prompt>>>> </samp><kbd>types.FunctionType</kbd>             <span>&#x2460;</span>
&lt;type 'function'>
<samp class=prompt>>>> </samp><kbd>FunctionType</kbd> <span>&#x2461;</span>
<samp class=traceback>Traceback (innermost last):
  File "&lt;interactive input>", line 1, in ?
NameError: There is no variable named 'FunctionType'</samp>
<samp class=prompt>>>> </samp><kbd>from types import FunctionType</kbd> <span>&#x2462;</span>
<samp class=prompt>>>> </samp><kbd>FunctionType</kbd> <span>&#x2463;</span>
&lt;type 'function'></pre><div class=calloutlist>
<ol>
<li>The <code>types</code> module contains no methods; it just has attributes for each Python object type. Note that the attribute, <code>FunctionType</code>, must be qualified by the module name, <code>types</code>.
<li><code>FunctionType</code> by itself has not been defined in this namespace; it exists only in the context of <code>types</code>.
<li>This syntax imports the attribute <code>FunctionType</code> from the <code>types</code> module directly into the local namespace.
<li>Now <code>FunctionType</code> can be accessed directly, without reference to <code>types</code>.
<p>When should you use <code>from <var>module</var> import</code>?
<div class=itemizedlist>
<ul>
<li>If you will be accessing attributes and methods often and don't want to type the module name over and over, use <code>from <var>module</var> import</code>.

<li>If you want to selectively import some attributes and methods but not others, use <code>from <var>module</var> import</code>.

<li>If the module contains attributes or functions with the same name as ones in your module, you must use <code>import <var>module</var></code> to avoid name conflicts.

</ul>
<p>Other than that, it's just a matter of style, and you will see Python code written both ways.
<table class=caution border="0" summary="">

<td rowspan="2" align="center" valign="top" width="1%"><img src="images/caution.png" alt="Caution" title="" width="24" height="24"><td colspan="2" align="left" valign="top" width="99%">Use <code>from module import *</code> sparingly, because it makes it difficult to determine where a particular function or attribute came from, and that makes
      debugging and refactoring more difficult.
<div class=itemizedlist>
<h3>Further Reading on Module Importing Techniques</h3>
<ul>
<li><a href="http://www.effbot.org/guides/">eff-bot</a> has more to say on <a href="http://www.effbot.org/guides/import-confusion.htm"><code>import <var>module</var></code> <i class=foreignphrase><abbr>vs.</abbr></i> <code>from <var>module</var> import</code></a>.

<li><a href="http://www.python.org/doc/current/tut/tut.html"><i class=citetitle>Python Tutorial</i></a> discusses advanced import techniques, including <a href="http://www.python.org/doc/current/tut/node8.html#SECTION008410000000000000000"><code>from <var>module</var> import *</code></a>.

</ul>
<h2 id="fileinfo.class">5.3. Defining Classes</h2>
<p>Python is fully object-oriented: you can define your own classes, inherit from your own or built-in classes, and instantiate the
   classes you've defined.
<p>Defining a class in Python is simple. As with functions, there is no separate interface definition. Just define the class and start coding. A Python class starts with the reserved word <code>class</code>, followed by the class name. Technically, that's all that's required, since a class doesn't need to inherit from any other
class.
<div class=example><h3 id="fileinfo.class.simplest">Example 5.3. The Simplest Python Class</h3><pre><code>
class Loaf: <span>&#x2460;</span>
    pass    <span>&#x2461;</span> <span>&#x2462;</span></pre><div class=calloutlist>
<ol>
<li>The name of this class is <code>Loaf</code>, and it doesn't inherit from any other class. Class names are usually capitalized, <code>EachWordLikeThis</code>, but this is only a convention, not a requirement.
<li>This class doesn't define any methods or attributes, but syntactically, there needs to be something in the definition, so
            you use <code>pass</code>. This is a Python reserved word that just means &#8220;move along, nothing to see here&#8221;. It's a statement that does nothing, and it's a good placeholder when you're stubbing out functions or classes.
<li>You probably guessed this, but everything in a class is indented, just like the code within a function, <code>if</code> statement, <code>for</code> loop, and so forth. The first thing not indented is not in the class.
<table id="compare.pass.java" class=note border="0" summary="">

<td rowspan="2" align="center" valign="top" width="1%"><img src="images/note.png" alt="Note" title="" width="24" height="24"><td colspan="2" align="left" valign="top" width="99%">The <code>pass</code> statement in Python is like an empty set of braces (<code>{}</code>) in Java or <abbr>C</abbr>.
<p>Of course, realistically, most classes will be inherited from other classes, and they will define their own class methods
and attributes. But as you've just seen, there is nothing that a class absolutely must have, other than a name. In particular,
<abbr>C++</abbr> programmers may find it odd that Python classes don't have explicit constructors and destructors. Python classes do have something similar to a constructor: the <code>__init__</code> method.
<div class=example><h3 id="fileinfo.class.example">Example 5.4. Defining the <code>FileInfo</code> Class</h3><pre><code>
from UserDict import UserDict

class FileInfo(UserDict): <span>&#x2460;</span></pre><div class=calloutlist>
<ol>
<li>In Python, the ancestor of a class is simply listed in parentheses immediately after the class name. So the <code>FileInfo</code> class is inherited from the <code>UserDict</code> class (which was <a href="#fileinfo.fromimport" title="5.2. Importing Modules Using from module import">imported from the <code>UserDict</code> module</a>). <code>UserDict</code> is a class that acts like a dictionary, allowing you to essentially subclass the dictionary datatype and add your own behavior.
             (There are similar classes <code>UserList</code> and <code>UserString</code> which allow you to subclass lists and strings.)  There is a bit of black magic behind this, which you will demystify later
            in this chapter when you explore the <code>UserDict</code> class in more depth.
<table id="compare.extends.java" class=note border="0" summary="">

<td rowspan="2" align="center" valign="top" width="1%"><img src="images/note.png" alt="Note" title="" width="24" height="24"><td colspan="2" align="left" valign="top" width="99%">In Python, the ancestor of a class is simply listed in parentheses immediately after the class name. There is no special keyword like
<code>extends</code> in Java.
<p>Python supports multiple inheritance. In the parentheses following the class name, you can list as many ancestor classes as you
like, separated by commas.
<h3>5.3.1. Initializing and Coding Classes</h3>
<p>This example shows the initialization of the <code>FileInfo</code> class using the <code>__init__</code> method.
<div class=example><h3 id="fileinfo.init.example">Example 5.5. Initializing the <code>FileInfo</code> Class</h3><pre><code>
class FileInfo(UserDict):
    "store file metadata"              <span>&#x2460;</span>
    def __init__(self, filename=None): <span>&#x2461;</span> <span>&#x2462;</span> <span>&#x2463;</span></pre><div class=calloutlist>
<ol>
<li>Classes can (and <a href="#tip.docstring">should</a>) have <code>docstring</code>s too, just like modules and functions.
<li><code>__init__</code> is called immediately after an instance of the class is created. It would be tempting but incorrect to call this the constructor
               of the class. It's tempting, because it looks like a constructor (by convention, <code>__init__</code> is the first method defined for the class), acts like one (it's the first piece of code executed in a newly created instance
               of the class), and even sounds like one (&#8220;init&#8221; certainly suggests a constructor-ish nature). Incorrect, because the object has already been constructed by the time <code>__init__</code> is called, and you already have a valid reference to the new instance of the class. But <code>__init__</code> is the closest thing you're going to get to a constructor in Python, and it fills much the same role.
<li>The first argument of every class method, including <code>__init__</code>, is always a reference to the current instance of the class. By convention, this argument is always named <code>self</code>. In the <code>__init__</code> method, <code>self</code> refers to the newly created object; in other class methods, it refers to the instance whose method was called. Although
               you need to specify <code>self</code> explicitly when defining the method, you do <em>not</em> specify it when calling the method; Python will add it for you automatically.
<li><code>__init__</code> methods can take any number of arguments, and just like functions, the arguments can be defined with default values, making
               them optional to the caller. In this case, <var>filename</var> has a default value of <code>None</code>, which is the Python null value.
<table id="compare.self.java" class=note border="0" summary="">

<td rowspan="2" align="center" valign="top" width="1%"><img src="images/note.png" alt="Note" title="" width="24" height="24"><td colspan="2" align="left" valign="top" width="99%">By convention, the first argument of any Python class method (the reference to the current instance) is called <code>self</code>. This argument fills the role of the reserved word <code>this</code> in <abbr>C++</abbr> or Java, but <code>self</code> is not a reserved word in Python, merely a naming convention. Nonetheless, please don't call it anything but <code>self</code>; this is a very strong convention.
<div class=example><h3 id="fileinfo.init.code.example">Example 5.6. Coding the <code>FileInfo</code> Class</h3><pre><code>
class FileInfo(UserDict):
    "store file metadata"
    def __init__(self, filename=None):
        UserDict.__init__(self)        <span>&#x2460;</span>
        self["name"] = filename        <span>&#x2461;</span>
<span>&#x2462;</span></pre><div class=calloutlist>
<ol>
<li>Some pseudo-object-oriented languages like Powerbuilder have a concept of &#8220;extending&#8221; constructors and other events, where the ancestor's method is called automatically before the descendant's method is executed.
                Python does not do this; you must always explicitly call the appropriate method in the ancestor class.
<li>I told you that this class acts like a dictionary, and here is the first sign of it. You're assigning the argument <var>filename</var> as the value of this object's <code>name</code> key.
<li>Note that the <code>__init__</code> method never returns a value.
<h3>5.3.2. Knowing When to Use <code>self</code> and <code>__init__</code></h3>
<p>When defining your class methods, you <em>must</em> explicitly list <code>self</code> as the first argument for each method, including <code>__init__</code>. When you call a method of an ancestor class from within your class, you <em>must</em> include the <code>self</code> argument. But when you call your class method from outside, you do not specify anything for the <code>self</code> argument; you skip it entirely, and Python automatically adds the instance reference for you. I am aware that this is confusing at first; it's not really inconsistent,
   but it may appear inconsistent because it relies on a distinction (between bound and unbound methods) that you don't know
   about yet.
<p>Whew. I realize that's a lot to absorb, but you'll get the hang of it. All Python classes work the same way, so once you learn one, you've learned them all. If you forget everything else, remember this
   one thing, because I promise it will trip you up:<table id="tip.initoptional" class=note border="0" summary="">

<td rowspan="2" align="center" valign="top" width="1%"><img src="images/note.png" alt="Note" title="" width="24" height="24"><td colspan="2" align="left" valign="top" width="99%"><code>__init__</code> methods are optional, but when you define one, you must remember to explicitly call the ancestor's <code>__init__</code> method (if it defines one). This is more generally true: whenever a descendant wants to extend the behavior of the ancestor,
         the descendant method must explicitly call the ancestor method at the proper time, with the proper arguments.
<div class=itemizedlist>
<h3>Further Reading on Python Classes</h3>
<ul>
<li><a href="http://www.freenetpages.co.uk/hp/alan.gauld/" title="Python book for first-time programmers"><i class=citetitle>Learning to Program</i></a> has a gentler <a href="http://www.freenetpages.co.uk/hp/alan.gauld/tutclass.htm">introduction to classes</a>.

<li><a href="http://www.ibiblio.org/obp/thinkCSpy/" title="Python book for computer science majors"><i class=citetitle>How to Think Like a Computer Scientist</i></a> shows how to <a href="http://www.ibiblio.org/obp/thinkCSpy/chap12.htm">use classes to model compound datatypes</a>.

<li><a href="http://www.python.org/doc/current/tut/tut.html"><i class=citetitle>Python Tutorial</i></a> has an in-depth look at <a href="http://www.python.org/doc/current/tut/node11.html">classes, namespaces, and inheritance</a>.

<li><a href="http://www.faqts.com/knowledge-base/index.phtml/fid/199/">Python Knowledge Base</a> answers <a href="http://www.faqts.com/knowledge-base/index.phtml/fid/242">common questions about classes</a>.

</ul>
<h2 id="fileinfo.create">5.4. Instantiating Classes</h2>
<p>Instantiating classes in Python is straightforward. To instantiate a class, simply call the class as if it were a function, passing the arguments that the
<code>__init__</code> method defines. The return value will be the newly created object.
<div class=example><h3>Example 5.7. Creating a <code>FileInfo</code> Instance</h3><pre class=screen><samp class=prompt>>>> </samp><kbd>import fileinfo</kbd>
<samp class=prompt>>>> </samp><kbd>f = fileinfo.FileInfo("/music/_singles/kairo.mp3")</kbd> <span>&#x2460;</span>
<samp class=prompt>>>> </samp><kbd>f.__class__</kbd>    <span>&#x2461;</span>
&lt;class fileinfo.FileInfo at 010EC204>
<samp class=prompt>>>> </samp><kbd>f.__doc__</kbd>      <span>&#x2462;</span>
'store file metadata'
<samp class=prompt>>>> </samp><kbd>f</kbd>              <span>&#x2463;</span>
{'name': '/music/_singles/kairo.mp3'}</pre><div class=calloutlist>
<ol>
<li>You are creating an instance of the <code>FileInfo</code> class (defined in the <code>fileinfo</code> module) and assigning the newly created instance to the variable <var>f</var>. You are passing one parameter, <code>/music/_singles/kairo.mp3</code>, which will end up as the <var>filename</var> argument in <code>FileInfo</code>'s <code>__init__</code> method.
<li>Every class instance has a built-in attribute, <code>__class__</code>, which is the object's class. (Note that the representation of this includes the physical address of the instance on my
            machine; your representation will be different.)  Java programmers may be familiar with the <code>Class</code> class, which contains methods like <code>getName</code> and <code>getSuperclass</code> to get metadata information about an object. In Python, this kind of metadata is available directly on the object itself through attributes like <code>__class__</code>, <code>__name__</code>, and <code>__bases__</code>.
<li>You can access the instance's <code>docstring</code> just as with a function or a module. All instances of a class share the same <code>docstring</code>.
<li>Remember when the <code>__init__</code> method <a href="#fileinfo.class.example" title="Example 5.4. Defining the FileInfo Class">assigned its <var>filename</var> argument to <code>self["name"]</code></a>?  Well, here's the result. The arguments you pass when you create the class instance get sent right along to the <code>__init__</code> method (along with the object reference, <code>self</code>, which Python adds for free).
<table id="compare.new.java" class=note border="0" summary="">

<td rowspan="2" align="center" valign="top" width="1%"><img src="images/note.png" alt="Note" title="" width="24" height="24"><td colspan="2" align="left" valign="top" width="99%">In Python, simply call a class as if it were a function to create a new instance of the class. There is no explicit <code>new</code> operator like <abbr>C++</abbr> or Java.
<h3>5.4.1. Garbage Collection</h3>
<p>If creating new instances is easy, destroying them is even easier. In general, there is no need to explicitly free instances,
   because they are freed automatically when the variables assigned to them go out of scope. Memory leaks are rare in Python.
<div class=example><h3 id="fileinfo.scope">Example 5.8. Trying to Implement a Memory Leak</h3><pre class=screen><samp class=prompt>>>> </samp><kbd>def leakmem():</kbd>
<samp class=prompt>...    </samp>f = fileinfo.FileInfo('/music/_singles/kairo.mp3') <span>&#x2460;</span>
<samp class=prompt>...    </samp>
<samp class=prompt>>>> </samp><kbd>for i in range(100):</kbd>
<samp class=prompt>...    </samp>leakmem()      <span>&#x2461;</span></pre><div class=calloutlist>
<ol>
<li>Every time the <code>leakmem</code> function is called, you are creating an instance of <code>FileInfo</code> and assigning it to the variable <var>f</var>, which is a local variable within the function. Then the function ends without ever freeing <var>f</var>, so you would expect a memory leak, but you would be wrong. When the function ends, the local variable <var>f</var> goes out of scope. At this point, there are no longer any references to the newly created instance of <code>FileInfo</code> (since you never assigned it to anything other than <var>f</var>), so Python destroys the instance for us.
<li>No matter how many times you call the <code>leakmem</code> function, it will never leak memory, because every time, Python will destroy the newly created <code>FileInfo</code> class before returning from <code>leakmem</code>.
<p>The technical term for this form of garbage collection is &#8220;reference counting&#8221;. Python keeps a list of references to every instance created. In the above example, there was only one reference to the <code>FileInfo</code> instance: the local variable <var>f</var>. When the function ends, the variable <var>f</var> goes out of scope, so the reference count drops to <code>0</code>, and Python destroys the instance automatically.
<p>In previous versions of Python, there were situations where reference counting failed, and Python couldn't clean up after you. If you created two instances that referenced each other (for instance, a doubly-linked list,
   where each node has a pointer to the previous and next node in the list), neither instance would ever be destroyed automatically
   because Python (correctly) believed that there is always a reference to each instance. Python 2.0 has an additional form of garbage collection called &#8220;mark-and-sweep&#8221; which is smart enough to notice this virtual gridlock and clean up circular references correctly.
<p>As a former philosophy major, it disturbs me to think that things disappear when no one is looking at them, but that's exactly
   what happens in Python. In general, you can simply forget about memory management and let Python clean up after you.
<div class=itemizedlist>
<h3>Further Reading on Garbage Collection</h3>
<ul>
<li><a href="http://www.python.org/doc/current/lib/"><i class=citetitle>Python Library Reference</i></a> summarizes <a href="http://www.python.org/doc/current/lib/specialattrs.html">built-in attributes like <code>__class__</code></a>.

<li><a href="http://www.python.org/doc/current/lib/"><i class=citetitle>Python Library Reference</i></a> documents the <a href="http://www.python.org/doc/current/lib/module-gc.html"><code>gc</code> module</a>, which gives you low-level control over Python's garbage collection.

</ul>
<h2 id="fileinfo.userdict">5.5. Exploring <code>UserDict</code>: A Wrapper Class</h2>
<p>As you've seen, <code>FileInfo</code> is a class that acts like a dictionary. To explore this further, let's look at the <code>UserDict</code> class in the <code>UserDict</code> module, which is the ancestor of the <code>FileInfo</code> class. This is nothing special; the class is written in Python and stored in a <code>.py</code> file, just like any other Python code. In particular, it's stored in the <code>lib</code> directory in your Python installation.
<table id="tip.locate" class=tip border="0" summary="">

<td rowspan="2" align="center" valign="top" width="1%"><img src="images/tip.png" alt="Tip" title="" width="24" height="24"><td colspan="2" align="left" valign="top" width="99%">In the ActivePython <abbr>IDE</abbr> on Windows, you can quickly open any module in your library path by selecting
File->Locate... (<kbd class=shortcut>Ctrl-L</kbd>).
<div class=example><h3 id="fileinfo.userdict.init.example">Example 5.9. Defining the <code>UserDict</code> Class</h3><pre><code>
class UserDict:              <span>&#x2460;</span>
    def __init__(self, dict=None):             <span>&#x2461;</span>
        self.data = {}       <span>&#x2462;</span>
        if dict is not None: self.update(dict) <span>&#x2463;</span> <span>&#x2464;</span>
</pre><div class=calloutlist>
<ol>
<li>Note that <code>UserDict</code> is a base class, not inherited from any other class.
<li>This is the <code>__init__</code> method that you <a href="#fileinfo.class.example" title="Example 5.4. Defining the FileInfo Class">overrode in the <code>FileInfo</code> class</a>. Note that the argument list in this ancestor class is different than the descendant. That's okay; each subclass can have
            its own set of arguments, as long as it calls the ancestor with the correct arguments. Here the ancestor class has a way
            to define initial values (by passing a dictionary in the <var>dict</var> argument) which the <code>FileInfo</code> does not use.
<li>Python supports data attributes (called &#8220;instance variables&#8221; in Java and Powerbuilder, and &#8220;member variables&#8221; in <abbr>C++</abbr>). Data attributes are pieces of data held by a specific instance of a class. In this case, each instance of <code>UserDict</code> will have a data attribute <var>data</var>. To reference this attribute from code outside the class, you qualify it with the instance name, <code><var>instance</var>.data</code>, in the same way that you qualify a function with its module name. To reference a data attribute from within the class,
            you use <code>self</code> as the qualifier. By convention, all data attributes are initialized to reasonable values in the <code>__init__</code> method. However, this is not required, since data attributes, like local variables, <a href="#odbchelper.vardef" title="3.4. Declaring variables">spring into existence</a> when they are first assigned a value.
<li>The <code>update</code> method is a dictionary duplicator: it copies all the keys and values from one dictionary to another. This does <em>not</em> clear the target dictionary first; if the target dictionary already has some keys, the ones from the source dictionary will
            be overwritten, but others will be left untouched. Think of <code>update</code> as a merge function, not a copy function.
<li>This is a syntax you may not have seen before (I haven't used it in the examples in this book). It's an <code>if</code> statement, but instead of having an indented block starting on the next line, there is just a single statement on the same
            line, after the colon. This is perfectly legal syntax, which is just a shortcut you can use when you have only one statement
            in a block. (It's like specifying a single statement without braces in <abbr>C++</abbr>.)  You can use this syntax, or you can have indented code on subsequent lines, but you can't do both for the same block.
<table id="compare.overloading" class=note border="0" summary="">

<td rowspan="2" align="center" valign="top" width="1%"><img src="images/note.png" alt="Note" title="" width="24" height="24"><td colspan="2" align="left" valign="top" width="99%">Java and Powerbuilder support function overloading by argument list, <i class=foreignphrase><abbr>i.e.</abbr></i> one class can have multiple methods with the same name but a different number of arguments, or arguments of different types.
       Other languages (most notably <abbr>PL/SQL</abbr>) even support function overloading by argument name; <i class=foreignphrase><abbr>i.e.</abbr></i> one class can have multiple methods with the same name and the same number of arguments of the same type but different argument
      names. Python supports neither of these; it has no form of function overloading whatsoever. Methods are defined solely by their name,
      and there can be only one method per class with a given name. So if a descendant class has an <code>__init__</code> method, it <em>always</em> overrides the ancestor <code>__init__</code> method, even if the descendant defines it with a different argument list. And the same rule applies to any other method.
<table id="fileinfo.derivedclasses" class=note border="0" summary="">

<td rowspan="2" align="center" valign="top" width="1%"><img src="images/note.png" alt="Note" title="" width="24" height="24"><td colspan="2" align="left" valign="top" width="99%">Guido, the original author of Python, explains method overriding this way: "Derived classes may override methods of their base classes. Because methods have no
      special privileges when calling other methods of the same object, a method of a base class that calls another method defined
      in the same base class, may in fact end up calling a method of a derived class that overrides it. (For <abbr>C++</abbr> programmers: all methods in Python are effectively virtual.)"  If that doesn't make sense to you (it confuses the hell out of me), feel free to ignore it. 
      I just thought I'd pass it along.
<table id="note.dataattributes" class=caution border="0" summary="">

<td rowspan="2" align="center" valign="top" width="1%"><img src="images/caution.png" alt="Caution" title="" width="24" height="24"><td colspan="2" align="left" valign="top" width="99%">Always assign an initial value to all of an instance's data attributes in the <code>__init__</code> method. It will save you hours of debugging later, tracking down <code>AttributeError</code> exceptions because you're referencing uninitialized (and therefore non-existent) attributes.
<div class=example><h3 id="fileinfo.userdict.normalmethods">Example 5.10. <code>UserDict</code> Normal Methods</h3><pre><code>
    def clear(self): self.data.clear()          <span>&#x2460;</span>
    def copy(self):           <span>&#x2461;</span>
        if self.__class__ is UserDict:          <span>&#x2462;</span>
            return UserDict(self.data)         
        import copy           <span>&#x2463;</span>
        return copy.copy(self)                 
    def keys(self): return self.data.keys()     <span>&#x2464;</span>
    def items(self): return self.data.items()  
    def values(self): return self.data.values()
</pre><div class=calloutlist>
<ol>
<li><code>clear</code> is a normal class method; it is publicly available to be called by anyone at any time. Notice that <code>clear</code>, like all class methods, has <code>self</code> as its first argument. (Remember that you don't include <code>self</code> when you call the method; it's something that Python adds for you.)  Also note the basic technique of this wrapper class: store a real dictionary (<var>data</var>) as a data attribute, define all the methods that a real dictionary has, and have each class method redirect to the corresponding
            method on the real dictionary. (In case you'd forgotten, a dictionary's <code>clear</code> method <a href="#odbchelper.dict.del" title="Example 3.5. Deleting Items from a Dictionary">deletes all of its keys</a> and their associated values.)
<li>The <code>copy</code> method of a real dictionary returns a new dictionary that is an exact duplicate of the original (all the same key-value pairs).
             But <code>UserDict</code> can't simply redirect to <code>self.data.copy</code>, because that method returns a real dictionary, and what you want is to return a new instance that is the same class as <code>self</code>.
<li>You use the <code>__class__</code> attribute to see if <code>self</code> is a <code>UserDict</code>; if so, you're golden, because you know how to copy a <code>UserDict</code>: just create a new <code>UserDict</code> and give it the real dictionary that you've squirreled away in <var>self.data</var>. Then you immediately return the new <code>UserDict</code> you don't even get to the <code>import copy</code> on the next line.
<li>If <code>self.__class__</code> is not <code>UserDict</code>, then <code>self</code> must be some subclass of <code>UserDict</code> (like maybe <code>FileInfo</code>), in which case life gets trickier. <code>UserDict</code> doesn't know how to make an exact copy of one of its descendants; there could, for instance, be other data attributes defined
            in the subclass, so you would need to iterate through them and make sure to copy all of them. Luckily, Python comes with a module to do exactly this, and it's called <code>copy</code>. I won't go into the details here (though it's a wicked cool module, if you're ever inclined to dive into it on your own).
             Suffice it to say that <code>copy</code> can copy arbitrary Python objects, and that's how you're using it here.
<li>The rest of the methods are straightforward, redirecting the calls to the built-in methods on <var>self.data</var>.
<table class=note border="0" summary="">

<td rowspan="2" align="center" valign="top" width="1%"><img src="images/note.png" alt="Note" title="" width="24" height="24"><td colspan="2" align="left" valign="top" width="99%">In versions of Python prior to 2.2, you could not directly subclass built-in datatypes like strings, lists, and dictionaries. To compensate for
      this, Python comes with wrapper classes that mimic the behavior of these built-in datatypes: <code>UserString</code>, <code>UserList</code>, and <code>UserDict</code>. Using a combination of normal and special methods, the <code>UserDict</code> class does an excellent imitation of a dictionary. In Python 2.2 and later, you can inherit classes directly from built-in datatypes like <code>dict</code>. An example of this is given in the examples that come with this book, in <code>fileinfo_fromdict.py</code>.
<p>In Python, you can inherit directly from the <code>dict</code> built-in datatype, as shown in this example. There are three differences here compared to the <code>UserDict</code> version.
<div class=example><h3 id="fileinfo.userdict.fromdict">Example 5.11. Inheriting Directly from Built-In Datatype <code>dict</code></h3><pre><code>
class FileInfo(dict):<span>&#x2460;</span>
    "store file metadata"
    def __init__(self, filename=None): <span>&#x2461;</span>
        self["name"] = filename
</pre><div class=calloutlist>
<ol>
<li>The first difference is that you don't need to import the <code>UserDict</code> module, since <code>dict</code> is a built-in datatype and is always available. The second is that you are inheriting from <code>dict</code> directly, instead of from <code>UserDict.UserDict</code>.
<li>The third difference is subtle but important. Because of the way <code>UserDict</code> works internally, it requires you to manually call its <code>__init__</code> method to properly initialize its internal data structures. <code>dict</code> does not work like this; it is not a wrapper, and it requires no explicit initialization.
<div class=itemizedlist>
<h3>Further Reading on <code>UserDict</code></h3>
<ul>
<li><a href="http://www.python.org/doc/current/lib/"><i class=citetitle>Python Library Reference</i></a> documents the <a href="http://www.python.org/doc/current/lib/module-UserDict.html"><code>UserDict</code> module</a> and the <a href="http://www.python.org/doc/current/lib/module-copy.html"><code>copy</code> module</a>.

</ul>
<h2 id="fileinfo.specialmethods">5.6. Special Class Methods</h2>
<p>In addition to normal class methods, there are a number of special methods that Python classes can define. Instead of being called directly by your code (like normal methods), special methods are called for
   you by Python in particular circumstances or when specific syntax is used.
<p>As you saw in the <a href="#fileinfo.userdict" title="5.5. Exploring UserDict: A Wrapper Class">previous section</a>, normal methods go a long way towards wrapping a dictionary in a class. But normal methods alone are not enough, because
there are a lot of things you can do with dictionaries besides call methods on them. For starters, you can <a href="#odbchelper.dict.define" title="Example 3.1. Defining a Dictionary">get</a> and <a href="#odbchelper.dict.modify" title="Example 3.2. Modifying a Dictionary">set</a> items with a syntax that doesn't include explicitly invoking methods. This is where special class methods come in: they
provide a way to map non-method-calling syntax into method calls.
<h3>5.6.1. Getting and Setting Items</h3>
<div class=example><h3>Example 5.12. The <code>__getitem__</code> Special Method</h3><pre><code>
    def __getitem__(self, key): return self.data[key]</pre><pre class=screen><samp class=prompt>>>> </samp><kbd>f = fileinfo.FileInfo("/music/_singles/kairo.mp3")</kbd>
<samp class=prompt>>>> </samp><kbd>f</kbd>
{'name':'/music/_singles/kairo.mp3'}
<samp class=prompt>>>> </samp><kbd>f.__getitem__("name")</kbd> <span>&#x2460;</span>
'/music/_singles/kairo.mp3'
<samp class=prompt>>>> </samp><kbd>f["name"]</kbd>             <span>&#x2461;</span>
'/music/_singles/kairo.mp3'</pre><div class=calloutlist>
<ol>
<li>The <code>__getitem__</code> special method looks simple enough. Like the normal methods <code>clear</code>, <code>keys</code>, and <code>values</code>, it just redirects to the dictionary to return its value. But how does it get called?  Well, you can call <code>__getitem__</code> directly, but in practice you wouldn't actually do that; I'm just doing it here to show you how it works. The right way
               to use <code>__getitem__</code> is to get Python to call it for you.
<li>This looks just like the syntax you would use to <a href="#odbchelper.dict.define" title="Example 3.1. Defining a Dictionary">get a dictionary value</a>, and in fact it returns the value you would expect. But here's the missing link: under the covers, Python has converted this syntax to the method call <code>f.__getitem__("name")</code>. That's why <code>__getitem__</code> is a special class method; not only can you call it yourself, you can get Python to call it for you by using the right syntax.
<p>Of course, Python has a <code>__setitem__</code> special method to go along with <code>__getitem__</code>, as shown in the next example.
<div class=example><h3 id="fileinfo.specialmethods.setitem.example">Example 5.13. The <code>__setitem__</code> Special Method</h3><pre><code>
    def __setitem__(self, key, item): self.data[key] = item</pre><pre class=screen><samp class=prompt>>>> </samp><kbd>f</kbd>
{'name':'/music/_singles/kairo.mp3'}
<samp class=prompt>>>> </samp><kbd>f.__setitem__("genre", 31)</kbd> <span>&#x2460;</span>
<samp class=prompt>>>> </samp><kbd>f</kbd>
{'name':'/music/_singles/kairo.mp3', 'genre':31}
<samp class=prompt>>>> </samp><kbd>f["genre"] = 32</kbd>            <span>&#x2461;</span>
<samp class=prompt>>>> </samp><kbd>f</kbd>
{'name':'/music/_singles/kairo.mp3', 'genre':32}</pre><div class=calloutlist>
<ol>
<li>Like the <code>__getitem__</code> method, <code>__setitem__</code> simply redirects to the real dictionary <var>self.data</var> to do its work. And like <code>__getitem__</code>, you wouldn't ordinarily call it directly like this; Python calls <code>__setitem__</code> for you when you use the right syntax.
<li>This looks like regular dictionary syntax, except of course that <var>f</var> is really a class that's trying very hard to masquerade as a dictionary, and <code>__setitem__</code> is an essential part of that masquerade. This line of code actually calls <code>f.__setitem__("genre", 32)</code> under the covers.
<p><code>__setitem__</code> is a special class method because it gets called for you, but it's still a class method. Just as easily as the <code>__setitem__</code> method was defined in <code>UserDict</code>, you can redefine it in the descendant class to override the ancestor method. This allows you to define classes that act
   like dictionaries in some ways but define their own behavior above and beyond the built-in dictionary.
<p>This concept is the basis of the entire framework you're studying in this chapter. Each file type can have a handler class
   that knows how to get metadata from a particular type of file. Once some attributes (like the file's name and location) are
   known, the handler class knows how to derive other attributes automatically. This is done by overriding the <code>__setitem__</code> method, checking for particular keys, and adding additional processing when they are found.
<p>For example, <code>MP3FileInfo</code> is a descendant of <code>FileInfo</code>. When an <code>MP3FileInfo</code>'s <code>name</code> is set, it doesn't just set the <code>name</code> key (like the ancestor <code>FileInfo</code> does); it also looks in the file itself for <abbr>MP3</abbr> tags and populates a whole set of keys. The next example shows how this works.
<div class=example><h3>Example 5.14. Overriding <code>__setitem__</code> in <code>MP3FileInfo</code></h3><pre><code>
    def __setitem__(self, key, item):         <span>&#x2460;</span>
        if key == "name" and item:            <span>&#x2461;</span>
            self.__parse(item)                <span>&#x2462;</span>
        FileInfo.__setitem__(self, key, item) <span>&#x2463;</span></pre><div class=calloutlist>
<ol>
<li>Notice that this <code>__setitem__</code> method is defined exactly the same way as the ancestor method. This is important, since Python will be calling the method for you, and it expects it to be defined with a certain number of arguments. (Technically speaking,
               the names of the arguments don't matter; only the number of arguments is important.)
<li>Here's the crux of the entire <code>MP3FileInfo</code> class: if you're assigning a value to the <code>name</code> key, you want to do something extra.
<li>The extra processing you do for <code>name</code>s is encapsulated in the <code>__parse</code> method. This is another class method defined in <code>MP3FileInfo</code>, and when you call it, you qualify it with <var>self</var>. Just calling <code>__parse</code> would look for a normal function defined outside the class, which is not what you want. Calling <code>self.__parse</code> will look for a class method defined within the class. This isn't anything new; you reference <a href="#fileinfo.userdict.normalmethods" title="Example 5.10. UserDict Normal Methods">data attributes</a> the same way.
<li>After doing this extra processing, you want to call the ancestor method. Remember that this is never done for you in Python; you must do it manually. Note that you're calling the immediate ancestor, <code>FileInfo</code>, even though it doesn't have a <code>__setitem__</code> method. That's okay, because Python will walk up the ancestor tree until it finds a class with the method you're calling, so this line of code will eventually
               find and call the <code>__setitem__</code> defined in <code>UserDict</code>.
<table id="tip.self.call" class=note border="0" summary="">

<td rowspan="2" align="center" valign="top" width="1%"><img src="images/note.png" alt="Note" title="" width="24" height="24"><td colspan="2" align="left" valign="top" width="99%">When accessing data attributes within a class, you need to qualify the attribute name: <code>self.<var>attribute</var></code>. When calling other methods within a class, you need to qualify the method name: <code>self.<var>method</var></code>.
<div class=example><h3 id="fileinfo.specialmethods.setname">Example 5.15. Setting an <code>MP3FileInfo</code>'s <code>name</code></h3><pre class=screen><samp class=prompt>>>> </samp><kbd>import fileinfo</kbd>
<samp class=prompt>>>> </samp><kbd>mp3file = fileinfo.MP3FileInfo()</kbd> <span>&#x2460;</span>
<samp class=prompt>>>> </samp><kbd>mp3file</kbd>
{'name':None}
<samp class=prompt>>>> </samp><kbd>mp3file["name"] = "/music/_singles/kairo.mp3"</kbd>      <span>&#x2461;</span>
<samp class=prompt>>>> </samp><kbd>mp3file</kbd>
<samp>{'album': 'Rave Mix', 'artist': '***DJ MARY-JANE***', 'genre': 31,
'title': 'KAIRO****THE BEST GOA', 'name': '/music/_singles/kairo.mp3',
'year': '2000', 'comment': 'http://mp3.com/DJMARYJANE'}</samp>
<samp class=prompt>>>> </samp><kbd>mp3file["name"] = "/music/_singles/sidewinder.mp3"</kbd> <span>&#x2462;</span>
<samp class=prompt>>>> </samp><kbd>mp3file</kbd>
<samp>{'album': '', 'artist': 'The Cynic Project', 'genre': 18, 'title': 'Sidewinder', 
'name': '/music/_singles/sidewinder.mp3', 'year': '2000', 
'comment': 'http://mp3.com/cynicproject'}</span></pre><div class=calloutlist>
<ol>
<li>First, you create an instance of <code>MP3FileInfo</code>, without passing it a filename. (You can get away with this because the <var>filename</var> argument of the <code>__init__</code> method is <a href="#apihelper.optional" title="4.2. Using Optional and Named Arguments">optional</a>.)  Since <code>MP3FileInfo</code> has no <code>__init__</code> method of its own, Python walks up the ancestor tree and finds the <code>__init__</code> method of <code>FileInfo</code>. This <code>__init__</code> method manually calls the <code>__init__</code> method of <code>UserDict</code> and then sets the <code>name</code> key to <var>filename</var>, which is <code>None</code>, since you didn't pass a filename. Thus, <var>mp3file</var> initially looks like a dictionary with one key, <code>name</code>, whose value is <code>None</code>.
               
<li>Now the real fun begins. Setting the <code>name</code> key of <var>mp3file</var> triggers the <code>__setitem__</code> method on <code>MP3FileInfo</code> (not <code>UserDict</code>), which notices that you're setting the <code>name</code> key with a real value and calls <code>self.__parse</code>. Although you haven't traced through the <code>__parse</code> method yet, you can see from the output that it sets several other keys: <code>album</code>, <code>artist</code>, <code>genre</code>, <code>title</code>, <code>year</code>, and <code>comment</code>.
               
<li>Modifying the <code>name</code> key will go through the same process again: Python calls <code>__setitem__</code>, which calls <code>self.__parse</code>, which sets all the other keys.
               
<h2 id="fileinfo.morespecial">5.7. Advanced Special Class Methods</h2>
<p>Python has more special methods than just <code>__getitem__</code> and <code>__setitem__</code>. Some of them let you emulate functionality that you may not even know about.
<p>This example shows some of the other special methods in <code>UserDict</code>.
<div class=example><h3 id="fileinfo.morespecial.example">Example 5.16. More Special Methods in <code>UserDict</code></h3><pre><code>
    def __repr__(self): return repr(self.data)     <span>&#x2460;</span>
    def __cmp__(self, dict):     <span>&#x2461;</span>
        if isinstance(dict, UserDict):            
            return cmp(self.data, dict.data)      
        else: 
            return cmp(self.data, dict)           
    def __len__(self): return len(self.data)       <span>&#x2462;</span>
    def __delitem__(self, key): del self.data[key] <span>&#x2463;</span></pre><div class=calloutlist>
<ol>
<li><code>__repr__</code> is a special method that is called when you call <code>repr(<var>instance</var>)</code>. The <code>repr</code> function is a built-in function that returns a string representation of an object. It works on any object, not just class
            instances. You're already intimately familiar with <code>repr</code> and you don't even know it. In the interactive window, when you type just a variable name and press the <kbd>ENTER</kbd> key, Python uses <code>repr</code> to display the variable's value. Go create a dictionary <var>d</var> with some data and then <code>print repr(d)</code> to see for yourself.
<li><code>__cmp__</code> is called when you compare class instances. In general, you can compare any two Python objects, not just class instances, by using <code>==</code>. There are rules that define when built-in datatypes are considered equal; for instance, dictionaries are equal when they
            have all the same keys and values, and strings are equal when they are the same length and contain the same sequence of characters.
             For class instances, you can define the <code>__cmp__</code> method and code the comparison logic yourself, and then you can use <code>==</code> to compare instances of your class and Python will call your <code>__cmp__</code> special method for you.
<li><code>__len__</code> is called when you call <code>len(<var>instance</var>)</code>. The <code>len</code> function is a built-in function that returns the length of an object. It works on any object that could reasonably be thought
            of as having a length. The <code>len</code> of a string is its number of characters; the <code>len</code> of a dictionary is its number of keys; the <code>len</code> of a list or tuple is its number of elements. For class instances, define the <code>__len__</code> method and code the length calculation yourself, and then call <code>len(<var>instance</var>)</code> and Python will call your <code>__len__</code> special method for you.
<li><code>__delitem__</code> is called when you call <code>del <var>instance</var>[<var>key</var>]</code>, which you may remember as the way to <a href="#odbchelper.dict.del" title="Example 3.5. Deleting Items from a Dictionary">delete individual items from a dictionary</a>. When you use <code>del</code> on a class instance, Python calls the <code>__delitem__</code> special method for you.
<table id="compare.strequals.java" class=note border="0" summary="">

<td rowspan="2" align="center" valign="top" width="1%"><img src="images/note.png" alt="Note" title="" width="24" height="24"><td colspan="2" align="left" valign="top" width="99%">In Java, you determine whether two string variables reference the same physical memory location by using <code>str1 == str2</code>. This is called <em>object identity</em>, and it is written in Python as <code>str1 is str2</code>. To compare string values in Java, you would use <code>str1.equals(str2)</code>; in Python, you would use <code>str1 == str2</code>. Java programmers who have been taught to believe that the world is a better place because <code>==</code> in Java compares by identity instead of by value may have a difficult time adjusting to Python's lack of such &#8220;gotchas&#8221;.
<p>At this point, you may be thinking, &#8220;All this work just to do something in a class that I can do with a built-in datatype.&#8221;  And it's true that life would be easier (and the entire <code>UserDict</code> class would be unnecessary) if you could inherit from built-in datatypes like a dictionary. But even if you could, special
methods would still be useful, because they can be used in any class, not just wrapper classes like <code>UserDict</code>.
<p>Special methods mean that <em>any class</em> can store key/value pairs like a dictionary, just by defining the <code>__setitem__</code> method. <em>Any class</em> can act like a sequence, just by defining the <code>__getitem__</code> method. Any class that defines the <code>__cmp__</code> method can be compared with <code>==</code>. And if your class represents something that has a length, don't define a <code>GetLength</code> method; define the <code>__len__</code> method and use <code>len(<var>instance</var>)</code>.
<table id="note.physical.v.logical" class=note border="0" summary="">

<td rowspan="2" align="center" valign="top" width="1%"><img src="images/note.png" alt="Note" title="" width="24" height="24"><td colspan="2" align="left" valign="top" width="99%">While other object-oriented languages only let you define the physical model of an object (&#8220;this object has a <code>GetLength</code> method&#8221;), Python's special class methods like <code>__len__</code> allow you to define the logical model of an object (&#8220;this object has a length&#8221;).
<p>Python has a lot of other special methods. There's a whole set of them that let classes act like numbers, allowing you to add,
subtract, and do other arithmetic operations on class instances. (The canonical example of this is a class that represents
complex numbers, numbers with both real and imaginary components.)  The <code>__call__</code> method lets a class act like a function, allowing you to call a class instance directly. And there are other special methods
that allow classes to have read-only and write-only data attributes; you'll talk more about those in later chapters.
<div class=itemizedlist>
<h3>Further Reading on Special Class Methods</h3>
<ul>
<li><a href="http://www.python.org/doc/current/ref/"><i class=citetitle>Python Reference Manual</i></a> documents <a href="http://www.python.org/doc/current/ref/specialnames.html">all the special class methods</a>.

</ul>
<h2 id="fileinfo.classattributes">5.8. Introducing Class Attributes</h2>
<p>You already know about <a href="#fileinfo.userdict.init.example" title="Example 5.9. Defining the UserDict Class">data attributes</a>, which are variables owned by a specific instance of a class. Python also supports class attributes, which are variables owned by the class itself.
<div class=example><h3 id="fileinfo.classattributes.intro">Example 5.17. Introducing Class Attributes</h3><pre><code>
class MP3FileInfo(FileInfo):
    "store ID3v1.0 MP3 tags"
    tagDataMap = {"title"   : (  3,  33, stripnulls),
"artist"  : ( 33,  63, stripnulls),
"album"   : ( 63,  93, stripnulls),
"year"    : ( 93,  97, stripnulls),
"comment" : ( 97, 126, stripnulls),
"genre"   : (127, 128, ord)}</pre><pre class=screen><samp class=prompt>>>> </samp><kbd>import fileinfo</kbd>
<samp class=prompt>>>> </samp><kbd>fileinfo.MP3FileInfo</kbd>            <span>&#x2460;</span>
&lt;class fileinfo.MP3FileInfo at 01257FDC>
<samp class=prompt>>>> </samp><kbd>fileinfo.MP3FileInfo.tagDataMap</kbd> <span>&#x2461;</span>
<samp>{'title': (3, 33, &lt;function stripnulls at 0260C8D4>), 
'genre': (127, 128, &lt;built-in function ord>), 
'artist': (33, 63, &lt;function stripnulls at 0260C8D4>), 
'year': (93, 97, &lt;function stripnulls at 0260C8D4>), 
'comment': (97, 126, &lt;function stripnulls at 0260C8D4>), 
'album': (63, 93, &lt;function stripnulls at 0260C8D4>)}</samp>
<samp class=prompt>>>> </samp><kbd>m = fileinfo.MP3FileInfo()</kbd>      <span>&#x2462;</span>
<samp class=prompt>>>> </samp><kbd>m.tagDataMap</kbd>
<samp>{'title': (3, 33, &lt;function stripnulls at 0260C8D4>), 
'genre': (127, 128, &lt;built-in function ord>), 
'artist': (33, 63, &lt;function stripnulls at 0260C8D4>), 
'year': (93, 97, &lt;function stripnulls at 0260C8D4>), 
'comment': (97, 126, &lt;function stripnulls at 0260C8D4>), 
'album': (63, 93, &lt;function stripnulls at 0260C8D4>)}</span></pre><div class=calloutlist>
<ol>
<li><code>MP3FileInfo</code> is the class itself, not any particular instance of the class.
<li><var>tagDataMap</var> is a class attribute: literally, an attribute of the class. It is available before creating any instances of the class.
<li>Class attributes are available both through direct reference to the class and through any instance of the class.
<table id="compare.classattr.java" class=note border="0" summary="">

<td rowspan="2" align="center" valign="top" width="1%"><img src="images/note.png" alt="Note" title="" width="24" height="24"><td colspan="2" align="left" valign="top" width="99%">In Java, both static variables (called class attributes in Python) and instance variables (called data attributes in Python) are defined immediately after the class definition (one with the <code>static</code> keyword, one without). In Python, only class attributes can be defined here; data attributes are defined in the <code>__init__</code> method.
<p>Class attributes can be used as class-level constants (which is how you use them in <code>MP3FileInfo</code>), but they are not really constants. You can also change them.
<table class=note border="0" summary="">

<td rowspan="2" align="center" valign="top" width="1%"><img src="images/note.png" alt="Note" title="" width="24" height="24"><td colspan="2" align="left" valign="top" width="99%">There are no constants in Python. Everything can be changed if you try hard enough. This fits with one of the core principles of Python: bad behavior should be discouraged but not banned. If you really want to change the value of <code>None</code>, you can do it, but don't come running to me when your code is impossible to debug.
<div class=example><h3 id="fileinfo.classattributes.writeable.example">Example 5.18. Modifying Class Attributes</h3><pre class=screen><samp class=prompt>>>> </samp><kbd>class counter:</kbd>
<samp class=prompt>...    </samp>count = 0   <span>&#x2460;</span>
<samp class=prompt>...    </samp>def __init__(self):
<samp class=prompt>...    </samp>    self.__class__.count += 1 <span>&#x2461;</span>
<samp class=prompt>...    </samp>
<samp class=prompt>>>> </samp><kbd>counter</kbd>
&lt;class __main__.counter at 010EAECC>
<samp class=prompt>>>> </samp><kbd>counter.count</kbd>   <span>&#x2462;</span>
0
<samp class=prompt>>>> </samp><kbd>c = counter()</kbd>
<samp class=prompt>>>> </samp><kbd>c.count</kbd>         <span>&#x2463;</span>
1
<samp class=prompt>>>> </samp><kbd>counter.count</kbd>
1
<samp class=prompt>>>> </samp><kbd>d = counter()</kbd>   <span>&#x2464;</span>
<samp class=prompt>>>> </samp><kbd>d.count</kbd>
2
<samp class=prompt>>>> </samp><kbd>c.count</kbd>
2
<samp class=prompt>>>> </samp><kbd>counter.count</kbd>
2</pre><div class=calloutlist>
<ol>
<li><var>count</var> is a class attribute of the <code>counter</code> class.
<li><code>__class__</code> is a built-in attribute of every class instance (of every class). It is a reference to the class that <var>self</var> is an instance of (in this case, the <code>counter</code> class).
<li>Because <var>count</var> is a class attribute, it is available through direct reference to the class, before you have created any instances of the
            class.
<li>Creating an instance of the class calls the <code>__init__</code> method, which increments the class attribute <var>count</var> by <code>1</code>. This affects the class itself, not just the newly created instance.
<li>Creating a second instance will increment the class attribute <var>count</var> again. Notice how the class attribute is shared by the class and all instances of the class.
<h2 id="fileinfo.private">5.9. Private Functions</h2>
<p>Like most languages, Python has the concept of private elements:
<div class=itemizedlist>
<ul>
<li>Private functions, which can't be called from outside their module
<li>Private class methods, which can't be called from outside their class
<li>Private attributes, which can't be accessed from outside their class.
</ul>
<p>Unlike in most languages, whether a Python function, method, or attribute is private or public is determined entirely by its name.
<p>If the name of a Python function, class method, or attribute starts with (but doesn't end with) two underscores, it's private; everything else is
public. Python has no concept of <em>protected</em> class methods (accessible only in their own class and descendant classes). Class methods are either private (accessible
only in their own class) or public (accessible from anywhere).
<p>In <code>MP3FileInfo</code>, there are two methods: <code>__parse</code> and <code>__setitem__</code>. As you have already discussed, <code>__setitem__</code> is a <a href="#fileinfo.specialmethods.setitem.example" title="Example 5.13. The __setitem__ Special Method">special method</a>; normally, you would call it indirectly by using the dictionary syntax on a class instance, but it is public, and you could
call it directly (even from outside the <code>fileinfo</code> module) if you had a really good reason. However, <code>__parse</code> is private, because it has two underscores at the beginning of its name.
<table id="tip.specialmethodnames" class=note border="0" summary="">

<td rowspan="2" align="center" valign="top" width="1%"><img src="images/note.png" alt="Note" title="" width="24" height="24"><td colspan="2" align="left" valign="top" width="99%">In Python, all special methods (like <a href="#fileinfo.specialmethods.setitem.example" title="Example 5.13. The __setitem__ Special Method"><code>__setitem__</code></a>) and built-in attributes (like <a href="#odbchelper.import" title="Example 2.3. Accessing the buildConnectionString Function's docstring"><code>__doc__</code></a>) follow a standard naming convention: they both start with and end with two underscores. Don't name your own methods and
      attributes this way, because it will only confuse you (and others) later.
<div class=example><h3>Example 5.19. Trying to Call a Private Method</h3><pre class=screen><samp class=prompt>>>> </samp><kbd>import fileinfo</kbd>
<samp class=prompt>>>> </samp><kbd>m = fileinfo.MP3FileInfo()</kbd>
<samp class=prompt>>>> </samp><kbd>m.__parse("/music/_singles/kairo.mp3")</kbd> <span>&#x2460;</span>
<samp class=traceback>Traceback (innermost last):
  File "&lt;interactive input>", line 1, in ?
AttributeError: 'MP3FileInfo' instance has no attribute '__parse'</span></pre><div class=calloutlist>
<ol>
<li>If you try to call a private method, Python will raise a slightly misleading exception, saying that the method does not exist. Of course it does exist, but it's private,
            so it's not accessible outside the class.Strictly speaking, private methods are accessible outside their class, just not <em>easily</em> accessible. Nothing in Python is truly private; internally, the names of private methods and attributes are mangled and unmangled on the fly to make them
            seem inaccessible by their given names. You can access the <code>__parse</code> method of the <code>MP3FileInfo</code> class by the name <code>_MP3FileInfo__parse</code>. Acknowledge that this is interesting, but promise to never, ever do it in real code. Private methods are private for a
            reason, but like many other things in Python, their privateness is ultimately a matter of convention, not force.
<div class=itemizedlist>
<h3>Further Reading on Private Functions</h3>
<ul>
<li><a href="http://www.python.org/doc/current/tut/tut.html"><i class=citetitle>Python Tutorial</i></a> discusses the inner workings of <a href="http://www.python.org/doc/current/tut/node11.html#SECTION0011600000000000000000">private variables</a>.

</ul>
<h2 id="fileinfo.summary">5.10. Summary</h2>
<p>That's it for the hard-core object trickery. You'll see a real-world application of special class methods in <a href="#soap">Chapter 12</a>, which uses <code>getattr</code> to create a proxy to a remote web service.
<p>The next chapter will continue using this code sample to explore other Python concepts, such as exceptions, file objects, and <code>for</code> loops.
<p>Before diving into the next chapter, make sure you're comfortable doing all of these things:
<div class=itemizedlist>
<ul>
<li>Importing modules using either <a href="#odbchelper.import" title="Example 2.3. Accessing the buildConnectionString Function's docstring"><code>import <var>module</var></code></a> or <a href="#fileinfo.fromimport" title="5.2. Importing Modules Using from module import"><code>from <var>module</var> import</code></a>
<li><a href="#fileinfo.class" title="5.3. Defining Classes">Defining</a> and <a href="#fileinfo.create" title="5.4. Instantiating Classes">instantiating</a> classes

<li>Defining <a href="#fileinfo.class.example" title="Example 5.4. Defining the FileInfo Class"><code>__init__</code> methods</a> and other <a href="#fileinfo.specialmethods" title="5.6. Special Class Methods">special class methods</a>, and understanding when they are called

<li>Subclassing <a href="#fileinfo.userdict" title="5.5. Exploring UserDict: A Wrapper Class"><code>UserDict</code></a> to define classes that act like dictionaries

<li>Defining <a href="#fileinfo.userdict.init.example" title="Example 5.9. Defining the UserDict Class">data attributes</a> and <a href="#fileinfo.classattributes" title="5.8. Introducing Class Attributes">class attributes</a>, and understanding the differences between them

<li>Defining <a href="#fileinfo.private" title="5.9. Private Functions">private attributes and methods</a>
</ul>
<div class=chapter>
<h2 id="filehandling">Chapter 6. Exceptions and File Handling</h2>
<p>In this chapter, you will dive into exceptions, file objects, <code>for</code> loops, and the <code>os</code> and <code>sys</code> modules. If you've used exceptions in another programming language, you can skim the first section to get a sense of Python's syntax. Be sure to tune in again for file handling.
<h2 id="fileinfo.exception">6.1. Handling Exceptions</h2>
<p>Like many other programming languages, Python has exception handling via <code>try...except</code> blocks.
<table id="compare.exceptions.java" class=note border="0" summary="">

<td rowspan="2" align="center" valign="top" width="1%"><img src="images/note.png" alt="Note" title="" width="24" height="24"><td colspan="2" align="left" valign="top" width="99%">Python uses <code>try...except</code> to handle exceptions and <code>raise</code> to generate them. Java and <abbr>C++</abbr> use <code>try...catch</code> to handle exceptions, and <code>throw</code> to generate them.
<p>Exceptions are everywhere in Python. Virtually every module in the standard Python library uses them, and Python itself will raise them in a lot of different circumstances. You've already seen them repeatedly throughout this book.
<div class=itemizedlist>
<ul>
<li><a href="#odbchelper.dict.define" title="Example 3.1. Defining a Dictionary">Accessing a non-existent dictionary key</a> will raise a <code>KeyError</code> exception.

<li><a href="#odbchelper.list.search" title="Example 3.12. Searching a List">Searching a list for a non-existent value</a> will raise a <code>ValueError</code> exception.

<li><a href="#odbchelper.tuplemethods" title="Example 3.16. Tuples Have No Methods">Calling a non-existent method</a> will raise an <code>AttributeError</code> exception.

<li><a href="#odbchelper.unboundvariable" title="Example 3.18. Referencing an Unbound Variable">Referencing a non-existent variable</a> will raise a <code>NameError</code> exception.

<li><a href="#odbchelper.stringformatting.coerce" title="Example 3.22. String Formatting vs. Concatenating">Mixing datatypes without coercion</a> will raise a <code>TypeError</code> exception.

</ul>
<p>In each of these cases, you were simply playing around in the Python <abbr>IDE</abbr>: an error occurred, the exception was printed (depending on your <abbr>IDE</abbr>, perhaps in an intentionally jarring shade of red), and that was that. This is called an <em>unhandled</em> exception. When the exception was raised, there was no code to explicitly notice it and deal with it, so it bubbled its
way back to the default behavior built in to Python, which is to spit out some debugging information and give up. In the <abbr>IDE</abbr>, that's no big deal, but if that happened while your actual Python program was running, the entire program would come to a screeching halt.
<p>An exception doesn't need result in a complete program crash, though. Exceptions, when raised, can be <em>handled</em>. Sometimes an exception is really because you have a bug in your code (like accessing a variable that doesn't exist), but
many times, an exception is something you can anticipate. If you're opening a file, it might not exist. If you're connecting
to a database, it might be unavailable, or you might not have the correct security credentials to access it. If you know
a line of code may raise an exception, you should handle the exception using a <code>try...except</code> block.
<div class=example><h3>Example 6.1. Opening a Non-Existent File</h3><pre class=screen><samp class=prompt>>>> </samp><kbd>fsock = open("/notthere", "r")</kbd>      <span>&#x2460;</span>
<samp class=traceback>Traceback (innermost last):
  File "&lt;interactive input>", line 1, in ?
IOError: [Errno 2] No such file or directory: '/notthere'</samp>
<samp class=prompt>>>> </samp><kbd>try:</kbd>
<samp class=prompt>...    </samp>fsock = open("/notthere")       <span>&#x2461;</span>
<samp class=prompt>... </samp>except IOError:   <span>&#x2462;</span>
<samp class=prompt>...    </samp>print "The file does not exist, exiting gracefully"
<samp class=prompt>... </samp>print "This line will always print" <span>&#x2463;</span>
<samp>The file does not exist, exiting gracefully
This line will always print</span></pre><div class=calloutlist>
<ol>
<li>Using the built-in <code>open</code> function, you can try to open a file for reading (more on <code>open</code> in the next section). But the file doesn't exist, so this raises the <code>IOError</code> exception. Since you haven't provided any explicit check for an <code>IOError</code> exception, Python just prints out some debugging information about what happened and then gives up.
<li>You're trying to open the same non-existent file, but this time you're doing it within a <code>try...except</code> block.
<li>When the <code>open</code> method raises an <code>IOError</code> exception, you're ready for it. The <code>except IOError:</code> line catches the exception and executes your own block of code, which in this case just prints a more pleasant error message.
<li>Once an exception has been handled, processing continues normally on the first line after the <code>try...except</code> block. Note that this line will always print, whether or not an exception occurs. If you really did have a file called
<code>notthere</code> in your root directory, the call to <code>open</code> would succeed, the <code>except</code> clause would be ignored, and this line would still be executed.
<p>Exceptions may seem unfriendly (after all, if you don't catch the exception, your entire program will crash), but consider
the alternative. Would you rather get back an unusable file object to a non-existent file?  You'd need to check its validity
somehow anyway, and if you forgot, somewhere down the line, your program would give you strange errors somewhere down the
line that you would need to trace back to the source. I'm sure you've experienced this, and you know it's not fun. With
exceptions, errors occur immediately, and you can handle them in a standard way at the source of the problem.
<h3>6.1.1. Using Exceptions For Other Purposes</h3>
<p>There are a lot of other uses for exceptions besides handling actual error conditions. A common use in the standard Python library is to try to import a module, and then check whether it worked. Importing a module that does not exist will raise
   an <code>ImportError</code> exception. You can use this to define multiple levels of functionality based on which modules are available at run-time,
   or to support multiple platforms (where platform-specific code is separated into different modules).
<p>You can also define your own exceptions by creating a class that inherits from the built-in <code>Exception</code> class, and then raise your exceptions with the <code>raise</code> command. See the further reading section if you're interested in doing this.
<p>The next example demonstrates how to use an exception to support platform-specific functionality. This code comes from the
<code>getpass</code> module, a wrapper module for getting a password from the user. Getting a password is accomplished differently on <abbr>UNIX</abbr>, Windows, and Mac OS platforms, but this code encapsulates all of those differences.
<div class=example><h3 id="crossplatform.example">Example 6.2. Supporting Platform-Specific Functionality</h3><pre><code>
  # Bind the name getpass to the appropriate function
  try:
      import termios, TERMIOS   <span>&#x2460;</span>
  except ImportError:
      try:
          import msvcrt         <span>&#x2461;</span>
      except ImportError:
          try:
              from EasyDialogs import AskPassword <span>&#x2462;</span>
          except ImportError:
              getpass = default_getpass           <span>&#x2463;</span>
          else:                 <span>&#x2464;</span>
              getpass = AskPassword
      else:
          getpass = win_getpass
  else:
      getpass = unix_getpass</pre><div class=calloutlist>
<ol>
<li><code>termios</code> is a <abbr>UNIX</abbr>-specific module that provides low-level control over the input terminal. If this module is not available (because it's not
               on your system, or your system doesn't support it), the import fails and Python raises an <code>ImportError</code>, which you catch.
<li>OK, you didn't have <code>termios</code>, so let's try <code>msvcrt</code>, which is a Windows-specific module that provides an <abbr>API</abbr> to many useful functions in the Microsoft Visual C++ runtime services. If this import fails, Python will raise an <code>ImportError</code>, which you catch.
<li>If the first two didn't work, you try to import a function from <code>EasyDialogs</code>, which is a Mac OS-specific module that provides functions to pop up dialog boxes of various types. Once again, if this import fails, Python will raise an <code>ImportError</code>, which you catch.
<li>None of these platform-specific modules is available (which is possible, since Python has been ported to a lot of different platforms), so you need to fall back on a default password input function (which is
               defined elsewhere in the <code>getpass</code> module). Notice what you're doing here: assigning the function <code>default_getpass</code> to the variable <var>getpass</var>. If you read the official <code>getpass</code> documentation, it tells you that the <code>getpass</code> module defines a <code>getpass</code> function. It does this by binding <var>getpass</var> to the correct function for your platform. Then when you call the <code>getpass</code> function, you're really calling a platform-specific function that this code has set up for you. You don't need to know or
               care which platform your code is running on -- just call <code>getpass</code>, and it will always do the right thing.
<li>A <code>try...except</code> block can have an <code>else</code> clause, like an <code>if</code> statement. If no exception is raised during the <code>try</code> block, the <code>else</code> clause is executed afterwards. In this case, that means that the <code>from EasyDialogs import AskPassword</code> import worked, so you should bind <var>getpass</var> to the <code>AskPassword</code> function. Each of the other <code>try...except</code> blocks has similar <code>else</code> clauses to bind <var>getpass</var> to the appropriate function when you find an <code>import</code> that works.
<div class=itemizedlist>
<h3>Further Reading on Exception Handling</h3>
<ul>
<li><a href="http://www.python.org/doc/current/tut/tut.html"><i class=citetitle>Python Tutorial</i></a> discusses <a href="http://www.python.org/doc/current/tut/node10.html#SECTION0010400000000000000000">defining and raising your own exceptions, and handling multiple exceptions at once</a>.

<li><a href="http://www.python.org/doc/current/lib/"><i class=citetitle>Python Library Reference</i></a> summarizes <a href="http://www.python.org/doc/current/lib/module-exceptions.html">all the built-in exceptions</a>.

<li><a href="http://www.python.org/doc/current/lib/"><i class=citetitle>Python Library Reference</i></a> documents the <a href="http://www.python.org/doc/current/lib/module-getpass.html">getpass</a> module.

<li><a href="http://www.python.org/doc/current/lib/"><i class=citetitle>Python Library Reference</i></a> documents the <a href="http://www.python.org/doc/current/lib/module-traceback.html"><code>traceback</code> module</a>, which provides low-level access to exception attributes after an exception is raised.

<li><a href="http://www.python.org/doc/current/ref/"><i class=citetitle>Python Reference Manual</i></a> discusses the inner workings of the <a href="http://www.python.org/doc/current/ref/try.html"><code>try...except</code> block</a>.

</ul>
<h2 id="fileinfo.files">6.2. Working with File Objects</h2>
<p>Python has a built-in function, <code>open</code>, for opening a file on disk. <code>open</code> returns a file object, which has methods and attributes for getting information about and manipulating the opened file.
<div class=example><h3>Example 6.3. Opening a File</h3><pre class=screen><samp class=prompt>>>> </samp><kbd>f = open("/music/_singles/kairo.mp3", "rb")</kbd> <span>&#x2460;</span>
<samp class=prompt>>>> </samp><kbd>f</kbd>       <span>&#x2461;</span>
&lt;open file '/music/_singles/kairo.mp3', mode 'rb' at 010E3988>
<samp class=prompt>>>> </samp><kbd>f.mode</kbd>  <span>&#x2462;</span>
'rb'
<samp class=prompt>>>> </samp><kbd>f.name</kbd>  <span>&#x2463;</span>
'/music/_singles/kairo.mp3'</pre><div class=calloutlist>
<ol>
<li>The <code>open</code> method can take up to three parameters: a filename, a mode, and a buffering parameter. Only the first one, the filename,
            is required; the other two are <a href="#apihelper.optional" title="4.2. Using Optional and Named Arguments">optional</a>. If not specified, the file is opened for reading in text mode. Here you are opening the file for reading in binary mode.
             (<code>print open.__doc__</code> displays a great explanation of all the possible modes.)
<li>The <code>open</code> function returns an object (by now, <a href="#odbchelper.objects" title="2.4. Everything Is an Object">this should not surprise you</a>). A file object has several useful attributes.
<li>The <var>mode</var> attribute of a file object tells you in which mode the file was opened.
<li>The <var>name</var> attribute of a file object tells you the name of the file that the file object has open.
<h3>6.2.1. Reading Files</h3>
<p>After you open a file, the first thing you'll want to do is read from it, as shown in the next example.
<div class=example><h3>Example 6.4. Reading a File</h3><pre class=screen>
<samp class=prompt>>>> </samp><kbd>f</kbd>
&lt;open file '/music/_singles/kairo.mp3', mode 'rb' at 010E3988>
<samp class=prompt>>>> </samp><kbd>f.tell()</kbd>              <span>&#x2460;</span>
0
<samp class=prompt>>>> </samp><kbd>f.seek(-128, 2)</kbd>       <span>&#x2461;</span>
<samp class=prompt>>>> </samp><kbd>f.tell()</kbd>              <span>&#x2462;</span>
7542909
<samp class=prompt>>>> </samp><kbd>tagData = f.read(128)</kbd> <span>&#x2463;</span>
<samp class=prompt>>>> </samp><kbd>tagData</kbd>
<samp>'TAGKAIRO****THE BEST GOA         ***DJ MARY-JANE***            
Rave Mix    2000http://mp3.com/DJMARYJANE     \037'</samp>
<samp class=prompt>>>> </samp><kbd>f.tell()</kbd>              <span>&#x2464;</span>
7543037</pre><div class=calloutlist>
<ol>
<li>A file object maintains state about the file it has open. The <code>tell</code> method of a file object tells you your current position in the open file. Since you haven't done anything with this file
               yet, the current position is <code>0</code>, which is the beginning of the file.
<li>The <code>seek</code> method of a file object moves to another position in the open file. The second parameter specifies what the first one means;
<code>0</code> means move to an absolute position (counting from the start of the file), <code>1</code> means move to a relative position (counting from the current position), and <code>2</code> means move to a position relative to the end of the file. Since the <abbr>MP3</abbr> tags you're looking for are stored at the end of the file, you use <code>2</code> and tell the file object to move to a position <code>128</code> bytes from the end of the file.
<li>The <code>tell</code> method confirms that the current file position has moved.
<li>The <code>read</code> method reads a specified number of bytes from the open file and returns a string with the data that was read. The optional
               parameter specifies the maximum number of bytes to read. If no parameter is specified, <code>read</code> will read until the end of the file. (You could have simply said <code>read()</code> here, since you know exactly where you are in the file and you are, in fact, reading the last 128 bytes.)  The read data
               is assigned to the <var>tagData</var> variable, and the current position is updated based on how many bytes were read.
<li>The <code>tell</code> method confirms that the current position has moved. If you do the math, you'll see that after reading 128 bytes, the position
               has been incremented by 128.
<h3>6.2.2. Closing Files</h3>
<p>Open files consume system resources, and depending on the file mode, other programs may not be able to access them. It's
   important to close files as soon as you're finished with them.
<div class=example><h3>Example 6.5. Closing a File</h3><pre class=screen>
<samp class=prompt>>>> </samp><kbd>f</kbd>
&lt;open file '/music/_singles/kairo.mp3', mode 'rb' at 010E3988>
<samp class=prompt>>>> </samp><kbd>f.closed</kbd>       <span>&#x2460;</span>
False
<samp class=prompt>>>> </samp><kbd>f.close()</kbd>      <span>&#x2461;</span>
<samp class=prompt>>>> </samp><kbd>f</kbd>
&lt;closed file '/music/_singles/kairo.mp3', mode 'rb' at 010E3988>
<samp class=prompt>>>> </samp><kbd>f.closed</kbd>       <span>&#x2462;</span>
True
<samp class=prompt>>>> </samp><kbd>f.seek(0)</kbd>      <span>&#x2463;</span>
<samp class=traceback>Traceback (innermost last):
  File "&lt;interactive input>", line 1, in ?
ValueError: I/O operation on closed file</samp>
<samp class=prompt>>>> </samp><kbd>f.tell()</kbd>
<samp class=traceback>Traceback (innermost last):
  File "&lt;interactive input>", line 1, in ?
ValueError: I/O operation on closed file</samp>
<samp class=prompt>>>> </samp><kbd>f.read()</kbd>
<samp class=traceback>Traceback (innermost last):
  File "&lt;interactive input>", line 1, in ?
ValueError: I/O operation on closed file</samp>
<samp class=prompt>>>> </samp><kbd>f.close()</kbd>      <span>&#x2464;</span></pre><div class=calloutlist>
<ol>
<li>The <var>closed</var> attribute of a file object indicates whether the object has a file open or not. In this case, the file is still open (<var>closed</var> is <code>False</code>).
<li>To close a file, call the <code>close</code> method of the file object. This frees the lock (if any) that you were holding on the file, flushes buffered writes (if any)
               that the system hadn't gotten around to actually writing yet, and releases the system resources.
<li>The <var>closed</var> attribute confirms that the file is closed.
<li>Just because a file is closed doesn't mean that the file object ceases to exist. The variable <var>f</var> will continue to exist until it <a href="#fileinfo.scope" title="Example 5.8. Trying to Implement a Memory Leak">goes out of scope</a> or gets manually deleted. However, none of the methods that manipulate an open file will work once the file has been closed;
               they all raise an exception.
<li>Calling <code>close</code> on a file object whose file is already closed does <em>not</em> raise an exception; it fails silently.
<h3>6.2.3. Handling <abbr>I/O</abbr> Errors</h3>
<p>Now you've seen enough to understand the file handling code in the <code>fileinfo.py</code> sample code from teh previous chapter. This example shows how to safely open and read from a file and gracefully handle
   errors.
<div class=example><h3 id="fileinfo.files.incode">Example 6.6. File Objects in <code>MP3FileInfo</code></h3><pre><code>
        try:              <span>&#x2460;</span>
            fsock = open(filename, "rb", 0) <span>&#x2461;</span>
            try:         
                fsock.seek(-128, 2)         <span>&#x2462;</span>
                tagdata = fsock.read(128)   <span>&#x2463;</span>
            finally:      <span>&#x2464;</span>
                fsock.close()              
            .
            .
            .
        except IOError:   <span>&#x2465;</span>
            pass         </pre><div class=calloutlist>
<ol>
<li>Because opening and reading files is risky and may raise an exception, all of this code is wrapped in a <code>try...except</code> block. (Hey, isn't <a href="#odbchelper.indenting" title="2.5. Indenting Code">standardized indentation</a> great?  This is where you start to appreciate it.)
<li>The <code>open</code> function may raise an <code>IOError</code>. (Maybe the file doesn't exist.)
<li>The <code>seek</code> method may raise an <code>IOError</code>. (Maybe the file is smaller than 128 bytes.)
<li>The <code>read</code> method may raise an <code>IOError</code>. (Maybe the disk has a bad sector, or it's on a network drive and the network just went down.)
<li>This is new: a <code>try...finally</code> block. Once the file has been opened successfully by the <code>open</code> function, you want to make absolutely sure that you close it, even if an exception is raised by the <code>seek</code> or <code>read</code> methods. That's what a <code>try...finally</code> block is for: code in the <code>finally</code> block will <em>always</em> be executed, even if something in the <code>try</code> block raises an exception. Think of it as code that gets executed on the way out, regardless of what happened before.
<li>At last, you handle your <code>IOError</code> exception. This could be the <code>IOError</code> exception raised by the call to <code>open</code>, <code>seek</code>, or <code>read</code>. Here, you really don't care, because all you're going to do is ignore it silently and continue. (Remember, <code>pass</code> is a Python statement that <a href="#fileinfo.class.simplest" title="Example 5.3. The Simplest Python Class">does nothing</a>.)  That's perfectly legal; &#8220;handling&#8221; an exception can mean explicitly doing nothing. It still counts as handled, and processing will continue normally on the
               next line of code after the <code>try...except</code> block.
<h3>6.2.4. Writing to Files</h3>
<p>As you would expect, you can also write to files in much the same way that you read from them. There are two basic file modes:
<div class=itemizedlist>
<ul>
<li>"Append" mode will add data to the end of the file.
<li>"write" mode will overwrite the file.
</ul>
<p>Either mode will create the file automatically if it doesn't already exist, so there's never a need for any sort of fiddly
   "if the log file doesn't exist yet, create a new empty file just so you can open it for the first time" logic. Just open
   it and start writing.
<div class=example><h3 id="fileinfo.files.writeandappend">Example 6.7. Writing to Files</h3><pre class=screen>
<samp class=prompt>>>> </samp><kbd>logfile = open('test.log', 'w')</kbd> <span>&#x2460;</span>
<samp class=prompt>>>> </samp><kbd>logfile.write('test succeeded')</kbd> <span>&#x2461;</span>
<samp class=prompt>>>> </samp><kbd>logfile.close()</kbd>
<samp class=prompt>>>> </samp><kbd>print file('test.log').read()</kbd>   <span>&#x2462;</span>
test succeeded
<samp class=prompt>>>> </samp><kbd>logfile = open('test.log', 'a')</kbd> <span>&#x2463;</span>
<samp class=prompt>>>> </samp><kbd>logfile.write('line 2')</kbd>
<samp class=prompt>>>> </samp><kbd>logfile.close()</kbd>
<samp class=prompt>>>> </samp><kbd>print file('test.log').read()</kbd>   <span>&#x2464;</span>
test succeededline 2
</pre><div class=calloutlist>
<ol>
<li>You start boldly by creating either the new file <code>test.log</code> or overwrites the existing file, and opening the file for writing. (The second parameter <code>"w"</code> means open the file for writing.)  Yes, that's all as dangerous as it sounds. I hope you didn't care about the previous
               contents of that file, because it's gone now.
<li>You can add data to the newly opened file with the <code>write</code> method of the file object returned by <code>open</code>.
<li><code>file</code> is a synonym for <code>open</code>. This one-liner opens the file, reads its contents, and prints them.
<li>You happen to know that <code>test.log</code> exists (since you just finished writing to it), so you can open it and append to it. (The <code>"a"</code> parameter means open the file for appending.)  Actually you could do this even if the file didn't exist, because opening
               the file for appending will create the file if necessary. But appending will <em>never</em> harm the existing contents of the file.
<li>As you can see, both the original line you wrote and the second line you appended are now in <code>test.log</code>. Also note that carriage returns are not included. Since you didn't write them explicitly to the file either time, the
               file doesn't include them. You can write a carriage return with the <code>"\n"</code> character. Since you didn't do this, everything you wrote to the file ended up smooshed together on the same line.
<div class=itemizedlist>
<h3>Further Reading on File Handling</h3>
<ul>
<li><a href="http://www.python.org/doc/current/tut/tut.html"><i class=citetitle>Python Tutorial</i></a> discusses reading and writing files, including how to <a href="http://www.python.org/doc/current/tut/node9.html#SECTION009210000000000000000">read a file one line at a time into a list</a>.

<li><a href="http://www.effbot.org/guides/">eff-bot</a> discusses efficiency and performance of <a href="http://www.effbot.org/guides/readline-performance.htm">various ways of reading a file</a>.

<li><a href="http://www.faqts.com/knowledge-base/index.phtml/fid/199/">Python Knowledge Base</a> answers <a href="http://www.faqts.com/knowledge-base/index.phtml/fid/552">common questions about files</a>.

<li><a href="http://www.python.org/doc/current/lib/"><i class=citetitle>Python Library Reference</i></a> summarizes <a href="http://www.python.org/doc/current/lib/bltin-file-objects.html">all the file object methods</a>.

</ul>
<h2 id="fileinfo.for">6.3. Iterating with <code>for</code> Loops</h2>
<p>Like most other languages, Python has <code>for</code> loops. The only reason you haven't seen them until now is that Python is good at so many other things that you don't need them as often.
<p>Most other languages don't have a powerful list datatype like Python, so you end up doing a lot of manual work, specifying a start, end, and step to define a range of integers or characters
or other iteratable entities. But in Python, a <code>for</code> loop simply iterates over a list, the same way <a href="#odbchelper.map" title="3.6. Mapping Lists">list comprehensions</a> work.
<div class=example><h3>Example 6.8. Introducing the <code>for</code> Loop</h3><pre class=screen><samp class=prompt>>>> </samp><kbd>li = ['a', 'b', 'e']</kbd>
<samp class=prompt>>>> </samp><kbd>for s in li:</kbd>         <span>&#x2460;</span>
<samp class=prompt>...    </samp>print s          <span>&#x2461;</span>
<samp>a
b
e</samp>
<samp class=prompt>>>> </samp><kbd>print "\n".join(li)</kbd>  <span>&#x2462;</span>
<samp>a
b
e</span></pre><div class=calloutlist>
<ol>
<li>The syntax for a <code>for</code> loop is similar to <a href="#odbchelper.map" title="3.6. Mapping Lists">list comprehensions</a>. <var>li</var> is a list, and <var>s</var> will take the value of each element in turn, starting from the first element.
<li>Like an <code>if</code> statement or any other <a href="#odbchelper.indenting" title="2.5. Indenting Code">indented block</a>, a <code>for</code> loop can have any number of lines of code in it.
<li>This is the reason you haven't seen the <code>for</code> loop yet: you haven't needed it yet. It's amazing how often you use <code>for</code> loops in other languages when all you really want is a <code>join</code> or a list comprehension.
<p>Doing a &#8220;normal&#8221; (by Visual Basic standards) counter <code>for</code> loop is also simple.
<div class=example><h3 id="fileinfo.for.counter">Example 6.9. Simple Counters</h3><pre class=screen>
<samp class=prompt>>>> </samp><kbd>for i in range(5):</kbd>             <span>&#x2460;</span>
<samp class=prompt>...    </samp>print i
<samp>0
1
2
3
4</samp>
<samp class=prompt>>>> </samp><kbd>li = ['a', 'b', 'c', 'd', 'e']</kbd>
<samp class=prompt>>>> </samp><kbd>for i in range(len(li)):</kbd>       <span>&#x2461;</span>
<samp class=prompt>...    </samp>print li[i]
<samp>a
b
c
d
e</span>
</pre><div class=calloutlist>
<ol>
<li>As you saw in <a href="#odbchelper.multiassign.range" title="Example 3.20. Assigning Consecutive Values">Example 3.20, &#8220;Assigning Consecutive Values&#8221;</a>, <code>range</code> produces a list of integers, which you then loop through. I know it looks a bit odd, but it is occasionally (and I stress
<em>occasionally</em>) useful to have a counter loop.
<li>Don't ever do this. This is Visual Basic-style thinking. Break out of it. Just iterate through the list, as shown in the previous example.
<p><code>for</code> loops are not just for simple counters. They can iterate through all kinds of things. Here is an example of using a <code>for</code> loop to iterate through a dictionary.
<div class=example><h3 id="dictionaryiter.example">Example 6.10. Iterating Through a Dictionary</h3><pre class=screen>
<samp class=prompt>>>> </samp><kbd>import os</kbd>
<samp class=prompt>>>> </samp><kbd>for k, v in os.environ.items():</kbd>      <span>&#x2460;</span> <span>&#x2461;</span>
<samp class=prompt>...    </samp>print "%s=%s" % (k, v)
<samp>USERPROFILE=C:\Documents and Settings\mpilgrim
OS=Windows_NT
COMPUTERNAME=MPILGRIM
USERNAME=mpilgrim

[...snip...]</samp>
<samp class=prompt>>>> </samp><kbd>print "\n".join(["%s=%s" % (k, v)</kbd>
<samp class=prompt>...    </samp>for k, v in os.environ.items()]) <span>&#x2462;</span>
<samp>USERPROFILE=C:\Documents and Settings\mpilgrim
OS=Windows_NT
COMPUTERNAME=MPILGRIM
USERNAME=mpilgrim

[...snip...]</span></pre><div class=calloutlist>
<ol>
<li><var>os.environ</var> is a dictionary of the environment variables defined on your system. In Windows, these are your user and system variables
            accessible from <abbr>MS-DOS</abbr>. In <abbr>UNIX</abbr>, they are the variables exported in your shell's startup scripts. In Mac OS, there is no concept of environment variables, so this dictionary is empty.
<li><code>os.environ.items()</code> returns a list of tuples: <code>[(<var>key1</var>, <var>value1</var>), (<var>key2</var>, <var>value2</var>), ...]</code>. The <code>for</code> loop iterates through this list. The first round, it assigns <code><var>key1</var></code> to <var>k</var> and <code><var>value1</var></code> to <var>v</var>, so <var>k</var> = <code>USERPROFILE</code> and <var>v</var> = <code>C:\Documents and Settings\mpilgrim</code>. In the second round, <var>k</var> gets the second key, <code>OS</code>, and <var>v</var> gets the corresponding value, <code>Windows_NT</code>.
<li>With <a href="#odbchelper.multiassign" title="3.4.2. Assigning Multiple Values at Once">multi-variable assignment</a> and <a href="#odbchelper.map" title="3.6. Mapping Lists">list comprehensions</a>, you can replace the entire <code>for</code> loop with a single statement. Whether you actually do this in real code is a matter of personal coding style. I like it
            because it makes it clear that what I'm doing is mapping a dictionary into a list, then joining the list into a single string.
             Other programmers prefer to write this out as a <code>for</code> loop. The output is the same in either case, although this version is slightly faster, because there is only one <code>print</code> statement instead of many.
<p>Now we can look at the <code>for</code> loop in <code>MP3FileInfo</code>, from the sample <code>fileinfo.py</code> program introduced in <a href="#fileinfo">Chapter 5</a>.
<div class=example><h3 id="fileinfo.multiassign.for.example">Example 6.11. <code>for</code> Loop in <code>MP3FileInfo</code></h3><pre><code>
    tagDataMap = {"title"   : (  3,  33, stripnulls),
"artist"  : ( 33,  63, stripnulls),
"album"   : ( 63,  93, stripnulls),
"year"    : ( 93,  97, stripnulls),
"comment" : ( 97, 126, stripnulls),
"genre"   : (127, 128, ord)}             <span>&#x2460;</span>
    .
    .
    .
            if tagdata[:3] == "TAG":
                for tag, (start, end, parseFunc) in self.tagDataMap.items(): <span>&#x2461;</span>
  self[tag] = parseFunc(tagdata[start:end])                <span>&#x2462;</span></pre><div class=calloutlist>
<ol>
<li><var>tagDataMap</var> is a <a href="#fileinfo.classattributes" title="5.8. Introducing Class Attributes">class attribute</a> that defines the tags you're looking for in an <abbr>MP3</abbr> file. Tags are stored in fixed-length fields. Once you read the last 128 bytes of the file, bytes 3 through 32 of those
            are always the song title, 33 through 62 are always the artist name, 63 through 92 are the album name, and so forth. Note
            that <var>tagDataMap</var> is a dictionary of tuples, and each tuple contains two integers and a function reference.
<li>This looks complicated, but it's not. The structure of the <code>for</code> variables matches the structure of the elements of the list returned by <code>items</code>. Remember that <code>items</code> returns a list of tuples of the form <code>(<var>key</var>, <var>value</var>)</code>. The first element of that list is <code>("title", (3, 33, &lt;function stripnulls>))</code>, so the first time around the loop, <var>tag</var> gets <code>"title"</code>, <var>start</var> gets <code>3</code>, <var>end</var> gets <code>33</code>, and <var>parseFunc</var> gets the function <code>stripnulls</code>.
<li>Now that you've extracted all the parameters for a single <abbr>MP3</abbr> tag, saving the tag data is easy. You <a href="#odbchelper.list.slice" title="Example 3.8. Slicing a List">slice</a> <var>tagdata</var> from <var>start</var> to <var>end</var> to get the actual data for this tag, call <var>parseFunc</var> to post-process the data, and assign this as the value for the key <var>tag</var> in the pseudo-dictionary <var>self</var>. After iterating through all the elements in <var>tagDataMap</var>, <var>self</var> has the values for all the tags, and <a href="#fileinfo.specialmethods.setname" title="Example 5.15. Setting an MP3FileInfo's name">you know what that looks like</a>.
<h2 id="fileinfo.modules">6.4. Using <code><code>sys</code>.modules</code></h2>
<p>Modules, like everything else in Python, are objects. Once imported, you can always get a reference to a module through the global dictionary <code><code>sys</code>.modules</code>.
<div class=example><h3>Example 6.12. Introducing <code><code>sys</code>.modules</code></h3><pre class=screen><samp class=prompt>>>> </samp><kbd>import sys</kbd>        <span>&#x2460;</span>
<samp class=prompt>>>> </samp><kbd>print '\n'.join(sys.modules.keys())</kbd> <span>&#x2461;</span>
<samp>win32api
os.path
os
exceptions
__main__
ntpath
nt
sys
__builtin__
site
signal
UserDict
stat</span></pre><div class=calloutlist>
<ol>
<li>The <code>sys</code> module contains system-level information, such as the version of Python you're running (<code><code>sys</code>.version</code> or <code><code>sys</code>.version_info</code>), and system-level options such as the maximum allowed recursion depth (<code><code>sys</code>.getrecursionlimit()</code> and <code><code>sys</code>.setrecursionlimit()</code>).
<li><code><code>sys</code>.modules</code> is a dictionary containing all the modules that have ever been imported since Python was started; the key is the module name, the value is the module object. Note that this is more than just the modules <em>your</em> program has imported. Python preloads some modules on startup, and if you're using a Python <abbr>IDE</abbr>, <code><code>sys</code>.modules</code> contains all the modules imported by all the programs you've run within the <abbr>IDE</abbr>.
<p>This example demonstrates how to use <code><code>sys</code>.modules</code>.
<div class=example><h3>Example 6.13. Using <code><code>sys</code>.modules</code></h3><pre class=screen><samp class=prompt>>>> </samp><kbd>import fileinfo</kbd>         <span>&#x2460;</span>
<samp class=prompt>>>> </samp><kbd>print '\n'.join(sys.modules.keys())</kbd>
<samp>win32api
os.path
os
fileinfo
exceptions
__main__
ntpath
nt
sys
__builtin__
site
signal
UserDict
stat</samp>
<samp class=prompt>>>> </samp><kbd>fileinfo</kbd>
&lt;module 'fileinfo' from 'fileinfo.pyc'>
<samp class=prompt>>>> </samp><kbd>sys.modules["fileinfo"]</kbd> <span>&#x2461;</span>
&lt;module 'fileinfo' from 'fileinfo.pyc'></pre><div class=calloutlist>
<ol>
<li>As new modules are imported, they are added to <code><code>sys</code>.modules</code>. This explains why importing the same module twice is very fast: Python has already loaded and cached the module in <code><code>sys</code>.modules</code>, so importing the second time is simply a dictionary lookup.
<li>Given the name (as a string) of any previously-imported module, you can get a reference to the module itself through the <code><code>sys</code>.modules</code> dictionary.
<p>The next example shows how to use the <code>__module__</code> class attribute with the <code><code>sys</code>.modules</code> dictionary to get a reference to the module in which a class is defined.
<div class=example><h3>Example 6.14. The <code>__module__</code> Class Attribute</h3><pre class=screen><samp class=prompt>>>> </samp><kbd>from fileinfo import MP3FileInfo</kbd>
<samp class=prompt>>>> </samp><kbd>MP3FileInfo.__module__</kbd>              <span>&#x2460;</span>
'fileinfo'
<samp class=prompt>>>> </samp><kbd>sys.modules[MP3FileInfo.__module__]</kbd> <span>&#x2461;</span>
&lt;module 'fileinfo' from 'fileinfo.pyc'></pre><div class=calloutlist>
<ol>
<li>Every Python class has a built-in <a href="#fileinfo.classattributes" title="5.8. Introducing Class Attributes">class attribute</a> <code>__module__</code>, which is the name of the module in which the class is defined.
<li>Combining this with the <code><code>sys</code>.modules</code> dictionary, you can get a reference to the module in which a class is defined.
<p>Now you're ready to see how <code><code>sys</code>.modules</code> is used in <code>fileinfo.py</code>, the sample program introduced in <a href="#fileinfo">Chapter 5</a>. This example shows that portion of the code.
<div class=example><h3>Example 6.15. <code><code>sys</code>.modules</code> in <code>fileinfo.py</code></h3><pre><code>
    def getFileInfoClass(filename, module=sys.modules[FileInfo.__module__]):       <span>&#x2460;</span>
        "get file info class from filename extension"           
        subclass = "%sFileInfo" % os.path.splitext(filename)[1].upper()[1:]        <span>&#x2461;</span>
        return hasattr(module, subclass) and getattr(module, subclass) or FileInfo <span>&#x2462;</span></pre><div class=calloutlist>
<ol>
<li>This is a function with two arguments; <var>filename</var> is required, but <var>module</var> is <a href="#apihelper.optional" title="4.2. Using Optional and Named Arguments">optional</a> and defaults to the module that contains the <code>FileInfo</code> class. This looks inefficient, because you might expect Python to evaluate the <code><code>sys</code>.modules</code> expression every time the function is called. In fact, Python evaluates default expressions only once, the first time the module is imported. As you'll see later, you never call this
            function with a <var>module</var> argument, so <var>module</var> serves as a function-level constant.
<li>You'll plow through this line later, after you dive into the <code>os</code> module. For now, take it on faith that <var>subclass</var> ends up as the name of a class, like <code>MP3FileInfo</code>.
<li>You already know about <a href="#apihelper.getattr" title="4.4. Getting Object References With getattr"><code>getattr</code></a>, which gets a reference to an object by name. <code>hasattr</code> is a complementary function that checks whether an object has a particular attribute; in this case, whether a module has
            a particular class (although it works for any object and any attribute, just like <code>getattr</code>). In English, this line of code says, &#8220;If this module has the class named by <var>subclass</var> then return it, otherwise return the base class <code>FileInfo</code>.&#8221;
<div class=itemizedlist>
<h3>Further Reading on Modules</h3>
<ul>
<li><a href="http://www.python.org/doc/current/tut/tut.html"><i class=citetitle>Python Tutorial</i></a> discusses exactly <a href="http://www.python.org/doc/current/tut/node6.html#SECTION006710000000000000000">when and how default arguments are evaluated</a>.

<li><a href="http://www.python.org/doc/current/lib/"><i class=citetitle>Python Library Reference</i></a> documents the <a href="http://www.python.org/doc/current/lib/module-sys.html"><code>sys</code></a> module.

</ul>
<h2 id="fileinfo.os">6.5. Working with Directories</h2>
<p>The <code>os.path</code> module has several functions for manipulating files and directories. Here, we're looking at handling pathnames and listing
   the contents of a directory.
<div class=example><h3 id="fileinfo.os.path.join.example">Example 6.16. Constructing Pathnames</h3><pre class=screen>
<samp class=prompt>>>> </samp><kbd>import os</kbd>
<samp class=prompt>>>> </samp><kbd>os.path.join("c:\\music\\ap\\", "mahadeva.mp3")</kbd> <span>&#x2460;</span> <span>&#x2461;</span>
'c:\\music\\ap\\mahadeva.mp3'
<samp class=prompt>>>> </samp><kbd>os.path.join("c:\\music\\ap", "mahadeva.mp3")</kbd>   <span>&#x2462;</span>
'c:\\music\\ap\\mahadeva.mp3'
<samp class=prompt>>>> </samp><kbd>os.path.expanduser("~")</kbd>       <span>&#x2463;</span>
'c:\\Documents and Settings\\mpilgrim\\My Documents'
<samp class=prompt>>>> </samp><kbd>os.path.join(os.path.expanduser("~"), "Python")</kbd> <span>&#x2464;</span>
'c:\\Documents and Settings\\mpilgrim\\My Documents\\Python'</pre><div class=calloutlist>
<ol>
<li><code>os.path</code> is a reference to a module -- which module depends on your platform. Just as <a href="#crossplatform.example" title="Example 6.2. Supporting Platform-Specific Functionality"><code>getpass</code></a> encapsulates differences between platforms by setting <var>getpass</var> to a platform-specific function, <code>os</code> encapsulates differences between platforms by setting <var>path</var> to a platform-specific module.
<li>The <code>join</code> function of <code>os.path</code> constructs a pathname out of one or more partial pathnames. In this case, it simply concatenates strings. (Note that dealing
            with pathnames on Windows is annoying because the backslash character must be escaped.)
<li>In this slightly less trivial case, <code>join</code> will add an extra backslash to the pathname before joining it to the filename. I was overjoyed when I discovered this, since
<code>addSlashIfNecessary</code> is one of the stupid little functions I always need to write when building up my toolbox in a new language. <em>Do not</em> write this stupid little function in Python; smart people have already taken care of it for you.
<li><code>expanduser</code> will expand a pathname that uses <code>~</code> to represent the current user's home directory. This works on any platform where users have a home directory, like Windows,
<abbr>UNIX</abbr>, and Mac OS X; it has no effect on Mac OS.
<li>Combining these techniques, you can easily construct pathnames for directories and files under the user's home directory.
<div class=example><h3 id="splittingpathnames.example">Example 6.17. Splitting Pathnames</h3><pre class=screen><samp class=prompt>>>> </samp><kbd>os.path.split("c:\\music\\ap\\mahadeva.mp3")</kbd>      <span>&#x2460;</span>
('c:\\music\\ap', 'mahadeva.mp3')
<samp class=prompt>>>> </samp><kbd>(filepath, filename) = os.path.split("c:\\music\\ap\\mahadeva.mp3")</kbd> <span>&#x2461;</span>
<samp class=prompt>>>> </samp><kbd>filepath</kbd>      <span>&#x2462;</span>
'c:\\music\\ap'
<samp class=prompt>>>> </samp><kbd>filename</kbd>      <span>&#x2463;</span>
'mahadeva.mp3'
<samp class=prompt>>>> </samp><kbd>(shortname, extension) = os.path.splitext(filename)</kbd>                 <span>&#x2464;</span>
<samp class=prompt>>>> </samp><kbd>shortname</kbd>
'mahadeva'
<samp class=prompt>>>> </samp><kbd>extension</kbd>
'.mp3'</pre><div class=calloutlist>
<ol>
<li>The <code>split</code> function splits a full pathname and returns a tuple containing the path and filename. Remember when I said you could use
<a href="#odbchelper.multiassign" title="3.4.2. Assigning Multiple Values at Once">multi-variable assignment</a> to return multiple values from a function?  Well, <code>split</code> is such a function.
<li>You assign the return value of the <code>split</code> function into a tuple of two variables. Each variable receives the value of the corresponding element of the returned tuple.
<li>The first variable, <var>filepath</var>, receives the value of the first element of the tuple returned from <code>split</code>, the file path.
<li>The second variable, <var>filename</var>, receives the value of the second element of the tuple returned from <code>split</code>, the filename.
<li><code>os.path</code> also contains a function <code>splitext</code>, which splits a filename and returns a tuple containing the filename and the file extension.  You use the same technique
            to assign each of them to separate variables.
<div class=example><h3 id="fileinfo.listdir.example">Example 6.18. Listing Directories</h3><pre class=screen><samp class=prompt>>>> </samp><kbd>os.listdir("c:\\music\\_singles\\")</kbd>              <span>&#x2460;</span>
<samp>['a_time_long_forgotten_con.mp3', 'hellraiser.mp3',
'kairo.mp3', 'long_way_home1.mp3', 'sidewinder.mp3', 
'spinning.mp3']</samp>
<samp class=prompt>>>> </samp><kbd>dirname = "c:\\"</kbd>
<samp class=prompt>>>> </samp><kbd>os.listdir(dirname)</kbd>            <span>&#x2461;</span>
<samp>['AUTOEXEC.BAT', 'boot.ini', 'CONFIG.SYS', 'cygwin',
'docbook', 'Documents and Settings', 'Incoming', 'Inetpub', 'IO.SYS',
'MSDOS.SYS', 'Music', 'NTDETECT.COM', 'ntldr', 'pagefile.sys',
'Program Files', 'Python20', 'RECYCLER',
'System Volume Information', 'TEMP', 'WINNT']</samp>
<samp class=prompt>>>> </samp><kbd>[f for f in os.listdir(dirname)</kbd>
<samp class=prompt>...    </samp>if os.path.isfile(os.path.join(dirname, f))] <span>&#x2462;</span>
<samp>['AUTOEXEC.BAT', 'boot.ini', 'CONFIG.SYS', 'IO.SYS', 'MSDOS.SYS',
'NTDETECT.COM', 'ntldr', 'pagefile.sys']</samp>
<samp class=prompt>>>> </samp><kbd>[f for f in os.listdir(dirname)</kbd>
<samp class=prompt>...    </samp>if os.path.isdir(os.path.join(dirname, f))]  <span>&#x2463;</span>
<samp>['cygwin', 'docbook', 'Documents and Settings', 'Incoming',
'Inetpub', 'Music', 'Program Files', 'Python20', 'RECYCLER',
'System Volume Information', 'TEMP', 'WINNT']</span></pre><div class=calloutlist>
<ol>
<li>The <code>listdir</code> function takes a pathname and returns a list of the contents of the directory.
<li><code>listdir</code> returns both files and folders, with no indication of which is which.
<li>You can use <a href="#apihelper.filter" title="4.5. Filtering Lists">list filtering</a> and the <code>isfile</code> function of the <code>os.path</code> module to separate the files from the folders. <code>isfile</code> takes a pathname and returns 1 if the path represents a file, and 0 otherwise. Here you're using <code><code>os.path</code>.<code>join</code></code> to ensure a full pathname, but <code>isfile</code> also works with a partial path, relative to the current working directory. You can use <code>os.getcwd()</code> to get the current working directory.
<li><code>os.path</code> also has a <code>isdir</code> function which returns 1 if the path represents a directory, and 0 otherwise. You can use this to get a list of the subdirectories
            within a directory.
<div class=example><h3>Example 6.19. Listing Directories in <code>fileinfo.py</code></h3><pre><code>
def listDirectory(directory, fileExtList):    
    "get list of file info objects for files of particular extensions" 
    fileList = [os.path.normcase(f)
                for f in os.listdir(directory)]            <span>&#x2460;</span> <span>&#x2461;</span>
    fileList = [os.path.join(directory, f) 
               for f in fileList
                if os.path.splitext(f)[1] in fileExtList]  <span>&#x2462;</span> <span>&#x2463;</span> <span>&#x2464;</span></pre><div class=calloutlist>
<ol>
<li><code>os.listdir(directory)</code> returns a list of all the files and folders in <var>directory</var>.
<li>Iterating through the list with <var>f</var>, you use <code>os.path.normcase(f)</code> to normalize the case according to operating system defaults. <code>normcase</code> is a useful little function that compensates for case-insensitive operating systems that think that <code>mahadeva.mp3</code> and <code>mahadeva.MP3</code> are the same file. For instance, on Windows and Mac OS, <code>normcase</code> will convert the entire filename to lowercase; on <abbr>UNIX</abbr>-compatible systems, it will return the filename unchanged.
<li>Iterating through the normalized list with <var>f</var> again, you use <code>os.path.splitext(f)</code> to split each filename into name and extension.
<li>For each file, you see if the extension is in the list of file extensions you care about (<var>fileExtList</var>, which was passed to the <code>listDirectory</code> function).
<li>For each file you care about, you use <code>os.path.join(directory, f)</code> to construct the full pathname of the file, and return a list of the full pathnames.
<table id="tip.os" class=note border="0" summary="">

<td rowspan="2" align="center" valign="top" width="1%"><img src="images/note.png" alt="Note" title="" width="24" height="24"><td colspan="2" align="left" valign="top" width="99%">Whenever possible, you should use the functions in <code>os</code> and <code>os.path</code> for file, directory, and path manipulations. These modules are wrappers for platform-specific modules, so functions like
<code>os.path.split</code> work on <abbr>UNIX</abbr>, Windows, Mac OS, and any other platform supported by Python.
<p>There is one other way to get the contents of a directory. It's very powerful, and it uses the sort of wildcards that you
may already be familiar with from working on the command line.
<div class=example><h3 id="fileinfo.os.glob.example">Example 6.20. Listing Directories with <code>glob</code></h3><pre class=screen>
<samp class=prompt>>>> </samp><kbd>os.listdir("c:\\music\\_singles\\")</kbd>               <span>&#x2460;</span>
<samp>['a_time_long_forgotten_con.mp3', 'hellraiser.mp3',
'kairo.mp3', 'long_way_home1.mp3', 'sidewinder.mp3',
'spinning.mp3']</samp>
<samp class=prompt>>>> </samp><kbd>import glob</kbd>
<samp class=prompt>>>> </samp><kbd>glob.glob('c:\\music\\_singles\\*.mp3')</kbd>           <span>&#x2461;</span>
<samp>['c:\\music\\_singles\\a_time_long_forgotten_con.mp3',
'c:\\music\\_singles\\hellraiser.mp3',
'c:\\music\\_singles\\kairo.mp3',
'c:\\music\\_singles\\long_way_home1.mp3',
'c:\\music\\_singles\\sidewinder.mp3',
'c:\\music\\_singles\\spinning.mp3']</samp>
<samp class=prompt>>>> </samp><kbd>glob.glob('c:\\music\\_singles\\s*.mp3')</kbd>          <span>&#x2462;</span>
<samp>['c:\\music\\_singles\\sidewinder.mp3',
'c:\\music\\_singles\\spinning.mp3']</samp>
<samp class=prompt>>>> </samp><kbd>glob.glob('c:\\music\\*\\*.mp3')</kbd><span>&#x2463;</span>
</pre><div class=calloutlist>
<ol>
<li>As you saw earlier, <code>os.listdir</code> simply takes a directory path and lists all files and directories in that directory.
<li>The <code>glob</code> module, on the other hand, takes a wildcard and returns the full path of all files and directories matching the wildcard.
             Here the wildcard is a directory path plus "*.mp3", which will match all <code>.mp3</code> files. Note that each element of the returned list already includes the full path of the file.
<li>If you want to find all the files in a specific directory that start with "s" and end with ".mp3", you can do that too.
<li>Now consider this scenario: you have a <code>music</code> directory, with several subdirectories within it, with <code>.mp3</code> files within each subdirectory. You can get a list of all of those with a single call to <code>glob</code>, by using two wildcards at once. One wildcard is the <code>"*.mp3"</code> (to match <code>.mp3</code> files), and one wildcard is <em>within the directory path itself</em>, to match any subdirectory within <code>c:\music</code>. That's a crazy amount of power packed into one deceptively simple-looking function!
<div class=itemizedlist>
<h3>Further Reading on the <code>os</code> Module</h3>
<ul>
<li><a href="http://www.faqts.com/knowledge-base/index.phtml/fid/199/">Python Knowledge Base</a> answers <a href="http://www.faqts.com/knowledge-base/index.phtml/fid/240">questions about the <code>os</code> module</a>.

<li><a href="http://www.python.org/doc/current/lib/"><i class=citetitle>Python Library Reference</i></a> documents the <a href="http://www.python.org/doc/current/lib/module-os.html"><code>os</code></a> module and the <a href="http://www.python.org/doc/current/lib/module-os.path.html"><code>os.path</code></a> module.

</ul>
<h2 id="fileinfo.alltogether">6.6. Putting It All Together</h2>
<p>Once again, all the dominoes are in place. You've seen how each line of code works. Now let's step back and see how it all
   fits together.
<div class=example><h3 id="fileinfo.nested">Example 6.21. <code>listDirectory</code></h3><pre><code>
def listDirectory(directory, fileExtList):     <span>&#x2460;</span>
    "get list of file info objects for files of particular extensions"
    fileList = [os.path.normcase(f)
                for f in os.listdir(directory)]           
    fileList = [os.path.join(directory, f) 
               for f in fileList
                if os.path.splitext(f)[1] in fileExtList]        <span>&#x2461;</span>
    def getFileInfoClass(filename, module=sys.modules[FileInfo.__module__]):       <span>&#x2462;</span>
        "get file info class from filename extension"           
        subclass = "%sFileInfo" % os.path.splitext(filename)[1].upper()[1:]        <span>&#x2463;</span>
        return hasattr(module, subclass) and getattr(module, subclass) or FileInfo <span>&#x2464;</span>
    return [getFileInfoClass(f)(f) for f in fileList]            <span>&#x2465;</span></pre><div class=calloutlist>
<ol>
<li><code>listDirectory</code> is the main attraction of this entire module. It takes a directory (like <code>c:\music\_singles\</code> in my case) and a list of interesting file extensions (like <code>['.mp3']</code>), and it returns a list of class instances that act like dictionaries that contain metadata about each interesting file in
            that directory. And it does it in just a few straightforward lines of code.
<li>As you saw in the <a href="#fileinfo.os" title="6.5. Working with Directories">previous section</a>, this line of code gets a list of the full pathnames of all the files in <var>directory</var> that have an interesting file extension (as specified by <var>fileExtList</var>).
<li>Old-school Pascal programmers may be familiar with them, but most people give me a blank stare when I tell them that Python supports <em>nested functions</em> -- literally, a function within a function. The nested function <code>getFileInfoClass</code> can be called only from the function in which it is defined, <code>listDirectory</code>. As with any other function, you don't need an interface declaration or anything fancy; just define the function and code
            it.
<li>Now that you've seen the <a href="#fileinfo.os" title="6.5. Working with Directories"><code>os</code></a> module, this line should make more sense. It gets the extension of the file (<code>os.path.splitext(filename)[1]</code>), forces it to uppercase (<code>.upper()</code>), slices off the dot (<code>[1:]</code>), and constructs a class name out of it with string formatting. So <code>c:\music\ap\mahadeva.mp3</code> becomes <code>.mp3</code> becomes <code>.MP3</code> becomes <code>MP3</code> becomes <code>MP3FileInfo</code>.
<li>Having constructed the name of the handler class that would handle this file, you check to see if that handler class actually
            exists in this module. If it does, you return the class, otherwise you return the base class <code>FileInfo</code>. This is a very important point: <em>this function returns a class</em>. Not an instance of a class, but the class itself.
<li>For each file in the &#8220;interesting files&#8221; list (<var>fileList</var>), you call <code>getFileInfoClass</code> with the filename (<var>f</var>). Calling <code>getFileInfoClass(f)</code> returns a class; you don't know exactly which class, but you don't care. You then create an instance of this class (whatever
            it is) and pass the filename (<var>f</var> again), to the <code>__init__</code> method. As you saw <a href="#fileinfo.specialmethods.setname" title="Example 5.15. Setting an MP3FileInfo's name">earlier in this chapter</a>, the <code>__init__</code> method of <code>FileInfo</code> sets <code>self["name"]</code>, which triggers <code>__setitem__</code>, which is overridden in the descendant (<code>MP3FileInfo</code>) to parse the file appropriately to pull out the file's metadata. You do all that for each interesting file and return a
            list of the resulting instances.
<p>Note that <code>listDirectory</code> is completely generic. It doesn't know ahead of time which types of files it will be getting, or which classes are defined
that could potentially handle those files. It inspects the directory for the files to process, and then introspects its own
module to see what special handler classes (like <code>MP3FileInfo</code>) are defined. You can extend this program to handle other types of files simply by defining an appropriately-named class:
<code>HTMLFileInfo</code> for <abbr>HTML</abbr> files, <code>DOCFileInfo</code> for Word <code>.doc</code> files, and so forth. <code>listDirectory</code> will handle them all, without modification, by handing off the real work to the appropriate classes and collating the results.
<h2 id="fileinfo.summary2">6.7. Summary</h2>
<p>The <code>fileinfo.py</code> program introduced in <a href="#fileinfo">Chapter 5</a> should now make perfect sense.
<pre><code>
"""Framework for getting filetype-specific metadata.

Instantiate appropriate class with filename. Returned object acts like a
dictionary, with key-value pairs for each piece of metadata.
    import fileinfo
    info = fileinfo.MP3FileInfo("/music/ap/mahadeva.mp3")
    print "\\n".join(["%s=%s" % (k, v) for k, v in info.items()])

Or use listDirectory function to get info on all files in a directory.
    for info in fileinfo.listDirectory("/music/ap/", [".mp3"]):
        ...

Framework can be extended by adding classes for particular file types, e.g.
HTMLFileInfo, MPGFileInfo, DOCFileInfo. Each class is completely responsible for
parsing its files appropriately; see MP3FileInfo for example.
"""
import os
import sys
from UserDict import UserDict

def stripnulls(data):
    "strip whitespace and nulls"
    return data.replace("\00", "").strip()

class FileInfo(UserDict):
    "store file metadata"
    def __init__(self, filename=None):
        UserDict.__init__(self)
        self["name"] = filename

class MP3FileInfo(FileInfo):
    "store ID3v1.0 MP3 tags"
    tagDataMap = {"title"   : (  3,  33, stripnulls),
"artist"  : ( 33,  63, stripnulls),
"album"   : ( 63,  93, stripnulls),
"year"    : ( 93,  97, stripnulls),
"comment" : ( 97, 126, stripnulls),
"genre"   : (127, 128, ord)}

    def __parse(self, filename):
        "parse ID3v1.0 tags from MP3 file"
        self.clear()
        try:             
            fsock = open(filename, "rb", 0)
            try:         
                fsock.seek(-128, 2)        
                tagdata = fsock.read(128)  
            finally:     
                fsock.close()              
            if tagdata[:3] == "TAG":
                for tag, (start, end, parseFunc) in self.tagDataMap.items():
  self[tag] = parseFunc(tagdata[start:end])               
        except IOError:  
            pass         

    def __setitem__(self, key, item):
        if key == "name" and item:
            self.__parse(item)
        FileInfo.__setitem__(self, key, item)

def listDirectory(directory, fileExtList):    
    "get list of file info objects for files of particular extensions"
    fileList = [os.path.normcase(f)
                for f in os.listdir(directory)]           
    fileList = [os.path.join(directory, f) 
               for f in fileList
                if os.path.splitext(f)[1] in fileExtList] 
    def getFileInfoClass(filename, module=sys.modules[FileInfo.__module__]):      
        "get file info class from filename extension"           
        subclass = "%sFileInfo" % os.path.splitext(filename)[1].upper()[1:]       
        return hasattr(module, subclass) and getattr(module, subclass) or FileInfo
    return [getFileInfoClass(f)(f) for f in fileList]           

if __name__ == "__main__":
    for info in listDirectory("/music/_singles/", [".mp3"]):
        print "\n".join(["%s=%s" % (k, v) for k, v in info.items()])
        print</pre><div class=highlights>
<p>Before diving into the next chapter, make sure you're comfortable doing the following things:
<div class=itemizedlist>
<ul>
<li>Catching exceptions with <a href="#fileinfo.exception" title="6.1. Handling Exceptions"><code>try...except</code></a>
<li>Protecting external resources with <a href="#fileinfo.files.incode" title="Example 6.6. File Objects in MP3FileInfo"><code>try...finally</code></a>
<li>Reading from <a href="#fileinfo.files" title="6.2. Working with File Objects">files</a>
<li>Assigning multiple values at once in a <a href="#fileinfo.multiassign.for.example" title="Example 6.11. for Loop in MP3FileInfo"><code>for</code> loop</a>
<li>Using the <a href="#fileinfo.os" title="6.5. Working with Directories"><code>os</code></a> module for all your cross-platform file manipulation needs

<li>Dynamically <a href="#fileinfo.alltogether" title="6.6. Putting It All Together">instantiating classes of unknown type</a> by treating classes as objects and passing them around

</ul>
<div class=chapter>
<h2 id="dialect">Chapter 8. <abbr>HTML</abbr> Processing</h2>
<h2 id="dialect.divein">8.1. Diving in</h2>
<p>I often see questions on <a href="http://groups.google.com/groups?group=comp.lang.python">comp.lang.python</a> like &#8220;How can I list all the [headers|images|links] in my <abbr>HTML</abbr> document?&#8221;  &#8220;How do I parse/translate/munge the text of my <abbr>HTML</abbr> document but leave the tags alone?&#8221;  &#8220;How can I add/remove/quote attributes of all my <abbr>HTML</abbr> tags at once?&#8221;  This chapter will answer all of these questions.
<p>Here is a complete, working Python program in two parts. The first part, <code>BaseHTMLProcessor.py</code>, is a generic tool to help you process <abbr>HTML</abbr> files by walking through the tags and text blocks. The second part, <code>dialect.py</code>, is an example of how to use <code>BaseHTMLProcessor.py</code> to translate the text of an <abbr>HTML</abbr> document but leave the tags alone. Read the <code>docstring</code>s and comments to get an overview of what's going on. Most of it will seem like black magic, because it's not obvious how
any of these class methods ever get called. Don't worry, all will be revealed in due time.
<div class=example><h3 id="dialect.basehtml.listing">Example 8.1. <code>BaseHTMLProcessor.py</code></h3>
<p>If you have not already done so, you can <a href="http://diveintopython3.org/download/diveintopython3-examples-5.4.zip" title="Download example scripts">download this and other examples</a> used in this book.
<pre><code>
from sgmllib import SGMLParser
import htmlentitydefs

class BaseHTMLProcessor(SGMLParser):
    def reset(self):     
        # extend (called by SGMLParser.__init__)
        self.pieces = []
        SGMLParser.reset(self)

    def unknown_starttag(self, tag, attrs):
        # called for each start tag
        # attrs is a list of (attr, value) tuples
        # e.g. for &lt;pre class=screen>, tag="pre", attrs=[("class", "screen")]
        # Ideally we would like to reconstruct original tag and attributes, but
        # we may end up quoting attribute values that weren't quoted in the source
        # document, or we may change the type of quotes around the attribute value
        # (single to double quotes).
        # Note that improperly embedded non-HTML code (like client-side Javascript)
        # may be parsed incorrectly by the ancestor, causing runtime script errors.
        # All non-HTML code must be enclosed in HTML comment tags (&lt;!-- code -->)
        # to ensure that it will pass through this parser unaltered (in handle_comment).
        strattrs = "".join([' %s="%s"' % (key, value) for key, value in attrs])
        self.pieces.append("&lt;%(tag)s%(strattrs)s>" % locals())

    def unknown_endtag(self, tag):         
        # called for each end tag, e.g. for &lt;/pre>, tag will be "pre"
        # Reconstruct the original end tag.
        self.pieces.append("&lt;/%(tag)s>" % locals())

    def handle_charref(self, ref):         
        # called for each character reference, e.g. for "&amp;#160;", ref will be "160"
        # Reconstruct the original character reference.
        self.pieces.append("&amp;#%(ref)s;" % locals())

    def handle_entityref(self, ref):       
        # called for each entity reference, e.g. for "&amp;copy;", ref will be "copy"
        # Reconstruct the original entity reference.
        self.pieces.append("&amp;%(ref)s" % locals())
        # standard HTML entities are closed with a semicolon; other entities are not
        if htmlentitydefs.entitydefs.has_key(ref):
            self.pieces.append(";")

    def handle_data(self, text):           
        # called for each block of plain text, i.e. outside of any tag and
        # not containing any character or entity references
        # Store the original text verbatim.
        self.pieces.append(text)

    def handle_comment(self, text):        
        # called for each HTML comment, e.g. &lt;!-- insert Javascript code here -->
        # Reconstruct the original comment.
        # It is especially important that the source document enclose client-side
        # code (like Javascript) within comments so it can pass through this
        # processor undisturbed; see comments in unknown_starttag for details.
        self.pieces.append("&lt;!--%(text)s-->" % locals())

    def handle_pi(self, text):             
        # called for each processing instruction, e.g. &lt;?instruction>
        # Reconstruct original processing instruction.
        self.pieces.append("&lt;?%(text)s>" % locals())

    def handle_decl(self, text):
        # called for the DOCTYPE, if present, e.g.
        # &lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        #     "http://www.w3.org/TR/html4/loose.dtd">
        # Reconstruct original DOCTYPE
        self.pieces.append("&lt;!%(text)s>" % locals())

    def output(self):              
        """Return processed HTML as a single string"""
        return "".join(self.pieces)</pre><div class=example><h3>Example 8.2. <code>dialect.py</code></h3><pre><code>
import re
from BaseHTMLProcessor import BaseHTMLProcessor

class Dialectizer(BaseHTMLProcessor):
    subs = ()

    def reset(self):
        # extend (called from __init__ in ancestor)
        # Reset all data attributes
        self.verbatim = 0
        BaseHTMLProcessor.reset(self)

    def start_pre(self, attrs):            
        # called for every &lt;pre> tag in HTML source
        # Increment verbatim mode count, then handle tag like normal
        self.verbatim += 1                 
        self.unknown_starttag("pre", attrs)

    def end_pre(self):   
        # called for every &lt;/pre> tag in HTML source
        # Decrement verbatim mode count
        self.unknown_endtag("pre")         
        self.verbatim -= 1                 

    def handle_data(self, text):    
        # override
        # called for every block of text in HTML source
        # If in verbatim mode, save text unaltered;
        # otherwise process the text with a series of substitutions
        self.pieces.append(self.verbatim and text or self.process(text))

    def process(self, text):
        # called from handle_data
        # Process text block by performing series of regular expression
        # substitutions (actual substitions are defined in descendant)
        for fromPattern, toPattern in self.subs:
            text = re.sub(fromPattern, toPattern, text)
        return text

class ChefDialectizer(Dialectizer):
    """convert HTML to Swedish Chef-speak
    
    based on the classic chef.x, copyright (c) 1992, 1993 John Hagerman
    """
    subs = ((r'a([nu])', r'u\1'),
            (r'A([nu])', r'U\1'),
            (r'a\B', r'e'),
            (r'A\B', r'E'),
            (r'en\b', r'ee'),
            (r'\Bew', r'oo'),
            (r'\Be\b', r'e-a'),
            (r'\be', r'i'),
            (r'\bE', r'I'),
            (r'\Bf', r'ff'),
            (r'\Bir', r'ur'),
            (r'(\w*?)i(\w*?)$', r'\1ee\2'),
            (r'\bow', r'oo'),
            (r'\bo', r'oo'),
            (r'\bO', r'Oo'),
            (r'the', r'zee'),
            (r'The', r'Zee'),
            (r'th\b', r't'),
            (r'\Btion', r'shun'),
            (r'\Bu', r'oo'),
            (r'\BU', r'Oo'),
            (r'v', r'f'),
            (r'V', r'F'),
            (r'w', r'w'),
            (r'W', r'W'),
            (r'([a-z])[.]', r'\1. Bork Bork Bork!'))

class FuddDialectizer(Dialectizer):
    """convert HTML to Elmer Fudd-speak"""
    subs = ((r'[rl]', r'w'),
            (r'qu', r'qw'),
            (r'th\b', r'f'),
            (r'th', r'd'),
            (r'n[.]', r'n, uh-hah-hah-hah.'))

class OldeDialectizer(Dialectizer):
    """convert HTML to mock Middle English"""
    subs = ((r'i([bcdfghjklmnpqrstvwxyz])e\b', r'y\1'),
            (r'i([bcdfghjklmnpqrstvwxyz])e', r'y\1\1e'),
            (r'ick\b', r'yk'),
            (r'ia([bcdfghjklmnpqrstvwxyz])', r'e\1e'),
            (r'e[ea]([bcdfghjklmnpqrstvwxyz])', r'e\1e'),
            (r'([bcdfghjklmnpqrstvwxyz])y', r'\1ee'),
            (r'([bcdfghjklmnpqrstvwxyz])er', r'\1re'),
            (r'([aeiou])re\b', r'\1r'),
            (r'ia([bcdfghjklmnpqrstvwxyz])', r'i\1e'),
            (r'tion\b', r'cioun'),
            (r'ion\b', r'ioun'),
            (r'aid', r'ayde'),
            (r'ai', r'ey'),
            (r'ay\b', r'y'),
            (r'ay', r'ey'),
            (r'ant', r'aunt'),
            (r'ea', r'ee'),
            (r'oa', r'oo'),
            (r'ue', r'e'),
            (r'oe', r'o'),
            (r'ou', r'ow'),
            (r'ow', r'ou'),
            (r'\bhe', r'hi'),
            (r've\b', r'veth'),
            (r'se\b', r'e'),
            (r"'s\b", r'es'),
            (r'ic\b', r'ick'),
            (r'ics\b', r'icc'),
            (r'ical\b', r'ick'),
            (r'tle\b', r'til'),
            (r'll\b', r'l'),
            (r'ould\b', r'olde'),
            (r'own\b', r'oune'),
            (r'un\b', r'onne'),
            (r'rry\b', r'rye'),
            (r'est\b', r'este'),
            (r'pt\b', r'pte'),
            (r'th\b', r'the'),
            (r'ch\b', r'che'),
            (r'ss\b', r'sse'),
            (r'([wybdp])\b', r'\1e'),
            (r'([rnt])\b', r'\1\1e'),
            (r'from', r'fro'),
            (r'when', r'whan'))

def translate(url, dialectName="chef"):
    """fetch URL and translate using dialect
    
    dialect in ("chef", "fudd", "olde")"""
    import urllib    
    sock = urllib.urlopen(url)         
    htmlSource = sock.read()           
    sock.close()     
    parserName = "%sDialectizer" % dialectName.capitalize()
    parserClass = globals()[parserName]  
    parser = parserClass()               
    parser.feed(htmlSource)
    parser.close()         
    return parser.output() 

def test(url):
    """test all dialects against URL"""
    for dialect in ("chef", "fudd", "olde"):
        outfile = "%s.html" % dialect
        fsock = open(outfile, "wb")
        fsock.write(translate(url, dialect))
        fsock.close()
        import webbrowser
        webbrowser.open_new(outfile)

if __name__ == "__main__":
    test("http://diveintopython3.org/odbchelper_list.html")</pre><div class=example><h3>Example 8.3. Output of <code>dialect.py</code></h3>
<p>Running this script will translate <a href="#odbchelper.list" title="3.2. Introducing Lists">Section 3.2, &#8220;Introducing Lists&#8221;</a> into <a href="../native_data_types/chef.html">mock Swedish Chef-speak</a> (from The Muppets), <a href="../native_data_types/fudd.html">mock Elmer Fudd-speak</a> (from Bugs Bunny cartoons), and <a href="../native_data_types/olde.html">mock Middle English</a> (loosely based on Chaucer's <i class=citetitle>The Canterbury Tales</i>). If you look at the <abbr>HTML</abbr> source of the output pages, you'll see that all the <abbr>HTML</abbr> tags and attributes are untouched, but the text between the tags has been &#8220;translated&#8221; into the mock language. If you look closer, you'll see that, in fact, only the titles and paragraphs were translated; the
   code listings and screen examples were left untouched.
<pre><code>
&lt;div class=abstract>
&lt;p>Lists awe &lt;span class=application>Pydon&lt;/span>'s wowkhowse datatype.
If youw onwy expewience wif wists is awways in
&lt;span class=application>Visuaw Basic&lt;/span> ow (God fowbid) de datastowe
in &lt;span class=application>Powewbuiwdew&lt;/span>, bwace youwsewf fow
&lt;span class=application>Pydon&lt;/span> wists.&lt;/p>
&lt;/div>
</pre><h2 id="dialect.sgmllib">8.2. Introducing <code>sgmllib.py</code></h2>
<p><abbr>HTML</abbr> processing is broken into three steps: breaking down the <abbr>HTML</abbr> into its constituent pieces, fiddling with the pieces, and reconstructing the pieces into <abbr>HTML</abbr> again. The first step is done by <code>sgmllib.py</code>, a part of the standard Python library.
<p>The key to understanding this chapter is to realize that <abbr>HTML</abbr> is not just text, it is structured text. The structure is derived from the more-or-less-hierarchical sequence of start tags
and end tags. Usually you don't work with <abbr>HTML</abbr> this way; you work with it <em>textually</em> in a text editor, or <em>visually</em> in a web browser or web authoring tool. <code>sgmllib.py</code> presents <abbr>HTML</abbr> <em>structurally</em>.
<p><code>sgmllib.py</code> contains one important class: <code>SGMLParser</code>. <code>SGMLParser</code> parses <abbr>HTML</abbr> into useful pieces, like start tags and end tags. As soon as it succeeds in breaking down some data into a useful piece,
it calls a method on itself based on what it found. In order to use the parser, you subclass the <code>SGMLParser</code> class and override these methods. This is what I meant when I said that it presents <abbr>HTML</abbr> <em>structurally</em>: the structure of the <abbr>HTML</abbr> determines the sequence of method calls and the arguments passed to each method.
<p><code>SGMLParser</code> parses <abbr>HTML</abbr> into 8 kinds of data, and calls a separate method for each of them:
<div class=variablelist>
<dl>
<dt>Start tag</dt>
<dd>An <abbr>HTML</abbr> tag that starts a block, like <code>&lt;html></code>, <code>&lt;head></code>, <code>&lt;body></code>, or <code>&lt;pre></code>, or a standalone tag like <code>&lt;br></code> or <code>&lt;img></code>. When it finds a start tag <var><code>tagname</code></var>, <code>SGMLParser</code> will look for a method called <code>start_<var><code>tagname</code></var></code> or <code>do_<var><code>tagname</code></var></code>. For instance, when it finds a <code>&lt;pre></code> tag, it will look for a <code>start_pre</code> or <code>do_pre</code> method. If found, <code>SGMLParser</code> calls this method with a list of the tag's attributes; otherwise, it calls <code>unknown_starttag</code> with the tag name and list of attributes.
</dd>
<dt>End tag</dt>
<dd>An <abbr>HTML</abbr> tag that ends a block, like <code>&lt;/html></code>, <code>&lt;/head></code>, <code>&lt;/body></code>, or <code>&lt;/pre></code>. When it finds an end tag, <code>SGMLParser</code> will look for a method called <code>end_<var><code>tagname</code></var></code>. If found, <code>SGMLParser</code> calls this method, otherwise it calls <code>unknown_endtag</code> with the tag name.
</dd>
<dt>Character reference</dt>
<dd>An escaped character referenced by its decimal or hexadecimal equivalent, like <code>&amp;#160;</code>. When found, <code>SGMLParser</code> calls <code>handle_charref</code> with the text of the decimal or hexadecimal character equivalent.
</dd>
<dt>Entity reference</dt>
<dd>An <abbr>HTML</abbr> entity, like <code>&amp;copy;</code>. When found, <code>SGMLParser</code> calls <code>handle_entityref</code> with the name of the <abbr>HTML</abbr> entity.
</dd>
<dt>Comment</dt>
<dd>An <abbr>HTML</abbr> comment, enclosed in <code>&lt;!-- ... --></code>. When found, <code>SGMLParser</code> calls <code>handle_comment</code> with the body of the comment.
</dd>
<dt>Processing instruction</dt>
<dd>An <abbr>HTML</abbr> processing instruction, enclosed in <code>&lt;? ... ></code>. When found, <code>SGMLParser</code> calls <code>handle_pi</code> with the body of the processing instruction.
</dd>
<dt>Declaration</dt>
<dd>An <abbr>HTML</abbr> declaration, such as a <code>DOCTYPE</code>, enclosed in <code>&lt;! ... ></code>. When found, <code>SGMLParser</code> calls <code>handle_decl</code> with the body of the declaration.
</dd>
<dt>Text data</dt>
<dd>A block of text. Anything that doesn't fit into the other 7 categories. When found, <code>SGMLParser</code> calls <code>handle_data</code> with the text.
</dd>
</dl>
<table class=important border="0" summary="">

<td rowspan="2" align="center" valign="top" width="1%"><img src="images/important.png" alt="Important" title="" width="24" height="24"><td colspan="2" align="left" valign="top" width="99%">Python 2.0 had a bug where <code>SGMLParser</code> would not recognize declarations at all (<code>handle_decl</code> would never be called), which meant that <code>DOCTYPE</code>s were silently ignored. This is fixed in Python 2.1.
<p><code>sgmllib.py</code> comes with a test suite to illustrate this. You can run <code>sgmllib.py</code>, passing the name of an <abbr>HTML</abbr> file on the command line, and it will print out the tags and other elements as it parses them. It does this by subclassing
the <code>SGMLParser</code> class and defining <code>unknown_starttag</code>, <code>unknown_endtag</code>, <code>handle_data</code> and other methods which simply print their arguments.
<table id="tip.commandline.windows" class=tip border="0" summary="">

<td rowspan="2" align="center" valign="top" width="1%"><img src="images/tip.png" alt="Tip" title="" width="24" height="24"><td colspan="2" align="left" valign="top" width="99%">In the ActivePython <abbr>IDE</abbr> on Windows, you can specify command line arguments in the &#8220;Run script&#8221; dialog. Separate multiple arguments with spaces.
<div class=example><h3>Example 8.4. Sample test of <code>sgmllib.py</code></h3>
<p>Here is a snippet from the table of contents of the <abbr>HTML</abbr> version of this book. Of course your paths may vary. (If you haven't downloaded the <abbr>HTML</abbr> version of the book, you can do so at <a href="http://diveintopython3.org/">http://diveintopython3.org/</a>.
<pre class=screen>
<samp class=prompt>c:\python23\lib></samp> type "c:\downloads\diveintopython3\html\toc\index.html"
<code>
&lt;!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
&lt;html>
   &lt;head>
      &lt;meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   
      &lt;title>Dive Into Python&lt;/title>
      &lt;link rel="stylesheet" href="diveintopython3.css" type="text/css">

... rest of file omitted for brevity ...
</code></pre><p>Running this through the test suite of <code>sgmllib.py</code> yields this output:<pre class=screen>
<samp class=prompt>c:\python23\lib></samp> python sgmllib.py "c:\downloads\diveintopython3\html\toc\index.html"
<samp>data: '\n\n'
start tag: &lt;html >
data: '\n   '
start tag: &lt;head>
data: '\n      '
start tag: &lt;meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
data: '\n   \n      '
start tag: &lt;title>
data: 'Dive Into Python'
end tag: &lt;/title>
data: '\n      '
start tag: &lt;link rel="stylesheet" href="diveintopython3.css" type="text/css" >
data: '\n      '

... rest of output omitted for brevity ...
</span></pre><p>Here's the roadmap for the rest of the chapter:
<div class=itemizedlist>
<ul>
<li>Subclass <code>SGMLParser</code> to create classes that extract interesting data out of <abbr>HTML</abbr> documents.

<li>Subclass <code>SGMLParser</code> to create <code>BaseHTMLProcessor</code>, which overrides all 8 handler methods and uses them to reconstruct the original <abbr>HTML</abbr> from the pieces.

<li>Subclass <code>BaseHTMLProcessor</code> to create <code>Dialectizer</code>, which adds some methods to process specific <abbr>HTML</abbr> tags specially, and overrides the <code>handle_data</code> method to provide a framework for processing the text blocks between the <abbr>HTML</abbr> tags.

<li>Subclass <code>Dialectizer</code> to create classes that define text processing rules used by <code>Dialectizer.handle_data</code>.

<li>Write a test suite that grabs a real web page from <code>http://diveintopython3.org/</code> and processes it.

</ul>
<p>Along the way, you'll also learn about <code>locals</code>, <code>globals</code>, and dictionary-based string formatting.
<h2 id="dialect.extract">8.3. Extracting data from <abbr>HTML</abbr> documents</h2>
<p>To extract data from <abbr>HTML</abbr> documents, subclass the <code>SGMLParser</code> class and define methods for each tag or entity you want to capture.
<p>The first step to extracting data from an <abbr>HTML</abbr> document is getting some <abbr>HTML</abbr>. If you have some <abbr>HTML</abbr> lying around on your hard drive, you can use <a href="#fileinfo.files" title="6.2. Working with File Objects">file functions</a> to read it, but the real fun begins when you get <abbr>HTML</abbr> from live web pages.
<div class=example><h3 id="dialect.extract.urllib">Example 8.5. Introducing <code>urllib</code></h3><pre class=screen>
<samp class=prompt>>>> </samp><kbd>import urllib</kbd>   <span>&#x2460;</span>
<samp class=prompt>>>> </samp><kbd>sock = urllib.urlopen("http://diveintopython3.org/")</kbd> <span>&#x2461;</span>
<samp class=prompt>>>> </samp><kbd>htmlSource = sock.read()</kbd>          <span>&#x2462;</span>
<samp class=prompt>>>> </samp><kbd>sock.close()</kbd>    <span>&#x2463;</span>
<samp class=prompt>>>> </samp><kbd>print htmlSource</kbd><span>&#x2464;</span>
<samp>&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">&lt;html>&lt;head>
      &lt;meta http-equiv='Content-Type' content='text/html; charset=ISO-8859-1'>
   &lt;title>Dive Into Python&lt;/title>
&lt;link rel='stylesheet' href='diveintopython3.css' type='text/css'>
&lt;link rev='made' href='mailto:mark@diveintopython3.org'>
&lt;meta name='keywords' content='Python, Dive Into Python, tutorial, object-oriented, programming, documentation, book, free'>
&lt;meta name='description' content='a free Python tutorial for experienced programmers'>
&lt;/head>
&lt;body bgcolor='white' text='black' link='#0000FF' vlink='#840084' alink='#0000FF'>
&lt;table cellpadding='0' cellspacing='0' border='0' width='100%'>
&lt;tr>&lt;td class='header' width='1%' valign='top'>diveintopython3.org&lt;/td>
&lt;td width='99%' align='right'>&lt;hr size='1' noshade>&lt;/td>&lt;/tr>
&lt;tr>&lt;td class='tagline' colspan='2'>Python&amp;nbsp;for&amp;nbsp;experienced&amp;nbsp;programmers&lt;/td>&lt;/tr></span>

[...snip...]</pre><div class=calloutlist>
<ol>
<li>The <code>urllib</code> module is part of the standard Python library. It contains functions for getting information about and actually retrieving data from Internet-based <abbr>URL</abbr>s (mainly web pages).
<li>The simplest use of <code>urllib</code> is to retrieve the entire text of a web page using the <code>urlopen</code> function. Opening a <abbr>URL</abbr> is similar to <a href="#fileinfo.files" title="6.2. Working with File Objects">opening a file</a>. The return value of <code>urlopen</code> is a file-like object, which has some of the same methods as a file object.
<li>The simplest thing to do with the file-like object returned by <code>urlopen</code> is <code>read</code>, which reads the entire <abbr>HTML</abbr> of the web page into a single string. The object also supports <code>readlines</code>, which reads the text line by line into a list.
<li>When you're done with the object, make sure to <code>close</code> it, just like a normal file object.
<li>You now have the complete <abbr>HTML</abbr> of the home page of <code>http://diveintopython3.org/</code> in a string, and you're ready to parse it.
<div class=example><h3 id="dialect.extract.links">Example 8.6. Introducing <code>urllister.py</code></h3>
<p>If you have not already done so, you can <a href="http://diveintopython3.org/download/diveintopython3-examples-5.4.zip" title="Download example scripts">download this and other examples</a> used in this book.
<pre><code>
from sgmllib import SGMLParser

class URLLister(SGMLParser):
    def reset(self):            <span>&#x2460;</span>
        SGMLParser.reset(self)
        self.urls = []

    def start_a(self, attrs):   <span>&#x2461;</span>
        href = [v for k, v in attrs if k=='href'] <span>&#x2462;</span> <span>&#x2463;</span>
        if href:
            self.urls.extend(href)</pre><div class=calloutlist>
<ol>
<li><code>reset</code> is called by the <code>__init__</code> method of <code>SGMLParser</code>, and it can also be called manually once an instance of the parser has been created. So if you need to do any initialization,
            do it in <code>reset</code>, not in <code>__init__</code>, so that it will be re-initialized properly when someone re-uses a parser instance.
<li><code>start_a</code> is called by <code>SGMLParser</code> whenever it finds an <code>&lt;a></code> tag. The tag may contain an <code>href</code> attribute, and/or other attributes, like <code>name</code> or <code>title</code>. The <var>attrs</var> parameter is a list of tuples, <code>[(<var>attribute</var>, <var>value</var>), (<var>attribute</var>, <var>value</var>), ...]</code>. Or it may be just an <code>&lt;a></code>, a valid (if useless) <abbr>HTML</abbr> tag, in which case <var>attrs</var> would be an empty list.
<li>You can find out whether this <code>&lt;a></code> tag has an <code>href</code> attribute with a simple <a href="#odbchelper.multiassign" title="3.4.2. Assigning Multiple Values at Once">multi-variable</a> <a href="#odbchelper.map" title="3.6. Mapping Lists">list comprehension</a>.
<li>String comparisons like <code>k=='href'</code> are always case-sensitive, but that's safe in this case, because <code>SGMLParser</code> converts attribute names to lowercase while building <var>attrs</var>.
<div class=example><h3 id="dialect.feed.example">Example 8.7. Using <code>urllister.py</code></h3><pre class=screen>
<samp class=prompt>>>> </samp><kbd>import urllib, urllister</kbd>
<samp class=prompt>>>> </samp><kbd>usock = urllib.urlopen("http://diveintopython3.org/")</kbd>
<samp class=prompt>>>> </samp><kbd>parser = urllister.URLLister()</kbd>
<samp class=prompt>>>> </samp><kbd>parser.feed(usock.read())</kbd>         <span>&#x2460;</span>
<samp class=prompt>>>> </samp><kbd>usock.close()</kbd>   <span>&#x2461;</span>
<samp class=prompt>>>> </samp><kbd>parser.close()</kbd>  <span>&#x2462;</span>
<samp class=prompt>>>> </samp><kbd>for url in parser.urls: print url</kbd> <span>&#x2463;</span>
<samp>toc/index.html
#download
#languages
toc/index.html
appendix/history.html
download/diveintopython3-html-5.0.zip
download/diveintopython3-pdf-5.0.zip
download/diveintopython3-word-5.0.zip
download/diveintopython3-text-5.0.zip
download/diveintopython3-html-flat-5.0.zip
download/diveintopython3-xml-5.0.zip
download/diveintopython3-common-5.0.zip
</span>

... rest of output omitted for brevity ...</pre><div class=calloutlist>
<ol>
<li>Call the <code>feed</code> method, defined in <code>SGMLParser</code>, to get <abbr>HTML</abbr> into the parser.
<sup>[<a name="d0e20503" href="#ftn.d0e20503">1</a>]</sup>  It takes a string, which is what <code>usock.read()</code> returns.
<li>Like files, you should <code>close</code> your <abbr>URL</abbr> objects as soon as you're done with them.
<li>You should <code>close</code> your parser object, too, but for a different reason. You've read all the data and fed it to the parser, but the <code>feed</code> method isn't guaranteed to have actually processed all the <abbr>HTML</abbr> you give it; it may buffer it, waiting for more. Be sure to call <code>close</code> to flush the buffer and force everything to be fully parsed.
<li>Once the parser is <code>close</code>d, the parsing is complete, and <var>parser.urls</var> contains a list of all the linked <abbr>URL</abbr>s in the <abbr>HTML</abbr> document. (Your output may look different, if the download links have been updated by the time you read this.)
<h2 id="dialect.basehtml">8.4. Introducing <code>BaseHTMLProcessor.py</code></h2>
<p><code>SGMLParser</code> doesn't produce anything by itself. It parses and parses and parses, and it calls a method for each interesting thing it
   finds, but the methods don't do anything. <code>SGMLParser</code> is an <abbr>HTML</abbr> <em>consumer</em>: it takes <abbr>HTML</abbr> and breaks it down into small, structured pieces. As you saw in the <a href="#dialect.extract" title="8.3. Extracting data from HTML documents">previous section</a>, you can subclass <code>SGMLParser</code> to define classes that catch specific tags and produce useful things, like a list of all the links on a web page. Now you'll
   take this one step further by defining a class that catches everything <code>SGMLParser</code> throws at it and reconstructs the complete <abbr>HTML</abbr> document. In technical terms, this class will be an <abbr>HTML</abbr> <em>producer</em>.
<p><code>BaseHTMLProcessor</code> subclasses <code>SGMLParser</code> and provides all 8 essential handler methods: <code>unknown_starttag</code>, <code>unknown_endtag</code>, <code>handle_charref</code>, <code>handle_entityref</code>, <code>handle_comment</code>, <code>handle_pi</code>, <code>handle_decl</code>, and <code>handle_data</code>.
<div class=example><h3 id="dialect.basehtml.intro">Example 8.8. Introducing <code>BaseHTMLProcessor</code></h3><pre><code>
class BaseHTMLProcessor(SGMLParser):
    def reset(self):      <span>&#x2460;</span>
        self.pieces = []
        SGMLParser.reset(self)

    def unknown_starttag(self, tag, attrs): <span>&#x2461;</span>
        strattrs = "".join([' %s="%s"' % (key, value) for key, value in attrs])
        self.pieces.append("&lt;%(tag)s%(strattrs)s>" % locals())

    def unknown_endtag(self, tag):          <span>&#x2462;</span>
        self.pieces.append("&lt;/%(tag)s>" % locals())

    def handle_charref(self, ref):          <span>&#x2463;</span>
        self.pieces.append("&amp;#%(ref)s;" % locals())

    def handle_entityref(self, ref):        <span>&#x2464;</span>
        self.pieces.append("&amp;%(ref)s" % locals())
        if htmlentitydefs.entitydefs.has_key(ref):
            self.pieces.append(";")

    def handle_data(self, text):            <span>&#x2465;</span>
        self.pieces.append(text)

    def handle_comment(self, text):         <span>&#x2466;</span>
        self.pieces.append("&lt;!--%(text)s-->" % locals())

    def handle_pi(self, text):              <span>&#x2467;</span>
        self.pieces.append("&lt;?%(text)s>" % locals())

    def handle_decl(self, text):
        self.pieces.append("&lt;!%(text)s>" % locals())</pre><div class=calloutlist>
<ol>
<li><code>reset</code>, called by <code>SGMLParser.__init__</code>, initializes <var>self.pieces</var> as an empty list before <a href="#fileinfo.init.code.example" title="Example 5.6. Coding the FileInfo Class">calling the ancestor method</a>. <var>self.pieces</var> is a <a href="#fileinfo.userdict.init.example" title="Example 5.9. Defining the UserDict Class">data attribute</a> which will hold the pieces of the <abbr>HTML</abbr> document you're constructing. Each handler method will reconstruct the <abbr>HTML</abbr> that <code>SGMLParser</code> parsed, and each method will append that string to <var>self.pieces</var>. Note that <var>self.pieces</var> is a list. You might be tempted to define it as a string and just keep appending each piece to it. That would work, but
Python is much more efficient at dealing with lists.
<sup>[<a name="d0e20702" href="#ftn.d0e20702">2</a>]</sup><li>Since <code>BaseHTMLProcessor</code> does not define any methods for specific tags (like the <code>start_a</code> method in <a href="#dialect.extract.links" title="Example 8.6. Introducing urllister.py"><code>URLLister</code></a>), <code>SGMLParser</code> will call <code>unknown_starttag</code> for every start tag. This method takes the tag (<var>tag</var>) and the list of attribute name/value pairs (<var>attrs</var>), reconstructs the original <abbr>HTML</abbr>, and appends it to <var>self.pieces</var>. The <a href="#odbchelper.stringformatting" title="3.5. Formatting Strings">string formatting</a> here is a little strange; you'll untangle that (and also the odd-looking <code>locals</code> function) later in this chapter.
<li>Reconstructing end tags is much simpler; just take the tag name and wrap it in the <code>&lt;/...></code> brackets.
<li>When <code>SGMLParser</code> finds a character reference, it calls <code>handle_charref</code> with the bare reference. If the <abbr>HTML</abbr> document contains the reference <code>&amp;#160;</code>, <var>ref</var> will be <code>160</code>. Reconstructing the original complete character reference just involves wrapping <var>ref</var> in <code>&amp;#...;</code> characters.
<li>Entity references are similar to character references, but without the hash mark. Reconstructing the original entity reference
            requires wrapping <var>ref</var> in <code>&amp;...;</code> characters. (Actually, as an erudite reader pointed out to me, it's slightly more complicated than this. Only certain standard
<abbr>HTML</abbr> entites end in a semicolon; other similar-looking entities do not. Luckily for us, the set of standard <abbr>HTML</abbr> entities is defined in a dictionary in a Python module called <code>htmlentitydefs</code>. Hence the extra <code>if</code> statement.)
<li>Blocks of text are simply appended to <var>self.pieces</var> unaltered.
<li><abbr>HTML</abbr> comments are wrapped in <code>&lt;!--...--></code> characters.
<li>Processing instructions are wrapped in <code>&lt;?...></code> characters.
<table class=important border="0" summary="">

<td rowspan="2" align="center" valign="top" width="1%"><img src="images/important.png" alt="Important" title="" width="24" height="24"><td colspan="2" align="left" valign="top" width="99%">The <abbr>HTML</abbr> specification requires that all non-<abbr>HTML</abbr> (like client-side JavaScript) must be enclosed in <abbr>HTML</abbr> comments, but not all web pages do this properly (and all modern web browsers are forgiving if they don't). <code>BaseHTMLProcessor</code> is not forgiving; if script is improperly embedded, it will be parsed as if it were <abbr>HTML</abbr>. For instance, if the script contains less-than and equals signs, <code>SGMLParser</code> may incorrectly think that it has found tags and attributes. <code>SGMLParser</code> always converts tags and attribute names to lowercase, which may break the script, and <code>BaseHTMLProcessor</code> always encloses attribute values in double quotes (even if the original <abbr>HTML</abbr> document used single quotes or no quotes), which will certainly break the script. Always protect your client-side script
      within <abbr>HTML</abbr> comments.
<div class=example><h3 id="dialect.output.example">Example 8.9. <code>BaseHTMLProcessor</code> output</h3><pre><code>
    def output(self):               <span>&#x2460;</span>
        """Return processed HTML as a single string"""
        return "".join(self.pieces) <span>&#x2461;</span></pre><div class=calloutlist>
<ol>
<li>This is the one method in <code>BaseHTMLProcessor</code> that is never called by the ancestor <code>SGMLParser</code>. Since the other handler methods store their reconstructed <abbr>HTML</abbr> in <var>self.pieces</var>, this function is needed to join all those pieces into one string. As noted before, Python is great at lists and mediocre at strings, so you only create the complete string when somebody explicitly asks for it.
<li>If you prefer, you could use the <code>join</code> method of the <code>string</code> module instead: <code>string.join(self.pieces, "")</code><div class=itemizedlist>
<h3>Further reading</h3>
<ul>
<li><a href="http://www.w3.org/">W3C</a> discusses <a href="http://www.w3.org/TR/REC-html40/charset.html#entities">character and entity references</a>.

<li><a href="http://www.python.org/doc/current/lib/"><i class=citetitle>Python Library Reference</i></a> confirms your suspicions that <a href="http://www.python.org/doc/current/lib/module-htmlentitydefs.html">the <code>htmlentitydefs</code> module</a> is exactly what it sounds like.

</ul>
<h2 id="dialect.locals">8.5. <code>locals</code> and <code>globals</code></h2>
<p>Let's digress from <abbr>HTML</abbr> processing for a minute and talk about how Python handles variables. Python has two built-in functions, <code>locals</code> and <code>globals</code>, which provide dictionary-based access to local and global variables.
<p>Remember <code>locals</code>?  You first saw it here:
<pre><code>
    def unknown_starttag(self, tag, attrs):
        strattrs = "".join([' %s="%s"' % (key, value) for key, value in attrs])
        self.pieces.append("&lt;%(tag)s%(strattrs)s>" % locals())
</pre><p>No, wait, you can't learn about <code>locals</code> yet. First, you need to learn about namespaces. This is dry stuff, but it's important, so pay attention.
<p>Python uses what are called namespaces to keep track of variables. A namespace is just like a dictionary where the keys are names
of variables and the dictionary values are the values of those variables. In fact, you can access a namespace as a Python dictionary, as you'll see in a minute.
<p>At any particular point in a Python program, there are several namespaces available. Each function has its own namespace, called the local namespace, which
keeps track of the function's variables, including function arguments and locally defined variables. Each module has its
own namespace, called the global namespace, which keeps track of the module's variables, including functions, classes, any
other imported modules, and module-level variables and constants. And there is the built-in namespace, accessible from any
module, which holds built-in functions and exceptions.
<p>When a line of code asks for the value of a variable <var>x</var>, Python will search for that variable in all the available namespaces, in order:
<div class=orderedlist>
<ol>
<li>local namespace - specific to the current function or class method. If the function defines a local variable <var>x</var>, or has an argument <var>x</var>, Python will use this and stop searching.

<li>global namespace - specific to the current module. If the module has defined a variable, function, or class called <var>x</var>, Python will use that and stop searching.

<li>built-in namespace - global to all modules. As a last resort, Python will assume that <var>x</var> is the name of built-in function or variable.

</ol>
<p>If Python doesn't find <var>x</var> in any of these namespaces, it gives up and raises a <code>NameError</code> with the message <samp>There is no variable named 'x'</samp>, which you saw back in <a href="#odbchelper.unboundvariable" title="Example 3.18. Referencing an Unbound Variable">Example 3.18, &#8220;Referencing an Unbound Variable&#8221;</a>, but you didn't appreciate how much work Python was doing before giving you that error.
<table class=important border="0" summary="">

<td rowspan="2" align="center" valign="top" width="1%"><img src="images/important.png" alt="Important" title="" width="24" height="24"><td colspan="2" align="left" valign="top" width="99%">Python 2.2 introduced a subtle but important change that affects the namespace search order: nested scopes. In versions of Python prior to 2.2, when you reference a variable within a <a href="#fileinfo.nested" title="Example 6.21. listDirectory">nested function</a> or <a href="#apihelper.lambda" title="4.7. Using lambda Functions"><code>lambda</code> function</a>, Python will search for that variable in the current (nested or <code>lambda</code>) function's namespace, then in the module's namespace. Python 2.2 will search for the variable in the current (nested or <code>lambda</code>) function's namespace, <em>then in the parent function's namespace</em>, then in the module's namespace. Python 2.1 can work either way; by default, it works like Python 2.0, but you can add the following line of code at the top of your module to make your module work like Python 2.2:<pre><code>
from __future__ import nested_scopes</pre><p>Are you confused yet?  Don't despair!  This is really cool, I promise. Like many things in Python, namespaces are <em>directly accessible at run-time</em>. How?  Well, the local namespace is accessible via the built-in <code>locals</code> function, and the global (module level) namespace is accessible via the built-in <code>globals</code> function.
<div class=example><h3>Example 8.10. Introducing <code>locals</code></h3><pre class=screen><samp class=prompt>>>> </samp><kbd>def foo(arg):</kbd> <span>&#x2460;</span>
<samp class=prompt>...    </samp>x = 1
<samp class=prompt>...    </samp>print locals()
<samp class=prompt>...    </samp>
<samp class=prompt>>>> </samp><kbd>foo(7)</kbd>        <span>&#x2461;</span>
{'arg': 7, 'x': 1}
<samp class=prompt>>>> </samp><kbd>foo('bar')</kbd>    <span>&#x2462;</span>
{'arg': 'bar', 'x': 1}</pre><div class=calloutlist>
<ol>
<li>The function <code>foo</code> has two variables in its local namespace: <var>arg</var>, whose value is passed in to the function, and <var>x</var>, which is defined within the function.
<li><code>locals</code> returns a dictionary of name/value pairs. The keys of this dictionary are the names of the variables as strings; the values
            of the dictionary are the actual values of the variables. So calling <code>foo</code> with <code>7</code> prints the dictionary containing the function's two local variables: <var>arg</var> (<code>7</code>) and <var>x</var> (<code>1</code>).
<li>Remember, Python has dynamic typing, so you could just as easily pass a string in for <var>arg</var>; the function (and the call to <code>locals</code>) would still work just as well. <code>locals</code> works with all variables of all datatypes.
<p>What <code>locals</code> does for the local (function) namespace, <code>globals</code> does for the global (module) namespace. <code>globals</code> is more exciting, though, because a module's namespace is more exciting.
<sup>[<a name="d0e21226" href="#ftn.d0e21226">3</a>]</sup>  Not only does the module's namespace include module-level variables and constants, it includes all the functions and classes
defined in the module. Plus, it includes anything that was imported into the module.
<p>Remember the difference between <a href="#fileinfo.fromimport" title="5.2. Importing Modules Using from module import"><code>from <var>module</var> import</code></a> and <a href="#odbchelper.import" title="Example 2.3. Accessing the buildConnectionString Function's docstring"><code>import <var>module</var></code></a>?  With <code>import <var>module</var></code>, the module itself is imported, but it retains its own namespace, which is why you need to use the module name to access
any of its functions or attributes: <code><var>module</var>.<var>function</var></code>. But with <code>from <var>module</var> import</code>, you're actually importing specific functions and attributes from another module into your own namespace, which is why you
access them directly without referencing the original module they came from. With the <code>globals</code> function, you can actually see this happen.
<div class=example><h3 id="dialect.globals.example">Example 8.11. Introducing <code>globals</code></h3>
<p>Look at the following block of code at the bottom of <code>BaseHTMLProcessor.py</code>:<pre><code>
if __name__ == "__main__":
    for k, v in globals().items():             <span>&#x2460;</span>
        print k, "=", v</pre><div class=calloutlist>
<ol>
<li>Just so you don't get intimidated, remember that you've seen all this before. The <code>globals</code> function returns a dictionary, and you're <a href="#dictionaryiter.example" title="Example 6.10. Iterating Through a Dictionary">iterating through the dictionary</a> using the <code>items</code> method and <a href="#odbchelper.multiassign" title="3.4.2. Assigning Multiple Values at Once">multi-variable assignment</a>. The only thing new here is the <code>globals</code> function.
<p>Now running the script from the command line gives this output (note that your output may be slightly different, depending
   on your platform and where you installed Python):<pre class=screen><samp class=prompt>c:\docbook\dip\py></samp> python BaseHTMLProcessor.py</pre><pre><code>
SGMLParser = sgmllib.SGMLParser                <span>&#x2460;</span>
htmlentitydefs = &lt;module 'htmlentitydefs' from 'C:\Python23\lib\htmlentitydefs.py'> <span>&#x2461;</span>
BaseHTMLProcessor = __main__.BaseHTMLProcessor <span>&#x2462;</span>
__name__ = __main__          <span>&#x2463;</span>
... rest of output omitted for brevity...</pre><div class=calloutlist>
<ol>
<li><code>SGMLParser</code> was imported from <code>sgmllib</code>, using <code>from <var>module</var> import</code>. That means that it was imported directly into the module's namespace, and here it is.
<li>Contrast this with <code>htmlentitydefs</code>, which was imported using <code>import</code>. That means that the <code>htmlentitydefs</code> module itself is in the namespace, but the <var>entitydefs</var> variable defined within <code>htmlentitydefs</code> is not.
<li>This module only defines one class, <code>BaseHTMLProcessor</code>, and here it is. Note that the value here is <a href="#fileinfo.classattributes.intro" title="Example 5.17. Introducing Class Attributes">the class itself</a>, not a specific instance of the class.
<li>Remember the <a href="#odbchelper.ifnametrick"><code>if __name__</code> trick</a>?  When running a module (as opposed to importing it from another module), the built-in <code>__name__</code> attribute is a special value, <code>__main__</code>. Since you ran this module as a script from the command line, <code>__name__</code> is <code>__main__</code>, which is why the little test code to print the <code>globals</code> got executed.
<table id="tip.localsbyname" class=note border="0" summary="">

<td rowspan="2" align="center" valign="top" width="1%"><img src="images/note.png" alt="Note" title="" width="24" height="24"><td colspan="2" align="left" valign="top" width="99%">Using the <code>locals</code> and <code>globals</code> functions, you can get the value of arbitrary variables dynamically, providing the variable name as a string. This mirrors
      the functionality of the <a href="#apihelper.getattr" title="4.4. Getting Object References With getattr"><code>getattr</code></a> function, which allows you to access arbitrary functions dynamically by providing the function name as a string.
<p>There is one other important difference between the <code>locals</code> and <code>globals</code> functions, which you should learn now before it bites you. It will bite you anyway, but at least then you'll remember learning
it.
<div class=example><h3 id="dialect.locals.readonly.example">Example 8.12. <code>locals</code> is read-only, <code>globals</code> is not</h3><pre><code>
def foo(arg):
    x = 1
    print locals()    <span>&#x2460;</span>
    locals()["x"] = 2 <span>&#x2461;</span>
    print "x=",x      <span>&#x2462;</span>

z = 7
print "z=",z
foo(3)
globals()["z"] = 8    <span>&#x2463;</span>
print "z=",z          <span>&#x2464;</span>
</pre><div class=calloutlist>
<ol>
<li>Since <code>foo</code> is called with <code>3</code>, this will print <code>{'arg': 3, 'x': 1}</code>. This should not be a surprise.
<li><code>locals</code> is a function that returns a dictionary, and here you are setting a value in that dictionary. You might think that this
            would change the value of the local variable <var>x</var> to <code>2</code>, but it doesn't. <code>locals</code> does not actually return the local namespace, it returns a copy. So changing it does nothing to the value of the variables
            in the local namespace.
<li>This prints <code>x= 1</code>, not <code>x= 2</code>.
<li>After being burned by <code>locals</code>, you might think that this <em>wouldn't</em> change the value of <var>z</var>, but it does. Due to internal differences in how Python is implemented (which I'd rather not go into, since I don't fully understand them myself), <code>globals</code> returns the actual global namespace, not a copy: the exact opposite behavior of <code>locals</code>. So any changes to the dictionary returned by <code>globals</code> directly affect your global variables.
<li>This prints <code>z= 8</code>, not <code>z= 7</code>.
<h2 id="dialect.dictsub">8.6. Dictionary-based string formatting</h2>
<p>Why did you learn about <code>locals</code> and <code>globals</code>?  So you can learn about dictionary-based string formatting. As you recall, <a href="#odbchelper.stringformatting" title="3.5. Formatting Strings">regular string formatting</a> provides an easy way to insert values into strings. Values are listed in a tuple and inserted in order into the string in
place of each formatting marker. While this is efficient, it is not always the easiest code to read, especially when multiple
values are being inserted. You can't simply scan through the string in one pass and understand what the result will be; you're
constantly switching between reading the string and reading the tuple of values.
<p>There is an alternative form of string formatting that uses dictionaries instead of tuples of values.
<div class=example><h3>Example 8.13. Introducing dictionary-based string formatting</h3><pre class=screen>
<samp class=prompt>>>> </samp><kbd>params = {"server":"mpilgrim", "database":"master", "uid":"sa", "pwd":"secret"}</kbd>
<samp class=prompt>>>> </samp><kbd>"%(pwd)s" % params</kbd><span>&#x2460;</span>
'secret'
<samp class=prompt>>>> </samp><kbd>"%(pwd)s is not a good password for %(uid)s" % params</kbd> <span>&#x2461;</span>
'secret is not a good password for sa'
<samp class=prompt>>>> </samp><kbd>"%(database)s of mind, %(database)s of body" % params</kbd> <span>&#x2462;</span>
'master of mind, master of body'</pre><div class=calloutlist>
<ol>
<li>Instead of a tuple of explicit values, this form of string formatting uses a dictionary, <var>params</var>. And instead of a simple <code>%s</code> marker in the string, the marker contains a name in parentheses. This name is used as a key in the <var>params</var> dictionary and subsitutes the corresponding value, <code>secret</code>, in place of the <code>%(pwd)s</code> marker.
<li>Dictionary-based string formatting works with any number of named keys. Each key must exist in the given dictionary, or the
            formatting will fail with a <code>KeyError</code>.
<li>You can even specify the same key twice; each occurrence will be replaced with the same value.
<p>So why would you use dictionary-based string formatting?  Well, it does seem like overkill to set up a dictionary of keys
and values simply to do string formatting in the next line; it's really most useful when you happen to have a dictionary of
meaningful keys and values already. Like <a href="#dialect.locals" title="8.5. locals and globals"><code>locals</code></a>.
<div class=example><h3 id="dialect.unknownstarttag">Example 8.14. Dictionary-based string formatting in <code>BaseHTMLProcessor.py</code></h3><pre><code>
    def handle_comment(self, text):        
        self.pieces.append("&lt;!--%(text)s-->" % locals()) <span>&#x2460;</span>
</pre><div class=calloutlist>
<ol>
<li>Using the built-in <code>locals</code> function is the most common use of dictionary-based string formatting. It means that you can use the names of local variables
            within your string (in this case, <var>text</var>, which was passed to the class method as an argument) and each named variable will be replaced by its value. If <var>text</var> is <code>'Begin page footer'</code>, the string formatting <code>"&lt;!--%(text)s-->" % locals()</code> will resolve to the string <code>'&lt;!--Begin page footer-->'</code>.
<div class=example><h3>Example 8.15. More dictionary-based string formatting</h3><pre><code>
    def unknown_starttag(self, tag, attrs):
        strattrs = "".join([' %s="%s"' % (key, value) for key, value in attrs]) <span>&#x2460;</span>
        self.pieces.append("&lt;%(tag)s%(strattrs)s>" % locals())    <span>&#x2461;</span>
</pre><div class=calloutlist>
<ol>
<li>When this method is called, <var>attrs</var> is a list of key/value tuples, just like the <a href="#odbchelper.items" title="Example 3.25. The keys, values, and items Functions"><code>items</code> of a dictionary</a>, which means you can use <a href="#odbchelper.multiassign" title="3.4.2. Assigning Multiple Values at Once">multi-variable assignment</a> to iterate through it. This should be a familiar pattern by now, but there's a lot going on here, so let's break it down:
<div class=orderedlist>
<ol type="a">
<li>Suppose <var>attrs</var> is <code>[('href', 'index.html'), ('title', 'Go to home page')]</code>.

<li>In the first round of the list comprehension, <var>key</var> will get <code>'href'</code>, and <var>value</var> will get <code>'index.html'</code>.

<li>The string formatting <code>' %s="%s"' % (key, value)</code> will resolve to <code>' href="index.html"'</code>. This string becomes the first element of the list comprehension's return value.

<li>In the second round, <var>key</var> will get <code>'title'</code>, and <var>value</var> will get <code>'Go to home page'</code>.

<li>The string formatting will resolve to <code>' title="Go to home page"'</code>.

<li>The list comprehension returns a list of these two resolved strings, and <var>strattrs</var> will join both elements of this list together to form <code>' href="index.html" title="Go to home page"'</code>.

</ol>
<li>Now, using dictionary-based string formatting, you insert the value of <var>tag</var> and <var>strattrs</var> into a string. So if <var>tag</var> is <code>'a'</code>, the final result would be <code>'&lt;a href="index.html" title="Go to home page">'</code>, and that is what gets appended to <var>self.pieces</var>.
<table class=important border="0" summary="">

<td rowspan="2" align="center" valign="top" width="1%"><img src="images/important.png" alt="Important" title="" width="24" height="24"><td colspan="2" align="left" valign="top" width="99%">Using dictionary-based string formatting with <code>locals</code> is a convenient way of making complex string formatting expressions more readable, but it comes with a price. There is a
      slight performance hit in making the call to <code>locals</code>, since <a href="#dialect.locals.readonly.example" title="Example 8.12. locals is read-only, globals is not"><code>locals</code> builds a copy</a> of the local namespace.
<h2 id="dialect.quoting">8.7. Quoting attribute values</h2>
<p>A common question on <a href="http://groups.google.com/groups?group=comp.lang.python">comp.lang.python</a> is &#8220;I have a bunch of <abbr>HTML</abbr> documents with unquoted attribute values, and I want to properly quote them all. How can I do this?&#8221;<sup>[<a name="d0e21764" href="#ftn.d0e21764">4</a>]</sup>  (This is generally precipitated by a project manager who has found the <abbr>HTML</abbr>-is-a-standard religion joining a large project and proclaiming that all pages must validate against an <abbr>HTML</abbr> validator. Unquoted attribute values are a common violation of the <abbr>HTML</abbr> standard.)  Whatever the reason, unquoted attribute values are easy to fix by feeding <abbr>HTML</abbr> through <code>BaseHTMLProcessor</code>.
<p><code>BaseHTMLProcessor</code> consumes <abbr>HTML</abbr> (since it's descended from <code>SGMLParser</code>) and produces equivalent <abbr>HTML</abbr>, but the <abbr>HTML</abbr> output is not identical to the input. Tags and attribute names will end up in lowercase, even if they started in uppercase
or mixed case, and attribute values will be enclosed in double quotes, even if they started in single quotes or with no quotes
at all. It is this last side effect that you can take advantage of.
<div class=example><h3 id="dialect.quoting.example">Example 8.16. Quoting attribute values</h3><pre class=screen>
<samp class=prompt>>>> </samp><kbd>htmlSource = """</kbd>        <span>&#x2460;</span>
<samp class=prompt>...    </samp>&lt;html>
<samp class=prompt>...    </samp>&lt;head>
<samp class=prompt>...    </samp>&lt;title>Test page&lt;/title>
<samp class=prompt>...    </samp>&lt;/head>
<samp class=prompt>...    </samp>&lt;body>
<samp class=prompt>...    </samp>&lt;ul>
<samp class=prompt>...    </samp>&lt;li>&lt;a href=index.html>Home&lt;/a>&lt;/li>
<samp class=prompt>...    </samp>&lt;li>&lt;a href=toc.html>Table of contents&lt;/a>&lt;/li>
<samp class=prompt>...    </samp>&lt;li>&lt;a href=history.html>Revision history&lt;/a>&lt;/li>
<samp class=prompt>...    </samp>&lt;/body>
<samp class=prompt>...    </samp>&lt;/html>
<samp class=prompt>...    </samp>"""
<samp class=prompt>>>> </samp><kbd>from BaseHTMLProcessor import BaseHTMLProcessor</kbd>
<samp class=prompt>>>> </samp><kbd>parser = BaseHTMLProcessor()</kbd>
<samp class=prompt>>>> </samp><kbd>parser.feed(htmlSource)</kbd> <span>&#x2461;</span>
<samp class=prompt>>>> </samp><kbd>print parser.output()</kbd>   <span>&#x2462;</span>
<samp>&lt;html>
&lt;head>
&lt;title>Test page&lt;/title>
&lt;/head>
&lt;body>
&lt;ul>
&lt;li>&lt;a href="index.html">Home&lt;/a>&lt;/li>
&lt;li>&lt;a href="toc.html">Table of contents&lt;/a>&lt;/li>
&lt;li>&lt;a href="history.html">Revision history&lt;/a>&lt;/li>
&lt;/body>
&lt;/html></span></pre><div class=calloutlist>
<ol>
<li>Note that the attribute values of the <code>href</code> attributes in the <code>&lt;a></code> tags are not properly quoted. (Also note that you're using <a href="#odbchelper.triplequotes" title="Example 2.2. Defining the buildConnectionString Function's docstring">triple quotes</a> for something other than a <code>docstring</code>. And directly in the <abbr>IDE</abbr>, no less. They're very useful.)
<li>Feed the parser.
<li>Using the <code>output</code> function defined in <code>BaseHTMLProcessor</code>, you get the output as a single string, complete with quoted attribute values. While this may seem anti-climactic, think
            about how much has actually happened here: <code>SGMLParser</code> parsed the entire <abbr>HTML</abbr> document, breaking it down into tags, refs, data, and so forth; <code>BaseHTMLProcessor</code> used those elements to reconstruct pieces of <abbr>HTML</abbr> (which are still stored in <var>parser.pieces</var>, if you want to see them); finally, you called <code>parser.output</code>, which joined all the pieces of <abbr>HTML</abbr> into one string.
<h2 id="dialect.dialectizer">8.8. Introducing <code>dialect.py</code></h2>
<p><code>Dialectizer</code> is a simple (and silly) descendant of <code>BaseHTMLProcessor</code>. It runs blocks of text through a series of substitutions, but it makes sure that anything within a <code><code>&lt;pre></code>...<code>&lt;/pre></code></code> block passes through unaltered.
<p>To handle the <code>&lt;pre></code> blocks, you define two methods in <code>Dialectizer</code>: <code>start_pre</code> and <code>end_pre</code>.
<div class=example><h3 id="dialect.specifictags.example">Example 8.17. Handling specific tags</h3><pre><code>
    def start_pre(self, attrs):             <span>&#x2460;</span>
        self.verbatim += 1<span>&#x2461;</span>
        self.unknown_starttag("pre", attrs) <span>&#x2462;</span>

    def end_pre(self):    <span>&#x2463;</span>
        self.unknown_endtag("pre")          <span>&#x2464;</span>
        self.verbatim -= 1<span>&#x2465;</span></pre><div class=calloutlist>
<ol>
<li><code>start_pre</code> is called every time <code>SGMLParser</code> finds a <code>&lt;pre></code> tag in the <abbr>HTML</abbr> source. (In a minute, you'll see exactly how this happens.)  The method takes a single parameter, <var>attrs</var>, which contains the attributes of the tag (if any). <var>attrs</var> is a list of key/value tuples, just like <a href="#dialect.unknownstarttag" title="Example 8.14. Dictionary-based string formatting in BaseHTMLProcessor.py"><code>unknown_starttag</code></a> takes.
<li>In the <code>reset</code> method, you initialize a data attribute that serves as a counter for <code>&lt;pre></code> tags. Every time you hit a <code>&lt;pre></code> tag, you increment the counter; every time you hit a <code>&lt;/pre></code> tag, you'll decrement the counter. (You could just use this as a flag and set it to <code>1</code> and reset it to <code>0</code>, but it's just as easy to do it this way, and this handles the odd (but possible) case of nested <code>&lt;pre></code> tags.)  In a minute, you'll see how this counter is put to good use.
<li>That's it, that's the only special processing you do for <code>&lt;pre></code> tags. Now you pass the list of attributes along to <code>unknown_starttag</code> so it can do the default processing.
<li><code>end_pre</code> is called every time <code>SGMLParser</code> finds a <code>&lt;/pre></code> tag. Since end tags can not contain attributes, the method takes no parameters.
<li>First, you want to do the default processing, just like any other end tag.
<li>Second, you decrement your counter to signal that this <code>&lt;pre></code> block has been closed.
<p>At this point, it's worth digging a little further into <code>SGMLParser</code>. I've claimed repeatedly (and you've taken it on faith so far) that <code>SGMLParser</code> looks for and calls specific methods for each tag, if they exist. For instance, you just saw the definition of <code>start_pre</code> and <code>end_pre</code> to handle <code>&lt;pre></code> and <code>&lt;/pre></code>. But how does this happen?  Well, it's not magic, it's just good Python coding.
<div class=example><h3 id="dialect.dialectizer.example">Example 8.18. <code>SGMLParser</code></h3><pre><code>
    def finish_starttag(self, tag, attrs):               <span>&#x2460;</span>
        try:        
            method = getattr(self, 'start_' + tag)       <span>&#x2461;</span>
        except AttributeError:         <span>&#x2462;</span>
            try:    
                method = getattr(self, 'do_' + tag)      <span>&#x2463;</span>
            except AttributeError:    
                self.unknown_starttag(tag, attrs)        <span>&#x2464;</span>
                return -1             
            else:   
                self.handle_starttag(tag, method, attrs) <span>&#x2465;</span>
                return 0              
        else:       
            self.stack.append(tag)    
            self.handle_starttag(tag, method, attrs)    
            return 1 <span>&#x2466;</span>

    def handle_starttag(self, tag, method, attrs):      
        method(attrs)<span>&#x2467;</span></pre><div class=calloutlist>
<ol>
<li>At this point, <code>SGMLParser</code> has already found a start tag and parsed the attribute list. The only thing left to do is figure out whether there is a
            specific handler method for this tag, or whether you should fall back on the default method (<code>unknown_starttag</code>).
<li>The &#8220;magic&#8221; of <code>SGMLParser</code> is nothing more than your old friend, <a href="#apihelper.getattr" title="4.4. Getting Object References With getattr"><code>getattr</code></a>. What you may not have realized before is that <code>getattr</code> will find methods defined in descendants of an object as well as the object itself. Here the object is <code>self</code>, the current instance. So if <var>tag</var> is <code>'pre'</code>, this call to <code>getattr</code> will look for a <code>start_pre</code> method on the current instance, which is an instance of the <code>Dialectizer</code> class.
<li><code>getattr</code> raises an <code>AttributeError</code> if the method it's looking for doesn't exist in the object (or any of its descendants), but that's okay, because you wrapped
            the call to <code>getattr</code> inside a <a href="#fileinfo.exception" title="6.1. Handling Exceptions"><code>try...except</code></a> block and explicitly caught the <code>AttributeError</code>.
<li>Since you didn't find a <code>start_xxx</code> method, you'll also look for a <code>do_xxx</code> method before giving up. This alternate naming scheme is generally used for standalone tags, like <code>&lt;br></code>, which have no corresponding end tag. But you can use either naming scheme; as you can see, <code>SGMLParser</code> tries both for every tag. (You shouldn't define both a <code>start_xxx</code> and <code>do_xxx</code> handler method for the same tag, though; only the <code>start_xxx</code> method will get called.)
<li>Another <code>AttributeError</code>, which means that the call to <code>getattr</code> failed with <code>do_xxx</code>. Since you found neither a <code>start_xxx</code> nor a <code>do_xxx</code> method for this tag, you catch the exception and fall back on the default method, <code>unknown_starttag</code>.
<li>Remember, <code>try...except</code> blocks can have an <code>else</code> clause, which is called if <a href="#crossplatform.example" title="Example 6.2. Supporting Platform-Specific Functionality">no exception is raised</a> during the <code>try...except</code> block. Logically, that means that you <em>did</em> find a <code>do_xxx</code> method for this tag, so you're going to call it.
<li>By the way, don't worry about these different return values; in theory they mean something, but they're never actually used.
             Don't worry about the <code>self.stack.append(tag)</code> either; <code>SGMLParser</code> keeps track internally of whether your start tags are balanced by appropriate end tags, but it doesn't do anything with this
            information either. In theory, you could use this module to validate that your tags were fully balanced, but it's probably
            not worth it, and it's beyond the scope of this chapter. You have better things to worry about right now.
<li><code>start_xxx</code> and <code>do_xxx</code> methods are not called directly; the tag, method, and attributes are passed to this function, <code>handle_starttag</code>, so that descendants can override it and change the way <em>all</em> start tags are dispatched. You don't need that level of control, so you just let this method do its thing, which is to call
            the method (<code>start_xxx</code> or <code>do_xxx</code>) with the list of attributes. Remember, <var>method</var> is a function, returned from <code>getattr</code>, and functions are objects. (I know you're getting tired of hearing it, and I promise I'll stop saying it as soon as I run
            out of ways to use it to my advantage.)  Here, the function object is passed into this dispatch method as an argument, and
            this method turns around and calls the function. At this point, you don't need to know what the function is, what it's named,
            or where it's defined; the only thing you need to know about the function is that it is called with one argument, <var>attrs</var>.
<p>Now back to our regularly scheduled program: <code>Dialectizer</code>. When you left, you were in the process of defining specific handler methods for <code>&lt;pre></code> and <code>&lt;/pre></code> tags. There's only one thing left to do, and that is to process text blocks with the pre-defined substitutions. For that,
you need to override the <code>handle_data</code> method.
<div class=example><h3>Example 8.19. Overriding the <code>handle_data</code> method</h3><pre><code>
    def handle_data(self, text):     <span>&#x2460;</span>
        self.pieces.append(self.verbatim and text or self.process(text)) <span>&#x2461;</span></pre><div class=calloutlist>
<ol>
<li><code>handle_data</code> is called with only one argument, the text to process.
<li>In the ancestor <a href="#dialect.basehtml.intro" title="Example 8.8. Introducing BaseHTMLProcessor"><code>BaseHTMLProcessor</code></a>, the <code>handle_data</code> method simply appended the text to the output buffer, <var>self.pieces</var>. Here the logic is only slightly more complicated. If you're in the middle of a <code><code>&lt;pre></code>...<code>&lt;/pre></code></code> block, <var>self.verbatim</var> will be some value greater than <code>0</code>, and you want to put the text in the output buffer unaltered. Otherwise, you will call a separate method to process the
            substitutions, then put the result of that into the output buffer. In Python, this is a one-liner, using <a href="#apihelper.andortrick.intro" title="Example 4.17. Introducing the and-or Trick">the <code>and-or</code> trick</a>.
<p>You're close to completely understanding <code>Dialectizer</code>. The only missing link is the nature of the text substitutions themselves. If you know any Perl, you know that when complex text substitutions are required, the only real solution is regular expressions. The classes
later in <code>dialect.py</code> define a series of regular expressions that operate on the text between the <abbr>HTML</abbr> tags. But you just had <a href="#re" title="Chapter 7. Regular Expressions">a whole chapter on regular expressions</a>. You don't really want to slog through regular expressions again, do you?  God knows I don't. I think you've learned enough
for one chapter.
<h2 id="dialect.alltogether">8.9. Putting it all together</h2>
<p>It's time to put everything you've learned so far to good use. I hope you were paying attention.
<div class=example><h3>Example 8.20. The <code>translate</code> function, part 1</h3><pre><code>
def translate(url, dialectName="chef"): <span>&#x2460;</span>
    import urllib     <span>&#x2461;</span>
    sock = urllib.urlopen(url)          <span>&#x2462;</span>
    htmlSource = sock.read()           
    sock.close()     
</pre><div class=calloutlist>
<ol>
<li>The <code>translate</code> function has an <a href="#apihelper.optional" title="4.2. Using Optional and Named Arguments">optional argument</a> <var>dialectName</var>, which is a string that specifies the dialect you'll be using. You'll see how this is used in a minute.
<li>Hey, wait a minute, there's an <a href="#odbchelper.import" title="Example 2.3. Accessing the buildConnectionString Function's docstring"><code>import</code></a> statement in this function!  That's perfectly legal in Python. You're used to seeing <code>import</code> statements at the top of a program, which means that the imported module is available anywhere in the program. But you can
            also import modules within a function, which means that the imported module is only available within the function. If you
            have a module that is only ever used in one function, this is an easy way to make your code more modular. (When you find
            that your weekend hack has turned into an 800-line work of art and decide to split it up into a dozen reusable modules, you'll
            appreciate this.)
<li>Now you <a href="#dialect.extract.urllib" title="Example 8.5. Introducing urllib">get the source of the given URL</a>.
<div class=example><h3>Example 8.21. The <code>translate</code> function, part 2: curiouser and curiouser</h3><pre><code>
    parserName = "%sDialectizer" % dialectName.capitalize() <span>&#x2460;</span>
    parserClass = globals()[parserName]   <span>&#x2461;</span>
    parser = parserClass()                <span>&#x2462;</span>
</pre><div class=calloutlist>
<ol>
<li><code>capitalize</code> is a string method you haven't seen before; it simply capitalizes the first letter of a string and forces everything else
            to lowercase. Combined with some <a href="#odbchelper.stringformatting" title="3.5. Formatting Strings">string formatting</a>, you've taken the name of a dialect and transformed it into the name of the corresponding Dialectizer class. If <var>dialectName</var> is the string <code>'chef'</code>, <var>parserName</var> will be the string <code>'ChefDialectizer'</code>.
<li>You have the name of a class as a string (<var>parserName</var>), and you have the global namespace as a dictionary (<code>globals</code>()). Combined, you can get a reference to the class which the string names. (Remember, <a href="#fileinfo.classattributes" title="5.8. Introducing Class Attributes">classes are objects</a>, and they can be assigned to variables just like any other object.)  If <var>parserName</var> is the string <code>'ChefDialectizer'</code>, <var>parserClass</var> will be the class <code>ChefDialectizer</code>.
<li>Finally, you have a class object (<var>parserClass</var>), and you want an instance of the class. Well, you already know how to do that: <a href="#fileinfo.create" title="5.4. Instantiating Classes">call the class like a function</a>. The fact that the class is being stored in a local variable makes absolutely no difference; you just call the local variable
            like a function, and out pops an instance of the class. If <var>parserClass</var> is the class <code>ChefDialectizer</code>, <var>parser</var> will be an instance of the class <code>ChefDialectizer</code>.
<p>Why bother?  After all, there are only 3 <code>Dialectizer</code> classes; why not just use a <code>case</code> statement?  (Well, there's no <code>case</code> statement in Python, but why not just use a series of <code>if</code> statements?)  One reason: extensibility. The <code>translate</code> function has absolutely no idea how many Dialectizer classes you've defined. Imagine if you defined a new <code>FooDialectizer</code> tomorrow; <code>translate</code> would work by passing <code>'foo'</code> as the <var>dialectName</var>.
<p>Even better, imagine putting <code>FooDialectizer</code> in a separate module, and importing it with <code>from <var>module</var> import</code>. You've already seen that this <a href="#dialect.globals.example" title="Example 8.11. Introducing globals">includes it in <code>globals</code>()</a>, so <code>translate</code> would still work without modification, even though <code>FooDialectizer</code> was in a separate file.
<p>Now imagine that the name of the dialect is coming from somewhere outside the program, maybe from a database or from a user-inputted
value on a form. You can use any number of server-side Python scripting architectures to dynamically generate web pages; this function could take a <abbr>URL</abbr> and a dialect name (both strings) in the query string of a web page request, and output the &#8220;translated&#8221; web page.
<p>Finally, imagine a <code>Dialectizer</code> framework with a plug-in architecture. You could put each <code>Dialectizer</code> class in a separate file, leaving only the <code>translate</code> function in <code>dialect.py</code>. Assuming a consistent naming scheme, the <code>translate</code> function could dynamic import the appropiate class from the appropriate file, given nothing but the dialect name. (You haven't
seen dynamic importing yet, but I promise to cover it in a later chapter.)  To add a new dialect, you would simply add an
appropriately-named file in the plug-ins directory (like <code>foodialect.py</code> which contains the <code>FooDialectizer</code> class). Calling the <code>translate</code> function with the dialect name <code>'foo'</code> would find the module <code>foodialect.py</code>, import the class <code>FooDialectizer</code>, and away you go.
<div class=example><h3>Example 8.22. The <code>translate</code> function, part 3</h3><pre><code>
    parser.feed(htmlSource) <span>&#x2460;</span>
    parser.close()          <span>&#x2461;</span>
    return parser.output()  <span>&#x2462;</span>
</pre><div class=calloutlist>
<ol>
<li>After all that imagining, this is going to seem pretty boring, but the <code>feed</code> function is what <a href="#dialect.feed.example" title="Example 8.7. Using urllister.py">does the entire transformation</a>. You had the entire <abbr>HTML</abbr> source in a single string, so you only had to call <code>feed</code> once. However, you can call <code>feed</code> as often as you want, and the parser will just keep parsing. So if you were worried about memory usage (or you knew you
            were going to be dealing with very large <abbr>HTML</abbr> pages), you could set this up in a loop, where you read a few bytes of <abbr>HTML</abbr> and fed it to the parser. The result would be the same.
<li>Because <code>feed</code> maintains an internal buffer, you should always call the parser's <code>close</code> method when you're done (even if you fed it all at once, like you did). Otherwise you may find that your output is missing
            the last few bytes.
<li>Remember, <code>output</code> is the function you defined on <code>BaseHTMLProcessor</code> that <a href="#dialect.output.example" title="Example 8.9. BaseHTMLProcessor output">joins all the pieces of output you've buffered</a> and returns them in a single string.
<p>And just like that, you've &#8220;translated&#8221; a web page, given nothing but a <abbr>URL</abbr> and the name of a dialect.
<div class=itemizedlist>
<h3>Further reading</h3>
<ul>
<li>You thought I was kidding about the server-side scripting idea. So did I, until I found <a href="http://rinkworks.com/dialect/">this web-based dialectizer</a>. Unfortunately, source code does not appear to be available.

</ul>
<h2 id="dialect.summary">8.10. Summary</h2>
<p>Python provides you with a powerful tool, <code>sgmllib.py</code>, to manipulate <abbr>HTML</abbr> by turning its structure into an object model. You can use this tool in many different ways.
<div class=itemizedlist>
<ul>
<li>parsing the <abbr>HTML</abbr> looking for something specific

<li>aggregating the results, like the <a href="#dialect.extract.links" title="Example 8.6. Introducing urllister.py"><abbr>URL</abbr> lister</a>
<li>altering the structure along the way, like the <a href="#dialect.quoting.example" title="Example 8.16. Quoting attribute values">attribute quoter</a>
<li>transforming the <abbr>HTML</abbr> into something else by manipulating the text while leaving the tags alone, like the <a href="#dialect.dialectizer" title="8.8. Introducing dialect.py"><code>Dialectizer</code></a>
</ul>
<p>Along with these examples, you should be comfortable doing all of the following things:
<div class=itemizedlist>
<ul>
<li>Using <a href="#dialect.locals" title="8.5. locals and globals"><code>locals</code>() and <code>globals</code>()</a> to access namespaces

<li><a href="#dialect.dictsub" title="8.6. Dictionary-based string formatting">Formatting strings</a> using dictionary-based substitutions

</ul>
<div class=footnotes><br><hr width="100" align="left">
<div class=footnote>
<p><sup>[<a name="ftn.d0e20503" href="#d0e20503">1</a>] </sup>The technical term for a parser like <code>SGMLParser</code> is a <em>consumer</em>: it consumes <abbr>HTML</abbr> and breaks it down. Presumably, the name <code>feed</code> was chosen to fit into the whole &#8220;consumer&#8221; motif. Personally, it makes me think of an exhibit in the zoo where there's just a dark cage with no trees or plants or
   evidence of life of any kind, but if you stand perfectly still and look really closely you can make out two beady eyes staring
   back at you from the far left corner, but you convince yourself that that's just your mind playing tricks on you, and the
   only way you can tell that the whole thing isn't just an empty cage is a small innocuous sign on the railing that reads, &#8220;Do not feed the parser.&#8221;  But maybe that's just me. In any event, it's an interesting mental image.
<div class=footnote>
<p><sup>[<a name="ftn.d0e20702" href="#d0e20702">2</a>] </sup>The reason Python is better at lists than strings is that lists are mutable but strings are immutable. This means that appending to a list
   just adds the element and updates the index. Since strings can not be changed after they are created, code like <code>s = s + newpiece</code> will create an entirely new string out of the concatenation of the original and the new piece, then throw away the original
   string. This involves a lot of expensive memory management, and the amount of effort involved increases as the string gets
   longer, so doing <code>s = s + newpiece</code> in a loop is deadly. In technical terms, appending <var>n</var> items to a list is <code>O(n)</code>, while appending <var>n</var> items to a string is <code>O(n<sup>2</sup>)</code>.
<div class=footnote>
<p><sup>[<a name="ftn.d0e21226" href="#d0e21226">3</a>] </sup>I don't get out much.
<div class=footnote>
<p><sup>[<a name="ftn.d0e21764" href="#d0e21764">4</a>] </sup>All right, it's not that common a question. It's not up there with &#8220;What editor should I use to write Python code?&#8221; (answer: Emacs) or &#8220;Is Python better or worse than Perl?&#8221; (answer: &#8220;Perl is worse than Python because people wanted it worse.&#8221; -Larry Wall, 10/14/1998)  But questions about <abbr>HTML</abbr> processing pop up in one form or another about once a month, and among those questions, this is a popular one.
<div class=chapter>
<h2 id="kgp">Chapter 9. <abbr>XML</abbr> Processing</h2>
<h2 id="kgp.divein">9.1. Diving in</h2>
<p>These next two chapters are about <abbr>XML</abbr> processing in Python. It would be helpful if you already knew what an <abbr>XML</abbr> document looks like, that it's made up of structured tags to form a hierarchy of elements, and so on. If this doesn't make
sense to you, there are <a href="http://directory.google.com/Top/Computers/Data_Formats/Markup_Languages/XML/Resources/FAQs,_Help,_and_Tutorials/">many <abbr>XML</abbr> tutorials</a> that can explain the basics.
<p>If you're not particularly interested in XML, you should still read these chapters, which cover important topics like Python packages, Unicode, command line arguments, and how to use <code>getattr</code> for method dispatching.
<p>Being a philosophy major is not required, although if you have ever had the misfortune of being subjected to the writings
of Immanuel Kant, you will appreciate the example program a lot more than if you majored in something useful, like computer
science.
<p>There are two basic ways to work with <abbr>XML</abbr>. One is called <abbr>SAX</abbr> (&#8220;Simple <abbr>API</abbr> for <abbr>XML</abbr>&#8221;), and it works by reading the <abbr>XML</abbr> a little bit at a time and calling a method for each element it finds. (If you read <a href="#dialect" title="Chapter 8. HTML Processing">Chapter 8, <i>HTML Processing</i></a>, this should sound familiar, because that's how the <code>sgmllib</code> module works.)  The other is called <abbr>DOM</abbr> (&#8220;Document Object Model&#8221;), and it works by reading in the entire <abbr>XML</abbr> document at once and creating an internal representation of it using native Python classes linked in a tree structure. Python has standard modules for both kinds of parsing, but this chapter will only deal with using the <abbr>DOM</abbr>.
<p>The following is a complete Python program which generates pseudo-random output based on a context-free grammar defined in an <abbr>XML</abbr> format. Don't worry yet if you don't understand what that means; you'll examine both the program's input and its output
in more depth throughout these next two chapters.
<div class=example><h3>Example 9.1. <code>kgp.py</code></h3>
<p>If you have not already done so, you can <a href="http://diveintopython3.org/download/diveintopython3-examples-5.4.zip" title="Download example scripts">download this and other examples</a> used in this book.
<pre><code>
"""Kant Generator for Python

Generates mock philosophy based on a context-free grammar

Usage: python kgp.py [options] [source]

Options:
  -g ..., --grammar=...  use specified grammar file or URL
  -h, --help              show this help
  -d    show debugging information while parsing

Examples:
  kgp.pygenerates several paragraphs of Kantian philosophy
  kgp.py -g husserl.xml   generates several paragraphs of Husserl
  kpg.py "&lt;xref id='paragraph'/>"  generates a paragraph of Kant
  kgp.py template.xml     reads from template.xml to decide what to generate
"""
from xml.dom import minidom
import random
import toolbox
import sys
import getopt

_debug = 0

class NoSourceError(Exception): pass

class KantGenerator:
    """generates mock philosophy based on a context-free grammar"""

    def __init__(self, grammar, source=None):
        self.loadGrammar(grammar)
        self.loadSource(source and source or self.getDefaultSource())
        self.refresh()

    def _load(self, source):
        """load XML input source, return parsed XML document

        - a URL of a remote XML file ("http://diveintopython3.org/kant.xml")
        - a filename of a local XML file ("~/diveintopython3/common/py/kant.xml")
        - standard input ("-")
        - the actual XML document, as a string
        """
        sock = toolbox.openAnything(source)
        xmldoc = minidom.parse(sock).documentElement
        sock.close()
        return xmldoc

    def loadGrammar(self, grammar):       
        """load context-free grammar"""   
        self.grammar = self._load(grammar)
        self.refs = {}  
        for ref in self.grammar.getElementsByTagName("ref"):
            self.refs[ref.attributes["id"].value] = ref     

    def loadSource(self, source):
        """load source"""
        self.source = self._load(source)

    def getDefaultSource(self):
        """guess default source of the current grammar
        
        The default source will be one of the &lt;ref>s that is not
        cross-referenced. This sounds complicated but it's not.
        Example: The default source for kant.xml is
        "&lt;xref id='section'/>", because 'section' is the one &lt;ref>
        that is not &lt;xref>'d anywhere in the grammar.
        In most grammars, the default source will produce the
        longest (and most interesting) output.
        """
        xrefs = {}
        for xref in self.grammar.getElementsByTagName("xref"):
            xrefs[xref.attributes["id"].value] = 1
        xrefs = xrefs.keys()
        standaloneXrefs = [e for e in self.refs.keys() if e not in xrefs]
        if not standaloneXrefs:
            raise NoSourceError, "can't guess source, and no source specified"
        return '&lt;xref id="%s"/>' % random.choice(standaloneXrefs)
        
    def reset(self):
        """reset parser"""
        self.pieces = []
        self.capitalizeNextWord = 0

    def refresh(self):
        """reset output buffer, re-parse entire source file, and return output
        
        Since parsing involves a good deal of randomness, this is an
        easy way to get new output without having to reload a grammar file
        each time.
        """
        self.reset()
        self.parse(self.source)
        return self.output()

    def output(self):
        """output generated text"""
        return "".join(self.pieces)

    def randomChildElement(self, node):
        """choose a random child element of a node
        
        This is a utility method used by do_xref and do_choice.
        """
        choices = [e for e in node.childNodes
 if e.nodeType == e.ELEMENT_NODE]
        chosen = random.choice(choices)            
        if _debug:               
            sys.stderr.write('%s available choices: %s\n' % \
                (len(choices), [e.toxml() for e in choices]))
            sys.stderr.write('Chosen: %s\n' % chosen.toxml())
        return chosen            

    def parse(self, node):         
        """parse a single XML node
        
        A parsed XML document (from minidom.parse) is a tree of nodes
        of various types. Each node is represented by an instance of the
        corresponding Python class (Element for a tag, Text for
        text data, Document for the top-level document). The following
        statement constructs the name of a class method based on the type
        of node we're parsing ("parse_Element" for an Element node,
        "parse_Text" for a Text node, etc.) and then calls the method.
        """
        parseMethod = getattr(self, "parse_%s" % node.__class__.__name__)
        parseMethod(node)

    def parse_Document(self, node):
        """parse the document node
        
        The document node by itself isn't interesting (to us), but
        its only child, node.documentElement, is: it's the root node
        of the grammar.
        """
        self.parse(node.documentElement)

    def parse_Text(self, node):    
        """parse a text node
        
        The text of a text node is usually added to the output buffer
        verbatim. The one exception is that &lt;p class='sentence'> sets
        a flag to capitalize the first letter of the next word. If
        that flag is set, we capitalize the text and reset the flag.
        """
        text = node.data
        if self.capitalizeNextWord:
            self.pieces.append(text[0].upper())
            self.pieces.append(text[1:])
            self.capitalizeNextWord = 0
        else:
            self.pieces.append(text)

    def parse_Element(self, node): 
        """parse an element
        
        An XML element corresponds to an actual tag in the source:
        &lt;xref id='...'>, &lt;p chance='...'>, &lt;choice>, etc.
        Each element type is handled in its own method. Like we did in
        parse(), we construct a method name based on the name of the
        element ("do_xref" for an &lt;xref> tag, etc.) and
        call the method.
        """
        handlerMethod = getattr(self, "do_%s" % node.tagName)
        handlerMethod(node)

    def parse_Comment(self, node):
        """parse a comment
        
        The grammar can contain XML comments, but we ignore them
        """
        pass
    
    def do_xref(self, node):
        """handle &lt;xref id='...'> tag
        
        An &lt;xref id='...'> tag is a cross-reference to a &lt;ref id='...'>
        tag. &lt;xref id='sentence'/> evaluates to a randomly chosen child of
        &lt;ref id='sentence'>.
        """
        id = node.attributes["id"].value
        self.parse(self.randomChildElement(self.refs[id]))

    def do_p(self, node):
        """handle &lt;p> tag
        
        The &lt;p> tag is the core of the grammar. It can contain almost
        anything: freeform text, &lt;choice> tags, &lt;xref> tags, even other
        &lt;p> tags. If a "class='sentence'" attribute is found, a flag
        is set and the next word will be capitalized. If a "chance='X'"
        attribute is found, there is an X% chance that the tag will be
        evaluated (and therefore a (100-X)% chance that it will be
        completely ignored)
        """
        keys = node.attributes.keys()
        if "class" in keys:
            if node.attributes["class"].value == "sentence":
                self.capitalizeNextWord = 1
        if "chance" in keys:
            chance = int(node.attributes["chance"].value)
            doit = (chance > random.randrange(100))
        else:
            doit = 1
        if doit:
            for child in node.childNodes: self.parse(child)

    def do_choice(self, node):
        """handle &lt;choice> tag
        
        A &lt;choice> tag contains one or more &lt;p> tags. One &lt;p> tag
        is chosen at random and evaluated; the rest are ignored.
        """
        self.parse(self.randomChildElement(node))

def usage():
    print __doc__

def main(argv):       
    grammar = "kant.xml"                
    try:              
        opts, args = getopt.getopt(argv, "hg:d", ["help", "grammar="])
    except getopt.GetoptError:          
        usage()       
        sys.exit(2)   
    for opt, arg in opts:               
        if opt in ("-h", "--help"):     
            usage()   
            sys.exit()
        elif opt == '-d':               
            global _debug               
            _debug = 1
        elif opt in ("-g", "--grammar"):
            grammar = arg               
    
    source = "".join(args)              

    k = KantGenerator(grammar, source)
    print k.output()

if __name__ == "__main__":
    main(sys.argv[1:])
</pre><div class=example><h3>Example 9.2. <code>toolbox.py</code></h3><pre><code>
"""Miscellaneous utility functions"""

def openAnything(source):            
    """URI, filename, or string --> stream

    This function lets you define parsers that take any input source
    (URL, pathname to local or network file, or actual data as a string)
    and deal with it in a uniform manner. Returned object is guaranteed
    to have all the basic stdio read methods (read, readline, readlines).
    Just .close() the object when you're done with it.
    
    Examples:
    >>> from xml.dom import minidom
    >>> sock = openAnything("http://localhost/kant.xml")
    >>> doc = minidom.parse(sock)
    >>> sock.close()
    >>> sock = openAnything("c:\\inetpub\\wwwroot\\kant.xml")
    >>> doc = minidom.parse(sock)
    >>> sock.close()
    >>> sock = openAnything("&lt;ref id='conjunction'>&lt;text>and&lt;/text>&lt;text>or&lt;/text>&lt;/ref>")
    >>> doc = minidom.parse(sock)
    >>> sock.close()
    """
    if hasattr(source, "read"):
        return source

    if source == '-':
        import sys
        return sys.stdin

    # try to open with urllib (if source is http, ftp, or file URL)
    import urllib       
    try:                
        return urllib.urlopen(source)     
    except (IOError, OSError):            
        pass            
    
    # try to open with native open function (if source is pathname)
    try:                
        return open(source)               
    except (IOError, OSError):            
        pass            
    
    # treat source as string
    import StringIO     
    return StringIO.StringIO(str(source)) 
</pre><p>Run the program <code>kgp.py</code> by itself, and it will parse the default <abbr>XML</abbr>-based grammar, in <code>kant.xml</code>, and print several paragraphs worth of philosophy in the style of Immanuel Kant.
<div class=example><h3>Example 9.3. Sample output of <code>kgp.py</code></h3><pre class=screen><samp class=prompt>[you@localhost kgp]$ python kgp.py</samp>
<samp>     As is shown in the writings of Hume, our a priori concepts, in
reference to ends, abstract from all content of knowledge; in the study
of space, the discipline of human reason, in accordance with the
principles of philosophy, is the clue to the discovery of the
Transcendental Deduction. The transcendental aesthetic, in all
theoretical sciences, occupies part of the sphere of human reason
concerning the existence of our ideas in general; still, the
never-ending regress in the series of empirical conditions constitutes
the whole content for the transcendental unity of apperception. What
we have alone been able to show is that, even as this relates to the
architectonic of human reason, the Ideal may not contradict itself, but
it is still possible that it may be in contradictions with the
employment of the pure employment of our hypothetical judgements, but
natural causes (and I assert that this is the case) prove the validity
of the discipline of pure reason. As we have already seen, time (and
it is obvious that this is true) proves the validity of time, and the
architectonic of human reason, in the full sense of these terms,
abstracts from all content of knowledge. I assert, in the case of the
discipline of practical reason, that the Antinomies are just as
necessary as natural causes, since knowledge of the phenomena is a
posteriori.
    The discipline of human reason, as I have elsewhere shown, is by
its very nature contradictory, but our ideas exclude the possibility of
the Antinomies. We can deduce that, on the contrary, the pure
employment of philosophy, on the contrary, is by its very nature
contradictory, but our sense perceptions are a representation of, in
the case of space, metaphysics. The thing in itself is a
representation of philosophy. Applied logic is the clue to the
discovery of natural causes. However, what we have alone been able to
show is that our ideas, in other words, should only be used as a canon
for the Ideal, because of our necessary ignorance of the conditions.

[...snip...]</span></pre><p>This is, of course, complete gibberish. Well, not complete gibberish. It is syntactically and grammatically correct (although
very verbose -- Kant wasn't what you would call a get-to-the-point kind of guy). Some of it may actually be true (or at least
the sort of thing that Kant would have agreed with), some of it is blatantly false, and most of it is simply incoherent. 
But all of it is in the style of Immanuel Kant.
<p>Let me repeat that this is much, much funnier if you are now or have ever been a philosophy major.
<p>The interesting thing about this program is that there is nothing Kant-specific about it. All the content in the previous
example was derived from the grammar file, <code>kant.xml</code>. If you tell the program to use a different grammar file (which you can specify on the command line), the output will be
completely different.
<div class=example><h3>Example 9.4. Simpler output from <code>kgp.py</code></h3><pre class=screen><samp class=prompt>[you@localhost kgp]$ python kgp.py -g binary.xml</samp>
00101001
<samp class=prompt>[you@localhost kgp]$ python kgp.py -g binary.xml</samp>
10110100</pre><p>You will take a closer look at the structure of the grammar file later in this chapter. For now, all you need to know is
that the grammar file defines the structure of the output, and the <code>kgp.py</code> program reads through the grammar and makes random decisions about which words to plug in where.
<h2 id="kgp.packages">9.2. Packages</h2>
<p>Actually parsing an <abbr>XML</abbr> document is very simple: one line of code. However, before you get to that line of code, you need to take a short detour
   to talk about packages.
<div class=example><h3>Example 9.5. Loading an <abbr>XML</abbr> document (a sneak peek)</h3><pre class=screen>
<samp class=prompt>>>> </samp><kbd>from xml.dom import minidom</kbd> <span>&#x2460;</span>
<samp class=prompt>>>> </samp>xmldoc = minidom.parse('~/diveintopython3/common/py/kgp/binary.xml')</pre><div class=calloutlist>
<ol>
<li>This is a syntax you haven't seen before. It looks almost like the <code>from <var>module</var> import</code> you know and love, but the <code>"."</code> gives it away as something above and beyond a simple import. In fact, <code>xml</code> is what is known as a package, <code>dom</code> is a nested package within <code>xml</code>, and <code>minidom</code> is a module within <code>xml.dom</code>.
<p>That sounds complicated, but it's really not. Looking at the actual implementation may help. Packages are little more than
directories of modules; nested packages are subdirectories. The modules within a package (or a nested package) are still
just <code>.py</code> files, like always, except that they're in a subdirectory instead of the main <code>lib/</code> directory of your Python installation.
<div class=example><h3>Example 9.6. File layout of a package</h3><pre class=screen>Python21/           root Python installation (home of the executable)
|
+--lib/             library directory (home of the standard library modules)
   |
   +-- xml/         xml package (really just a directory with other stuff in it)
       |
       +--sax/      xml.sax package (again, just a directory)
       |
       +--dom/      xml.dom package (contains minidom.py)
       |
       +--parsers/  xml.parsers package (used internally)</pre><p>So when you say <code>from xml.dom import minidom</code>, Python figures out that that means &#8220;look in the <code>xml</code> directory for a <code>dom</code> directory, and look in <em>that</em> for the <code>minidom</code> module, and import it as <code>minidom</code>&#8221;. But Python is even smarter than that; not only can you import entire modules contained within a package, you can selectively import
specific classes or functions from a module contained within a package. You can also import the package itself as a module.
The syntax is all the same; Python figures out what you mean based on the file layout of the package, and automatically does the right thing.
<div class=example><h3>Example 9.7. Packages are modules, too</h3><pre class=screen><samp class=prompt>>>> </samp><kbd>from xml.dom import minidom</kbd>         <span>&#x2460;</span>
<samp class=prompt>>>> </samp><kbd>minidom</kbd>
&lt;module 'xml.dom.minidom' from 'C:\Python21\lib\xml\dom\minidom.pyc'>
<samp class=prompt>>>> </samp><kbd>minidom.Element</kbd>
&lt;class xml.dom.minidom.Element at 01095744>
<samp class=prompt>>>> </samp><kbd>from xml.dom.minidom import Element</kbd> <span>&#x2461;</span>
<samp class=prompt>>>> </samp><kbd>Element</kbd>
&lt;class xml.dom.minidom.Element at 01095744>
<samp class=prompt>>>> </samp><kbd>minidom.Element</kbd>
&lt;class xml.dom.minidom.Element at 01095744>
<samp class=prompt>>>> </samp><kbd>from xml import dom</kbd>                 <span>&#x2462;</span>
<samp class=prompt>>>> </samp><kbd>dom</kbd>
&lt;module 'xml.dom' from 'C:\Python21\lib\xml\dom\__init__.pyc'>
<samp class=prompt>>>> </samp><kbd>import xml</kbd>        <span>&#x2463;</span>
<samp class=prompt>>>> </samp><kbd>xml</kbd>
&lt;module 'xml' from 'C:\Python21\lib\xml\__init__.pyc'></pre><div class=calloutlist>
<ol>
<li>Here you're importing a module (<code>minidom</code>) from a nested package (<code>xml.dom</code>). The result is that <code>minidom</code> is imported into your <a href="#dialect.locals" title="8.5. locals and globals">namespace</a>, and in order to reference classes within the <code>minidom</code> module (like <code>Element</code>), you need to preface them with the module name.
<li>Here you are importing a class (<code>Element</code>) from a module (<code>minidom</code>) from a nested package (<code>xml.dom</code>). The result is that <code>Element</code> is imported directly into your namespace. Note that this does not interfere with the previous import; the <code>Element</code> class can now be referenced in two ways (but it's all still the same class).
<li>Here you are importing the <code>dom</code> package (a nested package of <code>xml</code>) as a module in and of itself. Any level of a package can be treated as a module, as you'll see in a moment. It can even
            have its own attributes and methods, just the modules you've seen before.
<li>Here you are importing the root level <code>xml</code> package as a module.
<p>So how can a package (which is just a directory on disk) be imported and treated as a module (which is always a file on disk)?
The answer is the magical <code>__init__.py</code> file. You see, packages are not simply directories; they are directories with a specific file, <code>__init__.py</code>, inside. This file defines the attributes and methods of the package. For instance, <code>xml.dom</code> contains a <code>Node</code> class, which is defined in <code>xml/dom/__init__.py</code>. When you import a package as a module (like <code>dom</code> from <code>xml</code>), you're really importing its <code>__init__.py</code> file.
<table class=note border="0" summary="">

<td rowspan="2" align="center" valign="top" width="1%"><img src="images/note.png" alt="Note" title="" width="24" height="24"><td colspan="2" align="left" valign="top" width="99%">A package is a directory with the special <code>__init__.py</code> file in it. The <code>__init__.py</code> file defines the attributes and methods of the package. It doesn't need to define anything; it can just be an empty file,
      but it has to exist. But if <code>__init__.py</code> doesn't exist, the directory is just a directory, not a package, and it can't be imported or contain modules or nested packages.
<p>So why bother with packages?  Well, they provide a way to logically group related modules. Instead of having an <code>xml</code> package with <code>sax</code> and <code>dom</code> packages inside, the authors could have chosen to put all the <code>sax</code> functionality in <code>xmlsax.py</code> and all the <code>dom</code> functionality in <code>xmldom.py</code>, or even put all of it in a single module. But that would have been unwieldy (as of this writing, the <abbr>XML</abbr> package has over 3000 lines of code) and difficult to manage (separate source files mean multiple people can work on different
areas simultaneously).
<p>If you ever find yourself writing a large subsystem in Python (or, more likely, when you realize that your small subsystem has grown into a large one), invest some time designing a good
package architecture. It's one of the many things Python is good at, so take advantage of it.
<h2 id="kgp.parse">9.3. Parsing <abbr>XML</abbr></h2>
<p>As I was saying, actually parsing an <abbr>XML</abbr> document is very simple: one line of code. Where you go from there is up to you.
<div class=example><h3>Example 9.8. Loading an <abbr>XML</abbr> document (for real this time)</h3><pre class=screen>
<samp class=prompt>>>> </samp><kbd>from xml.dom import minidom</kbd>      <span>&#x2460;</span>
<samp class=prompt>>>> </samp><kbd>xmldoc = minidom.parse('~/diveintopython3/common/py/kgp/binary.xml')</kbd>  <span>&#x2461;</span>
<samp class=prompt>>>> </samp><kbd>xmldoc</kbd>         <span>&#x2462;</span>
&lt;xml.dom.minidom.Document instance at 010BE87C>
<samp class=prompt>>>> </samp><kbd>print xmldoc.toxml()</kbd>             <span>&#x2463;</span>
<samp>&lt;?xml version="1.0" ?>
&lt;grammar>
&lt;ref id="bit">
  &lt;p>0&lt;/p>
  &lt;p>1&lt;/p>
&lt;/ref>
&lt;ref id="byte">
  &lt;p>&lt;xref id="bit"/>&lt;xref id="bit"/>&lt;xref id="bit"/>&lt;xref id="bit"/>\
&lt;xref id="bit"/>&lt;xref id="bit"/>&lt;xref id="bit"/>&lt;xref id="bit"/>&lt;/p>
&lt;/ref>
&lt;/grammar></span></pre><div class=calloutlist>
<ol>
<li>As you saw in the <a href="#kgp.packages" title="9.2. Packages">previous section</a>, this imports the <code>minidom</code> module from the <code>xml.dom</code> package.
<li>Here is the one line of code that does all the work: <code>minidom.parse</code> takes one argument and returns a parsed representation of the <abbr>XML</abbr> document. The argument can be many things; in this case, it's simply a filename of an <abbr>XML</abbr> document on my local disk. (To follow along, you'll need to change the path to point to your downloaded examples directory.)
             But you can also pass a <a href="#fileinfo.files" title="6.2. Working with File Objects">file object</a>, or even a <a href="#dialect.extract.urllib" title="Example 8.5. Introducing urllib">file-like object</a>. You'll take advantage of this flexibility later in this chapter.
<li>The object returned from <code>minidom.parse</code> is a <code>Document</code> object, a descendant of the <code>Node</code> class. This <code>Document</code> object is the root level of a complex tree-like structure of interlocking Python objects that completely represent the <abbr>XML</abbr> document you passed to <code>minidom.parse</code>.
<li><code>toxml</code> is a method of the <code>Node</code> class (and is therefore available on the <code>Document</code> object you got from <code>minidom.parse</code>). <code>toxml</code> prints out the <abbr>XML</abbr> that this <code>Node</code> represents. For the <code>Document</code> node, this prints out the entire <abbr>XML</abbr> document.
<p>Now that you have an <abbr>XML</abbr> document in memory, you can start traversing through it.
<div class=example><h3 id="kgp.parse.gettingchildnodes.example">Example 9.9. Getting child nodes</h3><pre class=screen>
<samp class=prompt>>>> </samp><kbd>xmldoc.childNodes</kbd>    <span>&#x2460;</span>
[&lt;DOM Element: grammar at 17538908>]
<samp class=prompt>>>> </samp><kbd>xmldoc.childNodes[0]</kbd> <span>&#x2461;</span>
&lt;DOM Element: grammar at 17538908>
<samp class=prompt>>>> </samp><kbd>xmldoc.firstChild</kbd>    <span>&#x2462;</span>
&lt;DOM Element: grammar at 17538908></pre><div class=calloutlist>
<ol>
<li>Every <code>Node</code> has a <code>childNodes</code> attribute, which is a list of the <code>Node</code> objects. A <code>Document</code> always has only one child node, the root element of the <abbr>XML</abbr> document (in this case, the <code>grammar</code> element).
<li>To get the first (and in this case, the only) child node, just use regular list syntax. Remember, there is nothing special
            going on here; this is just a regular Python list of regular Python objects.
<li>Since getting the first child node of a node is a useful and common activity, the <code>Node</code> class has a <code>firstChild</code> attribute, which is synonymous with <code>childNodes[0]</code>. (There is also a <code>lastChild</code> attribute, which is synonymous with <code>childNodes[-1]</code>.)
<div class=example><h3>Example 9.10. <code>toxml</code> works on any node</h3><pre class=screen>
<samp class=prompt>>>> </samp><kbd>grammarNode = xmldoc.firstChild</kbd>
<samp class=prompt>>>> </samp><kbd>print grammarNode.toxml()</kbd> <span>&#x2460;</span>
<samp>&lt;grammar>
&lt;ref id="bit">
  &lt;p>0&lt;/p>
  &lt;p>1&lt;/p>
&lt;/ref>
&lt;ref id="byte">
  &lt;p>&lt;xref id="bit"/>&lt;xref id="bit"/>&lt;xref id="bit"/>&lt;xref id="bit"/>\
&lt;xref id="bit"/>&lt;xref id="bit"/>&lt;xref id="bit"/>&lt;xref id="bit"/>&lt;/p>
&lt;/ref>
&lt;/grammar></span></pre><div class=calloutlist>
<ol>
<li>Since the <code>toxml</code> method is defined in the <code>Node</code> class, it is available on any <abbr>XML</abbr> node, not just the <code>Document</code> element.
<div class=example><h3 id="kgp.parse.childnodescanbetext.example">Example 9.11. Child nodes can be text</h3><pre class=screen>
<samp class=prompt>>>> </samp><kbd>grammarNode.childNodes</kbd><span>&#x2460;</span>
<samp>[&lt;DOM Text node "\n">, &lt;DOM Element: ref at 17533332>, \
&lt;DOM Text node "\n">, &lt;DOM Element: ref at 17549660>, &lt;DOM Text node "\n">]</samp>
<samp class=prompt>>>> </samp><kbd>print grammarNode.firstChild.toxml()</kbd>    <span>&#x2461;</span>
<samp>

</samp>
<samp class=prompt>>>> </samp><kbd>print grammarNode.childNodes[1].toxml()</kbd> <span>&#x2462;</span>
<samp>&lt;ref id="bit">
  &lt;p>0&lt;/p>
  &lt;p>1&lt;/p>
&lt;/ref></samp>
<samp class=prompt>>>> </samp><kbd>print grammarNode.childNodes[3].toxml()</kbd> <span>&#x2463;</span>
<samp>&lt;ref id="byte">
  &lt;p>&lt;xref id="bit"/>&lt;xref id="bit"/>&lt;xref id="bit"/>&lt;xref id="bit"/>\
&lt;xref id="bit"/>&lt;xref id="bit"/>&lt;xref id="bit"/>&lt;xref id="bit"/>&lt;/p>
&lt;/ref></samp>
<samp class=prompt>>>> </samp><kbd>print grammarNode.lastChild.toxml()</kbd>     <span>&#x2464;</span>
<samp>

</span></pre><div class=calloutlist>
<ol>
<li>Looking at the <abbr>XML</abbr> in <code>binary.xml</code>, you might think that the <code>grammar</code> has only two child nodes, the two <code>ref</code> elements. But you're missing something: the carriage returns!  After the <code>'&lt;grammar>'</code> and before the first <code>'&lt;ref>'</code> is a carriage return, and this text counts as a child node of the <code>grammar</code> element. Similarly, there is a carriage return after each <code>'&lt;/ref>'</code>; these also count as child nodes. So <code>grammar.childNodes</code> is actually a list of 5 objects: 3 <code>Text</code> objects and 2 <code>Element</code> objects.
<li>The first child is a <code>Text</code> object representing the carriage return after the <code>'&lt;grammar>'</code> tag and before the first <code>'&lt;ref>'</code> tag.
<li>The second child is an <code>Element</code> object representing the first <code>ref</code> element.
<li>The fourth child is an <code>Element</code> object representing the second <code>ref</code> element.
<li>The last child is a <code>Text</code> object representing the carriage return after the <code>'&lt;/ref>'</code> end tag and before the <code>'&lt;/grammar>'</code> end tag.
<div class=example><h3>Example 9.12. Drilling down all the way to text</h3><pre class=screen>
<samp class=prompt>>>> </samp><kbd>grammarNode</kbd>
&lt;DOM Element: grammar at 19167148>
<samp class=prompt>>>> </samp><kbd>refNode = grammarNode.childNodes[1]</kbd> <span>&#x2460;</span>
<samp class=prompt>>>> </samp><kbd>refNode</kbd>
&lt;DOM Element: ref at 17987740>
<samp class=prompt>>>> </samp><kbd>refNode.childNodes</kbd><span>&#x2461;</span>
<samp>[&lt;DOM Text node "\n">, &lt;DOM Text node "  ">, &lt;DOM Element: p at 19315844>, \
&lt;DOM Text node "\n">, &lt;DOM Text node "  ">, \
&lt;DOM Element: p at 19462036>, &lt;DOM Text node "\n">]</samp>
<samp class=prompt>>>> </samp><kbd>pNode = refNode.childNodes[2]</kbd>
<samp class=prompt>>>> </samp><kbd>pNode</kbd>
&lt;DOM Element: p at 19315844>
<samp class=prompt>>>> </samp><kbd>print pNode.toxml()</kbd>                 <span>&#x2462;</span>
&lt;p>0&lt;/p>
<samp class=prompt>>>> </samp><kbd>pNode.firstChild</kbd>  <span>&#x2463;</span>
&lt;DOM Text node "0">
<samp class=prompt>>>> </samp><kbd>pNode.firstChild.data</kbd>               <span>&#x2464;</span>
u'0'</pre><div class=calloutlist>
<ol>
<li>As you saw in the previous example, the first <code>ref</code> element is <code>grammarNode.childNodes[1]</code>, since childNodes[0] is a <code>Text</code> node for the carriage return.
<li>The <code>ref</code> element has its own set of child nodes, one for the carriage return, a separate one for the spaces, one for the <code>p</code> element, and so forth.
<li>You can even use the <code>toxml</code> method here, deeply nested within the document.
<li>The <code>p</code> element has only one child node (you can't tell that from this example, but look at <code>pNode.childNodes</code> if you don't believe me), and it is a <code>Text</code> node for the single character <code>'0'</code>.
<li>The <code>.data</code> attribute of a <code>Text</code> node gives you the actual string that the text node represents. But what is that <code>'u'</code> in front of the string?  The answer to that deserves its own section.






(Unicode stuff was here)








<p>Remember I said Python usually converted unicode to <abbr>ASCII</abbr> whenever it needed to make a regular string out of a unicode string?  Well, this default encoding scheme is an option which
you can customize.
<div class=example><h3>Example 9.15. <code>sitecustomize.py</code></h3><pre><code>
# sitecustomize.py <span>&#x2460;</span>
# this file can be anywhere in your Python path,
# but it usually goes in ${pythondir}/lib/site-packages/
import sys
sys.setdefaultencoding('iso-8859-1') <span>&#x2461;</span>
</pre><div class=calloutlist>
<ol>
<li><code>sitecustomize.py</code> is a special script; Python will try to import it on startup, so any code in it will be run automatically. As the comment mentions, it can go anywhere
            (as long as <code>import</code> can find it), but it usually goes in the <code>site-packages</code> directory within your Python <code>lib</code> directory.
<li><code>setdefaultencoding</code> function sets, well, the default encoding. This is the encoding scheme that Python will try to use whenever it needs to auto-coerce a unicode string into a regular string.
<div class=example><h3>Example 9.16. Effects of setting the default encoding</h3><pre class=screen>
<samp class=prompt>>>> </samp><kbd>import sys</kbd>
<samp class=prompt>>>> </samp><kbd>sys.getdefaultencoding()</kbd> <span>&#x2460;</span>
'iso-8859-1'
<samp class=prompt>>>> </samp><kbd>s = u'La Pe\xf1a'</kbd>
<samp class=prompt>>>> </samp><kbd>print s</kbd><span>&#x2461;</span>
La Pe&ntilde;a</pre><div class=calloutlist>
<ol>
<li>This example assumes that you have made the changes listed in the previous example to your <code>sitecustomize.py</code> file, and restarted Python. If your default encoding still says <code>'ascii'</code>, you didn't set up your <code>sitecustomize.py</code> properly, or you didn't restart Python. The default encoding can only be changed during Python startup; you can't change it later. (Due to some wacky programming tricks that I won't get into right now, you can't even
            call <code>sys.setdefaultencoding</code> after Python has started up. Dig into <code>site.py</code> and search for &#8220;<code>setdefaultencoding</code>&#8221; to find out how.)
<li>Now that the default encoding scheme includes all the characters you use in your string, Python has no problem auto-coercing the string and printing it.





(More Unicode stuff was here)







<h2 id="kgp.search">9.5. Searching for elements</h2>
<p>Traversing <abbr>XML</abbr> documents by stepping through each node can be tedious. If you're looking for something in particular, buried deep within
   your <abbr>XML</abbr> document, there is a shortcut you can use to find it quickly: <code>getElementsByTagName</code>.
<p>For this section, you'll be using the <code>binary.xml</code> grammar file, which looks like this:
<div class=example><h3>Example 9.20. <code>binary.xml</code></h3><pre class=screen><samp>&lt;?xml version="1.0"?>
&lt;!DOCTYPE grammar PUBLIC "-//diveintopython3.org//DTD Kant Generator Pro v1.0//EN" "kgp.dtd">
&lt;grammar>
&lt;ref id="bit">
  &lt;p>0&lt;/p>
  &lt;p>1&lt;/p>
&lt;/ref>
&lt;ref id="byte">
  &lt;p>&lt;xref id="bit"/>&lt;xref id="bit"/>&lt;xref id="bit"/>&lt;xref id="bit"/>\
&lt;xref id="bit"/>&lt;xref id="bit"/>&lt;xref id="bit"/>&lt;xref id="bit"/>&lt;/p>
&lt;/ref>
&lt;/grammar></span></pre><p>It has two <code>ref</code>s, <code>'bit'</code> and <code>'byte'</code>. A <code>bit</code> is either a <code>'0'</code> or <code>'1'</code>, and a <code>byte</code> is 8 <code>bit</code>s.
<div class=example><h3>Example 9.21. Introducing <code>getElementsByTagName</code></h3><pre class=screen>
<samp class=prompt>>>> </samp><kbd>from xml.dom import minidom</kbd>
<samp class=prompt>>>> </samp><kbd>xmldoc = minidom.parse('binary.xml')</kbd>
<samp class=prompt>>>> </samp><kbd>reflist = xmldoc.getElementsByTagName('ref')</kbd> <span>&#x2460;</span>
<samp class=prompt>>>> </samp><kbd>reflist</kbd>
[&lt;DOM Element: ref at 136138108>, &lt;DOM Element: ref at 136144292>]
<samp class=prompt>>>> </samp><kbd>print reflist[0].toxml()</kbd>
<samp>&lt;ref id="bit">
  &lt;p>0&lt;/p>
  &lt;p>1&lt;/p>
&lt;/ref></samp>
<samp class=prompt>>>> </samp><kbd>print reflist[1].toxml()</kbd>
<samp>&lt;ref id="byte">
  &lt;p>&lt;xref id="bit"/>&lt;xref id="bit"/>&lt;xref id="bit"/>&lt;xref id="bit"/>\
&lt;xref id="bit"/>&lt;xref id="bit"/>&lt;xref id="bit"/>&lt;xref id="bit"/>&lt;/p>
&lt;/ref>
</span></pre><div class=calloutlist>
<ol>
<li><code>getElementsByTagName</code> takes one argument, the name of the element you wish to find. It returns a list of <code>Element</code> objects, corresponding to the <abbr>XML</abbr> elements that have that name. In this case, you find two <code>ref</code> elements.
<div class=example><h3>Example 9.22. Every element is searchable</h3><pre class=screen>
<samp class=prompt>>>> </samp><kbd>firstref = reflist[0]</kbd>    <span>&#x2460;</span>
<samp class=prompt>>>> </samp><kbd>print firstref.toxml()</kbd>
<samp>&lt;ref id="bit">
  &lt;p>0&lt;/p>
  &lt;p>1&lt;/p>
&lt;/ref></samp>
<samp class=prompt>>>> </samp><kbd>plist = firstref.getElementsByTagName("p")</kbd> <span>&#x2461;</span>
<samp class=prompt>>>> </samp><kbd>plist</kbd>
[&lt;DOM Element: p at 136140116>, &lt;DOM Element: p at 136142172>]
<samp class=prompt>>>> </samp><kbd>print plist[0].toxml()</kbd>   <span>&#x2462;</span>
&lt;p>0&lt;/p>
<samp class=prompt>>>> </samp><kbd>print plist[1].toxml()</kbd>
&lt;p>1&lt;/p></pre><div class=calloutlist>
<ol>
<li>Continuing from the previous example, the first object in your <var>reflist</var> is the <code>'bit'</code> <code>ref</code> element.
<li>You can use the same <code>getElementsByTagName</code> method on this <code>Element</code> to find all the <code>&lt;p></code> elements within the <code>'bit'</code> <code>ref</code> element.
<li>Just as before, the <code>getElementsByTagName</code> method returns a list of all the elements it found. In this case, you have two, one for each bit.
<div class=example><h3>Example 9.23. Searching is actually recursive</h3><pre class=screen>
<samp class=prompt>>>> </samp><kbd>plist = xmldoc.getElementsByTagName("p")</kbd> <span>&#x2460;</span>
<samp class=prompt>>>> </samp><kbd>plist</kbd>
[&lt;DOM Element: p at 136140116>, &lt;DOM Element: p at 136142172>, &lt;DOM Element: p at 136146124>]
<samp class=prompt>>>> </samp><kbd>plist[0].toxml()</kbd>       <span>&#x2461;</span>
'&lt;p>0&lt;/p>'
<samp class=prompt>>>> </samp><kbd>plist[1].toxml()</kbd>
'&lt;p>1&lt;/p>'
<samp class=prompt>>>> </samp><kbd>plist[2].toxml()</kbd>       <span>&#x2462;</span>
<samp>'&lt;p>&lt;xref id="bit"/>&lt;xref id="bit"/>&lt;xref id="bit"/>&lt;xref id="bit"/>\
&lt;xref id="bit"/>&lt;xref id="bit"/>&lt;xref id="bit"/>&lt;xref id="bit"/>&lt;/p>'</span></pre><div class=calloutlist>
<ol>
<li>Note carefully the difference between this and the previous example. Previously, you were searching for <code>p</code> elements within <var>firstref</var>, but here you are searching for <code>p</code> elements within <var>xmldoc</var>, the root-level object that represents the entire <abbr>XML</abbr> document. This <em>does</em> find the <code>p</code> elements nested within the <code>ref</code> elements within the root <code>grammar</code> element.
<li>The first two <code>p</code> elements are within the first <code>ref</code> (the <code>'bit'</code> <code>ref</code>).
<li>The last <code>p</code> element is the one within the second <code>ref</code> (the <code>'byte'</code> <code>ref</code>).
<h2 id="kgp.attributes">9.6. Accessing element attributes</h2>
<p><abbr>XML</abbr> elements can have one or more attributes, and it is incredibly simple to access them once you have parsed an <abbr>XML</abbr> document.
<p>For this section, you'll be using the <code>binary.xml</code> grammar file that you saw in the <a href="#kgp.search" title="9.5. Searching for elements">previous section</a>.
<table class=note border="0" summary="">

<td rowspan="2" align="center" valign="top" width="1%"><img src="images/note.png" alt="Note" title="" width="24" height="24"><td colspan="2" align="left" valign="top" width="99%">This section may be a little confusing, because of some overlapping terminology. Elements in an <abbr>XML</abbr> document have attributes, and Python objects also have attributes. When you parse an <abbr>XML</abbr> document, you get a bunch of Python objects that represent all the pieces of the <abbr>XML</abbr> document, and some of these Python objects represent attributes of the <abbr>XML</abbr> elements. But the (Python) objects that represent the (<abbr>XML</abbr>) attributes also have (Python) attributes, which are used to access various parts of the (<abbr>XML</abbr>) attribute that the object represents. I told you it was confusing. I am open to suggestions on how to distinguish these
      more clearly.
<div class=example><h3>Example 9.24. Accessing element attributes</h3><pre class=screen>
<samp class=prompt>>>> </samp><kbd>xmldoc = minidom.parse('binary.xml')</kbd>
<samp class=prompt>>>> </samp><kbd>reflist = xmldoc.getElementsByTagName('ref')</kbd>
<samp class=prompt>>>> </samp><kbd>bitref = reflist[0]</kbd>
<samp class=prompt>>>> </samp><kbd>print bitref.toxml()</kbd>
<samp>&lt;ref id="bit">
  &lt;p>0&lt;/p>
  &lt;p>1&lt;/p>
&lt;/ref></samp>
<samp class=prompt>>>> </samp><kbd>bitref.attributes</kbd>          <span>&#x2460;</span>
&lt;xml.dom.minidom.NamedNodeMap instance at 0x81e0c9c>
<samp class=prompt>>>> </samp><kbd>bitref.attributes.keys()</kbd>   <span>&#x2461;</span> <span>&#x2462;</span>
[u'id']
<samp class=prompt>>>> </samp><kbd>bitref.attributes.values()</kbd> <span>&#x2463;</span>
[&lt;xml.dom.minidom.Attr instance at 0x81d5044>]
<samp class=prompt>>>> </samp><kbd>bitref.attributes["id"]</kbd>    <span>&#x2464;</span>
&lt;xml.dom.minidom.Attr instance at 0x81d5044></pre><div class=calloutlist>
<ol>
<li>Each <code>Element</code> object has an attribute called <code>attributes</code>, which is a <code>NamedNodeMap</code> object. This sounds scary, but it's not, because a <code>NamedNodeMap</code> is an object that <a href="#fileinfo.userdict" title="5.5. Exploring UserDict: A Wrapper Class">acts like a dictionary</a>, so you already know how to use it.
<li>Treating the <code>NamedNodeMap</code> as a dictionary, you can get a list of the names of the attributes of this element by using <code>attributes.keys()</code>. This element has only one attribute, <code>'id'</code>.
<li>Attribute names, like all other text in an <abbr>XML</abbr> document, are stored in <a href="#kgp.unicode" title="9.4. Unicode">unicode</a>.
<li>Again treating the <code>NamedNodeMap</code> as a dictionary, you can get a list of the values of the attributes by using <code>attributes.values()</code>. The values are themselves objects, of type <code>Attr</code>. You'll see how to get useful information out of this object in the next example.
<li>Still treating the <code>NamedNodeMap</code> as a dictionary, you can access an individual attribute by name, using normal dictionary syntax. (Readers who have been
            paying extra-close attention will already know how the <code>NamedNodeMap</code> class accomplishes this neat trick: by defining a <a href="#fileinfo.specialmethods" title="5.6. Special Class Methods"><code>__getitem__</code> special method</a>. Other readers can take comfort in the fact that they don't need to understand how it works in order to use it effectively.)
<div class=example><h3>Example 9.25. Accessing individual attributes</h3><pre class=screen>
<samp class=prompt>>>> </samp><kbd>a = bitref.attributes["id"]</kbd>
<samp class=prompt>>>> </samp><kbd>a</kbd>
&lt;xml.dom.minidom.Attr instance at 0x81d5044>
<samp class=prompt>>>> </samp><kbd>a.name</kbd>  <span>&#x2460;</span>
u'id'
<samp class=prompt>>>> </samp><kbd>a.value</kbd> <span>&#x2461;</span>
u'bit'</pre><div class=calloutlist>
<ol>
<li>The <code>Attr</code> object completely represents a single <abbr>XML</abbr> attribute of a single <abbr>XML</abbr> element. The name of the attribute (the same name as you used to find this object in the <code>bitref.attributes</code> <code>NamedNodeMap</code> pseudo-dictionary) is stored in <code>a.name</code>.
<li>The actual text value of this <abbr>XML</abbr> attribute is stored in <code>a.value</code>.
<table class=note border="0" summary="">

<td rowspan="2" align="center" valign="top" width="1%"><img src="images/note.png" alt="Note" title="" width="24" height="24"><td colspan="2" align="left" valign="top" width="99%">Like a dictionary, attributes of an <abbr>XML</abbr> element have no ordering. Attributes may <em>happen to be</em> listed in a certain order in the original <abbr>XML</abbr> document, and the <code>Attr</code> objects may <em>happen to be</em> listed in a certain order when the <abbr>XML</abbr> document is parsed into Python objects, but these orders are arbitrary and should carry no special meaning. You should always access individual attributes
      by name, like the keys of a dictionary.
<h2 id="kgp.segue">9.7. Segue</h2>
<p>OK, that's it for the hard-core XML stuff. The next chapter will continue to use these same example programs, but focus on
   other aspects that make the program more flexible: using streams for input processing, using <code>getattr</code> for method dispatching, and using command-line flags to allow users to reconfigure the program without changing the code.
<p>Before moving on to the next chapter, you should be comfortable doing all of these things:
<div class=itemizedlist>
<ul>
<li><a href="#kgp.parse" title="9.3. Parsing XML">Parsing <abbr>XML</abbr> documents</a> using <code>minidom</code>, <a href="#kgp.search" title="9.5. Searching for elements">searching through the parsed document</a>, and accessing arbitrary <a href="#kgp.attributes" title="9.6. Accessing element attributes">element attributes</a> and <a href="#kgp.child" title="10.4. Finding direct children of a node">element children</a>
<li>Organizing complex libraries into <a href="#kgp.packages" title="9.2. Packages">packages</a>
<li><a href="#kgp.unicode" title="9.4. Unicode">Converting unicode strings</a> to different character encodings

</ul>
<div class=footnotes><br><hr width="100" align="left">
<div class=footnote>
<p><sup>[<a name="ftn.d0e23786" href="#d0e23786">5</a>] </sup>This, sadly, is <em>still</em> an oversimplification. Unicode now has been extended to handle ancient Chinese, Korean, and Japanese texts, which had so
   many different characters that the 2-byte unicode system could not represent them all. But Python doesn't currently support that out of the box, and I don't know if there is a project afoot to add it. You've reached the
   limits of my expertise, sorry.
<div class=chapter>
<h2 id="streams">Chapter 10. Scripts and Streams</h2>
<h2 id="kgp.openanything">10.1. Abstracting input sources</h2>
<p>One of Python's greatest strengths is its dynamic binding, and one powerful use of dynamic binding is the <em>file-like object</em>.
<p>Many functions which require an input source could simply take a filename, go open the file for reading, read it, and close
it when they're done. But they don't. Instead, they take a <em>file-like object</em>.
<p>In the simplest case, a <em>file-like object</em> is any object with a <code>read</code> method with an optional <var>size</var> parameter, which returns a string. When called with no <var>size</var> parameter, it reads everything there is to read from the input source and returns all the data as a single string. When
called with a <var>size</var> parameter, it reads that much from the input source and returns that much data; when called again, it picks up where it left
off and returns the next chunk of data.
<p>This is how <a href="#fileinfo.files" title="6.2. Working with File Objects">reading from real files</a> works; the difference is that you're not limiting yourself to real files. The input source could be anything: a file on
disk, a web page, even a hard-coded string. As long as you pass a file-like object to the function, and the function simply
calls the object's <code>read</code> method, the function can handle any kind of input source without specific code to handle each kind.
<p>In case you were wondering how this relates to <abbr>XML</abbr> processing, <code>minidom.parse</code> is one such function which can take a file-like object.
<div class=example><h3>Example 10.1. Parsing <abbr>XML</abbr> from a file</h3><pre class=screen>
<samp class=prompt>>>> </samp><kbd>from xml.dom import minidom</kbd>
<samp class=prompt>>>> </samp><kbd>fsock = open('binary.xml')</kbd>    <span>&#x2460;</span>
<samp class=prompt>>>> </samp><kbd>xmldoc = minidom.parse(fsock)</kbd> <span>&#x2461;</span>
<samp class=prompt>>>> </samp><kbd>fsock.close()</kbd>                 <span>&#x2462;</span>
<samp class=prompt>>>> </samp><kbd>print xmldoc.toxml()</kbd>          <span>&#x2463;</span>
<samp>&lt;?xml version="1.0" ?>
&lt;grammar>
&lt;ref id="bit">
  &lt;p>0&lt;/p>
  &lt;p>1&lt;/p>
&lt;/ref>
&lt;ref id="byte">
  &lt;p>&lt;xref id="bit"/>&lt;xref id="bit"/>&lt;xref id="bit"/>&lt;xref id="bit"/>\
&lt;xref id="bit"/>&lt;xref id="bit"/>&lt;xref id="bit"/>&lt;xref id="bit"/>&lt;/p>
&lt;/ref>
&lt;/grammar></span></pre><div class=calloutlist>
<ol>
<li>First, you open the file on disk. This gives you a <a href="#fileinfo.files" title="6.2. Working with File Objects">file object</a>.
<li>You pass the file object to <code>minidom.parse</code>, which calls the <code>read</code> method of <var>fsock</var> and reads the <abbr>XML</abbr> document from the file on disk.
<li>Be sure to call the <code>close</code> method of the file object after you're done with it. <code>minidom.parse</code> will not do this for you.
<li>Calling the <code>toxml()</code> method on the returned <abbr>XML</abbr> document prints out the entire thing.
<p>Well, that all seems like a colossal waste of time. After all, you've already seen that <code>minidom.parse</code> can simply take the filename and do all the opening and closing nonsense automatically. And it's true that if you know you're
just going to be parsing a local file, you can pass the filename and <code>minidom.parse</code> is smart enough to Do The Right Thing&#8482;. But notice how similar -- and easy -- it is to parse an <abbr>XML</abbr> document straight from the Internet.
<div class=example><h3 id="kgp.openanything.urllib">Example 10.2. Parsing <abbr>XML</abbr> from a <abbr>URL</abbr></h3><pre class=screen>
<samp class=prompt>>>> </samp><kbd>import urllib</kbd>
<samp class=prompt>>>> </samp><kbd>usock = urllib.urlopen('http://slashdot.org/slashdot.rdf')</kbd> <span>&#x2460;</span>
<samp class=prompt>>>> </samp><kbd>xmldoc = minidom.parse(usock)</kbd>            <span>&#x2461;</span>
<samp class=prompt>>>> </samp><kbd>usock.close()</kbd>          <span>&#x2462;</span>
<samp class=prompt>>>> </samp><kbd>print xmldoc.toxml()</kbd>   <span>&#x2463;</span>
<samp>&lt;?xml version="1.0" ?>
&lt;rdf:RDF xmlns="http://my.netscape.com/rdf/simple/0.9/"
 xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">

&lt;channel>
&lt;title>Slashdot&lt;/title>
&lt;link>http://slashdot.org/&lt;/link>
&lt;description>News for nerds, stuff that matters&lt;/description>
&lt;/channel>

&lt;image>
&lt;title>Slashdot&lt;/title>
&lt;url>http://images.slashdot.org/topics/topicslashdot.gif&lt;/url>
&lt;link>http://slashdot.org/&lt;/link>
&lt;/image>

&lt;item>
&lt;title>To HDTV or Not to HDTV?&lt;/title>
&lt;link>http://slashdot.org/article.pl?sid=01/12/28/0421241&lt;/link>
&lt;/item>

[...snip...]</span></pre><div class=calloutlist>
<ol>
<li>As you saw <a href="#dialect.extract.urllib" title="Example 8.5. Introducing urllib">in a previous chapter</a>, <code>urlopen</code> takes a web page <abbr>URL</abbr> and returns a file-like object. Most importantly, this object has a <code>read</code> method which returns the <abbr>HTML</abbr> source of the web page.
<li>Now you pass the file-like object to <code>minidom.parse</code>, which obediently calls the <code>read</code> method of the object and parses the <abbr>XML</abbr> data that the <code>read</code> method returns. The fact that this <abbr>XML</abbr> data is now coming straight from a web page is completely irrelevant. <code>minidom.parse</code> doesn't know about web pages, and it doesn't care about web pages; it just knows about file-like objects.
<li>As soon as you're done with it, be sure to close the file-like object that <code>urlopen</code> gives you.
<li>By the way, this <abbr>URL</abbr> is real, and it really is <abbr>XML</abbr>. It's an <abbr>XML</abbr> representation of the current headlines on <a href="http://slashdot.org/">Slashdot</a>, a technical news and gossip site.
<div class=example><h3>Example 10.3. Parsing <abbr>XML</abbr> from a string (the easy but inflexible way)</h3><pre class=screen>
<samp class=prompt>>>> </samp><kbd>contents = "&lt;grammar>&lt;ref id='bit'>&lt;p>0&lt;/p>&lt;p>1&lt;/p>&lt;/ref>&lt;/grammar>"</kbd>
<samp class=prompt>>>> </samp><kbd>xmldoc = minidom.parseString(contents)</kbd> <span>&#x2460;</span>
<samp class=prompt>>>> </samp><kbd>print xmldoc.toxml()</kbd>
<samp>&lt;?xml version="1.0" ?>
&lt;grammar>&lt;ref id="bit">&lt;p>0&lt;/p>&lt;p>1&lt;/p>&lt;/ref>&lt;/grammar></span></pre><div class=calloutlist>
<ol>
<li><code>minidom</code> has a method, <code>parseString</code>, which takes an entire <abbr>XML</abbr> document as a string and parses it. You can use this instead of <code>minidom.parse</code> if you know you already have your entire <abbr>XML</abbr> document in a string.
<p>OK, so you can use the <code>minidom.parse</code> function for parsing both local files and remote <abbr>URL</abbr>s, but for parsing strings, you use... a different function. That means that if you want to be able to take input from a
file, a <abbr>URL</abbr>, or a string, you'll need special logic to check whether it's a string, and call the <code>parseString</code> function instead. How unsatisfying.
<p>If there were a way to turn a string into a file-like object, then you could simply pass this object to <code>minidom.parse</code>. And in fact, there is a module specifically designed for doing just that: <code>StringIO</code>.
<div class=example><h3 id="kgp.openanything.stringio.example">Example 10.4. Introducing <code>StringIO</code></h3><pre class=screen>
<samp class=prompt>>>> </samp><kbd>contents = "&lt;grammar>&lt;ref id='bit'>&lt;p>0&lt;/p>&lt;p>1&lt;/p>&lt;/ref>&lt;/grammar>"</kbd>
<samp class=prompt>>>> </samp><kbd>import StringIO</kbd>
<samp class=prompt>>>> </samp><kbd>ssock = StringIO.StringIO(contents)</kbd>   <span>&#x2460;</span>
<samp class=prompt>>>> </samp><kbd>ssock.read()</kbd>        <span>&#x2461;</span>
"&lt;grammar>&lt;ref id='bit'>&lt;p>0&lt;/p>&lt;p>1&lt;/p>&lt;/ref>&lt;/grammar>"
<samp class=prompt>>>> </samp><kbd>ssock.read()</kbd>        <span>&#x2462;</span>
''
<samp class=prompt>>>> </samp><kbd>ssock.seek(0)</kbd>       <span>&#x2463;</span>
<samp class=prompt>>>> </samp><kbd>ssock.read(15)</kbd>      <span>&#x2464;</span>
'&lt;grammar>&lt;ref i'
<samp class=prompt>>>> </samp><kbd>ssock.read(15)</kbd>
"d='bit'>&lt;p>0&lt;/p"
<samp class=prompt>>>> </samp><kbd>ssock.read()</kbd>
'>&lt;p>1&lt;/p>&lt;/ref>&lt;/grammar>'
<samp class=prompt>>>> </samp><kbd>ssock.close()</kbd>       <span>&#x2465;</span></pre><div class=calloutlist>
<ol>
<li>The <code>StringIO</code> module contains a single class, also called <code>StringIO</code>, which allows you to turn a string into a file-like object. The <code>StringIO</code> class takes the string as a parameter when creating an instance.
<li>Now you have a file-like object, and you can do all sorts of file-like things with it. Like <code>read</code>, which returns the original string.
<li>Calling <code>read</code> again returns an empty string. This is how real file objects work too; once you read the entire file, you can't read any
            more without explicitly seeking to the beginning of the file. The <code>StringIO</code> object works the same way.
<li>You can explicitly seek to the beginning of the string, just like seeking through a file, by using the <code>seek</code> method of the <code>StringIO</code> object.
<li>You can also read the string in chunks, by passing a <var>size</var> parameter to the <code>read</code> method.
<li>At any time, <code>read</code> will return the rest of the string that you haven't read yet. All of this is exactly how file objects work; hence the term
<em>file-like object</em>.
<div class=example><h3>Example 10.5. Parsing <abbr>XML</abbr> from a string (the file-like object way)</h3><pre class=screen>
<samp class=prompt>>>> </samp><kbd>contents = "&lt;grammar>&lt;ref id='bit'>&lt;p>0&lt;/p>&lt;p>1&lt;/p>&lt;/ref>&lt;/grammar>"</kbd>
<samp class=prompt>>>> </samp><kbd>ssock = StringIO.StringIO(contents)</kbd>
<samp class=prompt>>>> </samp><kbd>xmldoc = minidom.parse(ssock)</kbd> <span>&#x2460;</span>
<samp class=prompt>>>> </samp><kbd>ssock.close()</kbd>
<samp class=prompt>>>> </samp><kbd>print xmldoc.toxml()</kbd>
<samp>&lt;?xml version="1.0" ?>
&lt;grammar>&lt;ref id="bit">&lt;p>0&lt;/p>&lt;p>1&lt;/p>&lt;/ref>&lt;/grammar></span></pre><div class=calloutlist>
<ol>
<li>Now you can pass the file-like object (really a <code>StringIO</code>) to <code>minidom.parse</code>, which will call the object's <code>read</code> method and happily parse away, never knowing that its input came from a hard-coded string.
<p>So now you know how to use a single function, <code>minidom.parse</code>, to parse an <abbr>XML</abbr> document stored on a web page, in a local file, or in a hard-coded string. For a web page, you use <code>urlopen</code> to get a file-like object; for a local file, you use <code>open</code>; and for a string, you use <code>StringIO</code>. Now let's take it one step further and generalize <em>these</em> differences as well.
<div class=example><h3 id="kgp.openanything.example">Example 10.6. <code>openAnything</code></h3><pre><code>
def openAnything(source):<span>&#x2460;</span>
    # try to open with urllib (if source is http, ftp, or file URL)
    import urllib       
    try:                
        return urllib.urlopen(source)      <span>&#x2461;</span>
    except (IOError, OSError):            
        pass            

    # try to open with native open function (if source is pathname)
    try:                
        return open(source)                <span>&#x2462;</span>
    except (IOError, OSError):            
        pass            

    # treat source as string
    import StringIO     
    return StringIO.StringIO(str(source))  <span>&#x2463;</span></pre><div class=calloutlist>
<ol>
<li>The <code>openAnything</code> function takes a single parameter, <var>source</var>, and returns a file-like object. <var>source</var> is a string of some sort; it can either be a <abbr>URL</abbr> (like <code>'http://slashdot.org/slashdot.rdf'</code>), a full or partial pathname to a local file (like <code>'binary.xml'</code>), or a string that contains actual <abbr>XML</abbr> data to be parsed.
<li>First, you see if <var>source</var> is a <abbr>URL</abbr>. You do this through brute force: you try to open it as a <abbr>URL</abbr> and silently ignore errors caused by trying to open something which is not a <abbr>URL</abbr>. This is actually elegant in the sense that, if <code>urllib</code> ever supports new types of <abbr>URL</abbr>s in the future, you will also support them without recoding. If <code>urllib</code> is able to open <var>source</var>, then the <code>return</code> kicks you out of the function immediately and the following <code>try</code> statements never execute.
<li>On the other hand, if <code>urllib</code> yelled at you and told you that <var>source</var> wasn't a valid <abbr>URL</abbr>, you assume it's a path to a file on disk and try to open it. Again, you don't do anything fancy to check whether <var>source</var> is a valid filename or not (the rules for valid filenames vary wildly between different platforms anyway, so you'd probably
            get them wrong anyway). Instead, you just blindly open the file, and silently trap any errors.
<li>By this point, you need to assume that <var>source</var> is a string that has hard-coded data in it (since nothing else worked), so you use <code>StringIO</code> to create a file-like object out of it and return that. (In fact, since you're using the <code>str</code> function, <var>source</var> doesn't even need to be a string; it could be any object, and you'll use its string representation, as defined by its <code>__str__</code> <a href="#fileinfo.morespecial" title="5.7. Advanced Special Class Methods">special method</a>.)
<p>Now you can use this <code>openAnything</code> function in conjunction with <code>minidom.parse</code> to make a function that takes a <var>source</var> that refers to an <abbr>XML</abbr> document somehow (either as a <abbr>URL</abbr>, or a local filename, or a hard-coded <abbr>XML</abbr> document in a string) and parses it.
<div class=example><h3>Example 10.7. Using <code>openAnything</code> in <code>kgp.py</code></h3><pre><code>
class KantGenerator:
    def _load(self, source):
        sock = toolbox.openAnything(source)
        xmldoc = minidom.parse(sock).documentElement
        sock.close()
        return xmldoc</pre><h2 id="kgp.stdio">10.2. Standard input, output, and error</h2>
<p><abbr>UNIX</abbr> users are already familiar with the concept of standard input, standard output, and standard error. This section is for
   the rest of you.
<p>Standard output and standard error (commonly abbreviated <code>stdout</code> and <code>stderr</code>) are pipes that are built into every <abbr>UNIX</abbr> system. When you <code>print</code> something, it goes to the <code>stdout</code> pipe; when your program crashes and prints out debugging information (like a traceback in Python), it goes to the <code>stderr</code> pipe. Both of these pipes are ordinarily just connected to the terminal window where you are working, so when a program
prints, you see the output, and when a program crashes, you see the debugging information. (If you're working on a system
with a window-based Python <abbr>IDE</abbr>, <code>stdout</code> and <code>stderr</code> default to your &#8220;Interactive Window&#8221;.)
<div class=example><h3>Example 10.8. Introducing <code>stdout</code> and <code>stderr</code></h3><pre class=screen>
<samp class=prompt>>>> </samp><kbd>for i in range(3):</kbd>
<samp class=prompt>...    </samp>print 'Dive in'             <span>&#x2460;</span>
<samp>Dive in
Dive in
Dive in</samp>
<samp class=prompt>>>> </samp><kbd>import sys</kbd>
<samp class=prompt>>>> </samp><kbd>for i in range(3):</kbd>
<samp class=prompt>...    </samp>sys.stdout.write('Dive in') <span>&#x2461;</span>
Dive inDive inDive in
<samp class=prompt>>>> </samp><kbd>for i in range(3):</kbd>
<samp class=prompt>...    </samp>sys.stderr.write('Dive in') <span>&#x2462;</span>
Dive inDive inDive in</pre><div class=calloutlist>
<ol>
<li>As you saw in <a href="#fileinfo.for.counter" title="Example 6.9. Simple Counters">Example 6.9, &#8220;Simple Counters&#8221;</a>, you can use Python's built-in <code>range</code> function to build simple counter loops that repeat something a set number of times.
<li><code>stdout</code> is a file-like object; calling its <code>write</code> function will print out whatever string you give it. In fact, this is what the <code>print</code> function really does; it adds a carriage return to the end of the string you're printing, and calls <code>sys.stdout.write</code>.
<li>In the simplest case, <code>stdout</code> and <code>stderr</code> send their output to the same place: the Python <abbr>IDE</abbr> (if you're in one), or the terminal (if you're running Python from the command line). Like <code>stdout</code>, <code>stderr</code> does not add carriage returns for you; if you want them, add them yourself.
<p><code>stdout</code> and <code>stderr</code> are both file-like objects, like the ones you discussed in <a href="#kgp.openanything" title="10.1. Abstracting input sources">Section 10.1, &#8220;Abstracting input sources&#8221;</a>, but they are both write-only. They have no <code>read</code> method, only <code>write</code>. Still, they are file-like objects, and you can assign any other file- or file-like object to them to redirect their output.
<div class=example><h3>Example 10.9. Redirecting output</h3><pre class=screen>
<samp class=prompt>[you@localhost kgp]$ </samp>python stdout.py
Dive in
<samp class=prompt>[you@localhost kgp]$ </samp>cat out.log
This message will be logged instead of displayed</pre><p>(On Windows, you can use <code>type</code> instead of <code>cat</code> to display the contents of a file.)
<p>If you have not already done so, you can <a href="http://diveintopython3.org/download/diveintopython3-examples-5.4.zip" title="Download example scripts">download this and other examples</a> used in this book.
<pre><code>
#stdout.py
import sys

print 'Dive in'      <span>&#x2460;</span>
saveout = sys.stdout <span>&#x2461;</span>
fsock = open('out.log', 'w')           <span>&#x2462;</span>
sys.stdout = fsock   <span>&#x2463;</span>
print 'This message will be logged instead of displayed' <span>&#x2464;</span>
sys.stdout = saveout <span>&#x2465;</span>
fsock.close()        <span>&#x2466;</span>
</pre><div class=calloutlist>
<ol>
<li>This will print to the <abbr>IDE</abbr> &#8220;Interactive Window&#8221; (or the terminal, if running the script from the command line).
<li>Always save <code>stdout</code> before redirecting it, so you can set it back to normal later.
<li>Open a file for writing. If the file doesn't exist, it will be created. If the file does exist, it will be overwritten.
<li>Redirect all further output to the new file you just opened.
<li>This will be &#8220;printed&#8221; to the log file only; it will not be visible in the <abbr>IDE</abbr> window or on the screen.
<li>Set <code>stdout</code> back to the way it was before you mucked with it.
<li>Close the log file.
<p>Redirecting <code>stderr</code> works exactly the same way, using <code>sys.stderr</code> instead of <code>sys.stdout</code>.
<div class=example><h3>Example 10.10. Redirecting error information</h3><pre class=screen>
<samp class=prompt>[you@localhost kgp]$ </samp>python stderr.py
<samp class=prompt>[you@localhost kgp]$ </samp>cat error.log
<samp>Traceback (most recent line last):
  File "stderr.py", line 5, in ?
    raise Exception, 'this error will be logged'
Exception: this error will be logged</span></pre><p>If you have not already done so, you can <a href="http://diveintopython3.org/download/diveintopython3-examples-5.4.zip" title="Download example scripts">download this and other examples</a> used in this book.
<pre><code>
#stderr.py
import sys

fsock = open('error.log', 'w')               <span>&#x2460;</span>
sys.stderr = fsock         <span>&#x2461;</span>
raise Exception, 'this error will be logged' <span>&#x2462;</span> <span>&#x2463;</span>
</pre><div class=calloutlist>
<ol>
<li>Open the log file where you want to store debugging information.
<li>Redirect standard error by assigning the file object of the newly-opened log file to <code>stderr</code>.
<li>Raise an exception. Note from the screen output that this does <em>not</em> print anything on screen. All the normal traceback information has been written to <code>error.log</code>.
<li>Also note that you're not explicitly closing your log file, nor are you setting <code>stderr</code> back to its original value. This is fine, since once the program crashes (because of the exception), Python will clean up and close the file for us, and it doesn't make any difference that <code>stderr</code> is never restored, since, as I mentioned, the program crashes and Python ends. Restoring the original is more important for <code>stdout</code>, if you expect to go do other stuff within the same script afterwards.
<p>Since it is so common to write error messages to standard error, there is a shorthand syntax that can be used instead of going
through the hassle of redirecting it outright.
<div class=example><h3 id="kgp.stdio.print.example">Example 10.11. Printing to <code>stderr</code></h3><pre class=screen>
<samp class=prompt>>>> </samp><kbd>print 'entering function'</kbd>
entering function
<samp class=prompt>>>> </samp><kbd>import sys</kbd>
<samp class=prompt>>>> </samp><kbd>print >> sys.stderr, 'entering function'</kbd> <span>&#x2460;</span>
entering function
</pre><div class=calloutlist>
<ol>
<li>This shorthand syntax of the <code>print</code> statement can be used to write to any open file, or file-like object. In this case, you can redirect a single <code>print</code> statement to <code>stderr</code> without affecting subsequent <code>print</code> statements.
<p>Standard input, on the other hand, is a read-only file object, and it represents the data flowing into the program from some
previous program. This will likely not make much sense to classic Mac OS users, or even Windows users unless you were ever fluent on the <abbr>MS-DOS</abbr> command line. The way it works is that you can construct a chain of commands in a single line, so that one program's output
becomes the input for the next program in the chain. The first program simply outputs to standard output (without doing any
special redirecting itself, just doing normal <code>print</code> statements or whatever), and the next program reads from standard input, and the operating system takes care of connecting
one program's output to the next program's input.
<div class=example><h3>Example 10.12. Chaining commands</h3><pre class=screen>
<samp class=prompt>[you@localhost kgp]$ </samp>python kgp.py -g binary.xml         <span>&#x2460;</span>
01100111
<samp class=prompt>[you@localhost kgp]$ </samp>cat binary.xml    <span>&#x2461;</span>
<samp>&lt;?xml version="1.0"?>
&lt;!DOCTYPE grammar PUBLIC "-//diveintopython3.org//DTD Kant Generator Pro v1.0//EN" "kgp.dtd">
&lt;grammar>
&lt;ref id="bit">
  &lt;p>0&lt;/p>
  &lt;p>1&lt;/p>
&lt;/ref>
&lt;ref id="byte">
  &lt;p>&lt;xref id="bit"/>&lt;xref id="bit"/>&lt;xref id="bit"/>&lt;xref id="bit"/>\
&lt;xref id="bit"/>&lt;xref id="bit"/>&lt;xref id="bit"/>&lt;xref id="bit"/>&lt;/p>
&lt;/ref>
&lt;/grammar></samp>
<samp class=prompt>[you@localhost kgp]$ </samp>cat binary.xml | python kgp.py -g - <span>&#x2462;</span> <span>&#x2463;</span>
10110001</pre><div class=calloutlist>
<ol>
<li>As you saw in <a href="#kgp.divein" title="9.1. Diving in">Section 9.1, &#8220;Diving in&#8221;</a>, this will print a string of eight random bits, <code>0</code> or <code>1</code>.
<li>This simply prints out the entire contents of <code>binary.xml</code>. (Windows users should use <code>type</code> instead of <code>cat</code>.)
<li>This prints the contents of <code>binary.xml</code>, but the &#8220;<code>|</code>&#8221; character, called the &#8220;pipe&#8221; character, means that the contents will not be printed to the screen. Instead, they will become the standard input of the
            next command, which in this case calls your Python script.
<li>Instead of specifying a module (like <code>binary.xml</code>), you specify &#8220;<code>-</code>&#8221;, which causes your script to load the grammar from standard input instead of from a specific file on disk. (More on how
            this happens in the next example.)  So the effect is the same as the first syntax, where you specified the grammar filename
            directly, but think of the expansion possibilities here. Instead of simply doing <code>cat binary.xml</code>, you could run a script that dynamically generates the grammar, then you can pipe it into your script. It could come from
            anywhere: a database, or some grammar-generating meta-script, or whatever. The point is that you don't need to change your
<code>kgp.py</code> script at all to incorporate any of this functionality. All you need to do is be able to take grammar files from standard
            input, and you can separate all the other logic into another program.
<p>So how does the script &#8220;know&#8221; to read from standard input when the grammar file is &#8220;<code>-</code>&#8221;?  It's not magic; it's just code.
<div class=example><h3>Example 10.13. Reading from standard input in <code>kgp.py</code></h3><pre><code>
def openAnything(source):
    if source == "-":    <span>&#x2460;</span>
        import sys
        return sys.stdin

    # try to open with urllib (if source is http, ftp, or file URL)
    import urllib
    try:

[... snip ...]</pre><div class=calloutlist>
<ol>
<li>This is the <code>openAnything</code> function from <code>toolbox.py</code>, which you previously examined in <a href="#kgp.openanything" title="10.1. Abstracting input sources">Section 10.1, &#8220;Abstracting input sources&#8221;</a>. All you've done is add three lines of code at the beginning of the function to check if the source is &#8220;<code>-</code>&#8221;; if so, you return <code>sys.stdin</code>. Really, that's it!  Remember, <code>stdin</code> is a file-like object with a <code>read</code> method, so the rest of the code (in <code>kgp.py</code>, where you call <code>openAnything</code>) doesn't change a bit.
<h2 id="kgp.cache">10.3. Caching node lookups</h2>
<p><code>kgp.py</code> employs several tricks which may or may not be useful to you in your <abbr>XML</abbr> processing. The first one takes advantage of the consistent structure of the input documents to build a cache of nodes.
<p>A grammar file defines a series of <code>ref</code> elements. Each <code>ref</code> contains one or more <code>p</code> elements, which can contain a lot of different things, including <code>xref</code>s. Whenever you encounter an <code>xref</code>, you look for a corresponding <code>ref</code> element with the same <code>id</code> attribute, and choose one of the <code>ref</code> element's children and parse it. (You'll see how this random choice is made in the next section.)
<p>This is how you build up the grammar: define <code>ref</code> elements for the smallest pieces, then define <code>ref</code> elements which "include" the first <code>ref</code> elements by using <code>xref</code>, and so forth. Then you parse the "largest" reference and follow each <code>xref</code>, and eventually output real text. The text you output depends on the (random) decisions you make each time you fill in an
<code>xref</code>, so the output is different each time.
<p>This is all very flexible, but there is one downside: performance. When you find an <code>xref</code> and need to find the corresponding <code>ref</code> element, you have a problem. The <code>xref</code> has an <code>id</code> attribute, and you want to find the <code>ref</code> element that has that same <code>id</code> attribute, but there is no easy way to do that. The slow way to do it would be to get the entire list of <code>ref</code> elements each time, then manually loop through and look at each <code>id</code> attribute. The fast way is to do that once and build a cache, in the form of a dictionary.
<div class=example><h3>Example 10.14. <code>loadGrammar</code></h3><pre><code>
    def loadGrammar(self, grammar):       
        self.grammar = self._load(grammar)
        self.refs = {}   <span>&#x2460;</span>
        for ref in self.grammar.getElementsByTagName("ref"): <span>&#x2461;</span>
            self.refs[ref.attributes["id"].value] = ref      <span>&#x2462;</span> <span>&#x2463;</span></pre><div class=calloutlist>
<ol>
<li>Start by creating an empty dictionary, <var>self.refs</var>.
<li>As you saw in <a href="#kgp.search" title="9.5. Searching for elements">Section 9.5, &#8220;Searching for elements&#8221;</a>, <code>getElementsByTagName</code> returns a list of all the elements of a particular name. You easily can get a list of all the <code>ref</code> elements, then simply loop through that list.
<li>As you saw in <a href="#kgp.attributes" title="9.6. Accessing element attributes">Section 9.6, &#8220;Accessing element attributes&#8221;</a>, you can access individual attributes of an element by name, using standard dictionary syntax. So the keys of the <var>self.refs</var> dictionary will be the values of the <code>id</code> attribute of each <code>ref</code> element.
<li>The values of the <var>self.refs</var> dictionary will be the <code>ref</code> elements themselves. As you saw in <a href="#kgp.parse" title="9.3. Parsing XML">Section 9.3, &#8220;Parsing XML&#8221;</a>, each element, each node, each comment, each piece of text in a parsed <abbr>XML</abbr> document is an object.
<p>Once you build this cache, whenever you come across an <code>xref</code> and need to find the <code>ref</code> element with the same <code>id</code> attribute, you can simply look it up in <var>self.refs</var>.
<div class=example><h3>Example 10.15. Using the <code>ref</code> element cache</h3><pre><code>
    def do_xref(self, node):
        id = node.attributes["id"].value
        self.parse(self.randomChildElement(self.refs[id]))</pre><p>You'll explore the <code>randomChildElement</code> function in the next section.
<h2 id="kgp.child">10.4. Finding direct children of a node</h2>
<p>Another useful techique when parsing <abbr>XML</abbr> documents is finding all the direct child elements of a particular element. For instance, in the grammar files, a <code>ref</code> element can have several <code>p</code> elements, each of which can contain many things, including other <code>p</code> elements. You want to find just the <code>p</code> elements that are children of the <code>ref</code>, not <code>p</code> elements that are children of other <code>p</code> elements.
<p>You might think you could simply use <code>getElementsByTagName</code> for this, but you can't. <code>getElementsByTagName</code> searches recursively and returns a single list for all the elements it finds. Since <code>p</code> elements can contain other <code>p</code> elements, you can't use <code>getElementsByTagName</code>, because it would return nested <code>p</code> elements that you don't want. To find only direct child elements, you'll need to do it yourself.
<div class=example><h3>Example 10.16. Finding direct child elements</h3><pre><code>
    def randomChildElement(self, node):
        choices = [e for e in node.childNodes
 if e.nodeType == e.ELEMENT_NODE] <span>&#x2460;</span> <span>&#x2461;</span> <span>&#x2462;</span>
        chosen = random.choice(choices)             <span>&#x2463;</span>
        return chosen            </pre><div class=calloutlist>
<ol>
<li>As you saw in <a href="#kgp.parse.gettingchildnodes.example" title="Example 9.9. Getting child nodes">Example 9.9, &#8220;Getting child nodes&#8221;</a>, the <code>childNodes</code> attribute returns a list of all the child nodes of an element.
<li>However, as you saw in <a href="#kgp.parse.childnodescanbetext.example" title="Example 9.11. Child nodes can be text">Example 9.11, &#8220;Child nodes can be text&#8221;</a>, the list returned by <code>childNodes</code> contains all different types of nodes, including text nodes. That's not what you're looking for here. You only want the
            children that are elements.
<li>Each node has a <var>nodeType</var> attribute, which can be <code>ELEMENT_NODE</code>, <code>TEXT_NODE</code>, <code>COMMENT_NODE</code>, or any number of other values. The complete list of possible values is in the <code>__init__.py</code> file in the <code>xml.dom</code> package. (See <a href="#kgp.packages" title="9.2. Packages">Section 9.2, &#8220;Packages&#8221;</a> for more on packages.)  But you're just interested in nodes that are elements, so you can filter the list to only include
            those nodes whose <var>nodeType</var> is <code>ELEMENT_NODE</code>.
<li>Once you have a list of actual elements, choosing a random one is easy. Python comes with a module called <code>random</code> which includes several useful functions. The <code>random.choice</code> function takes a list of any number of items and returns a random item. For example, if the <code>ref</code> elements contains several <code>p</code> elements, then <var>choices</var> would be a list of <code>p</code> elements, and <var>chosen</var> would end up being assigned exactly one of them, selected at random.
<h2 id="kgp.handler">10.5. Creating separate handlers by node type</h2>
<p>The third useful <abbr>XML</abbr> processing tip involves separating your code into logical functions, based on node types and element names. Parsed <abbr>XML</abbr> documents are made up of various types of nodes, each represented by a Python object. The root level of the document itself is represented by a <code>Document</code> object. The <code>Document</code> then contains one or more <code>Element</code> objects (for actual <abbr>XML</abbr> tags), each of which may contain other <code>Element</code> objects, <code>Text</code> objects (for bits of text), or <code>Comment</code> objects (for embedded comments). Python makes it easy to write a dispatcher to separate the logic for each node type.
<div class=example><h3>Example 10.17. Class names of parsed <abbr>XML</abbr> objects</h3><pre class=screen>
<samp class=prompt>>>> </samp><kbd>from xml.dom import minidom</kbd>
<samp class=prompt>>>> </samp><kbd>xmldoc = minidom.parse('kant.xml')</kbd> <span>&#x2460;</span>
<samp class=prompt>>>> </samp><kbd>xmldoc</kbd>
&lt;xml.dom.minidom.Document instance at 0x01359DE8>
<samp class=prompt>>>> </samp><kbd>xmldoc.__class__</kbd> <span>&#x2461;</span>
&lt;class xml.dom.minidom.Document at 0x01105D40>
<samp class=prompt>>>> </samp><kbd>xmldoc.__class__.__name__</kbd>          <span>&#x2462;</span>
'Document'</pre><div class=calloutlist>
<ol>
<li>Assume for a moment that <code>kant.xml</code> is in the current directory.
<li>As you saw in <a href="#kgp.packages" title="9.2. Packages">Section 9.2, &#8220;Packages&#8221;</a>, the object returned by parsing an <abbr>XML</abbr> document is a <code>Document</code> object, as defined in the <code>minidom.py</code> in the <code>xml.dom</code> package. As you saw in <a href="#fileinfo.create" title="5.4. Instantiating Classes">Section 5.4, &#8220;Instantiating Classes&#8221;</a>, <code>__class__</code> is built-in attribute of every Python object.
<li>Furthermore, <code>__name__</code> is a built-in attribute of every Python class, and it is a string. This string is not mysterious; it's the same as the class name you type when you define a class
            yourself. (See <a href="#fileinfo.class" title="5.3. Defining Classes">Section 5.3, &#8220;Defining Classes&#8221;</a>.)
<p>Fine, so now you can get the class name of any particular <abbr>XML</abbr> node (since each <abbr>XML</abbr> node is represented as a Python object). How can you use this to your advantage to separate the logic of parsing each node type?  The answer is <code>getattr</code>, which you first saw in <a href="#apihelper.getattr" title="4.4. Getting Object References With getattr">Section 4.4, &#8220;Getting Object References With getattr&#8221;</a>.
<div class=example><h3>Example 10.18. <code>parse</code>, a generic <abbr>XML</abbr> node dispatcher</h3><pre><code>
    def parse(self, node):          
        parseMethod = getattr(self, "parse_%s" % node.__class__.__name__) <span>&#x2460;</span> <span>&#x2461;</span>
        parseMethod(node) <span>&#x2462;</span></pre><div class=calloutlist>
<ol>
<li>First off, notice that you're constructing a larger string based on the class name of the node you were passed (in the <var>node</var> argument). So if you're passed a <code>Document</code> node, you're constructing the string <code>'parse_Document'</code>, and so forth.
<li>Now you can treat that string as a function name, and get a reference to the function itself using <code>getattr</code><li>Finally, you can call that function and pass the node itself as an argument. The next example shows the definitions of each
            of these functions.
<div class=example><h3>Example 10.19. Functions called by the <code>parse</code> dispatcher</h3><pre><code>
    def parse_Document(self, node): <span>&#x2460;</span>
        self.parse(node.documentElement)

    def parse_Text(self, node):    <span>&#x2461;</span>
        text = node.data
        if self.capitalizeNextWord:
            self.pieces.append(text[0].upper())
            self.pieces.append(text[1:])
            self.capitalizeNextWord = 0
        else:
            self.pieces.append(text)

    def parse_Comment(self, node): <span>&#x2462;</span>
        pass

    def parse_Element(self, node): <span>&#x2463;</span>
        handlerMethod = getattr(self, "do_%s" % node.tagName)
        handlerMethod(node)</pre><div class=calloutlist>
<ol>
<li><code>parse_Document</code> is only ever called once, since there is only one <code>Document</code> node in an <abbr>XML</abbr> document, and only one <code>Document</code> object in the parsed <abbr>XML</abbr> representation. It simply turns around and parses the root element of the grammar file.
<li><code>parse_Text</code> is called on nodes that represent bits of text. The function itself does some special processing to handle automatic capitalization
            of the first word of a sentence, but otherwise simply appends the represented text to a list.
<li><code>parse_Comment</code> is just a <code>pass</code>, since you don't care about embedded comments in the grammar files. Note, however, that you still need to define the function
            and explicitly make it do nothing. If the function did not exist, the generic <code>parse</code> function would fail as soon as it stumbled on a comment, because it would try to find the non-existent <code>parse_Comment</code> function. Defining a separate function for every node type, even ones you don't use, allows the generic <code>parse</code> function to stay simple and dumb.
<li>The <code>parse_Element</code> method is actually itself a dispatcher, based on the name of the element's tag. The basic idea is the same: take what distinguishes
            elements from each other (their tag names) and dispatch to a separate function for each of them. You construct a string like
<code>'do_xref'</code> (for an <code>&lt;xref></code> tag), find a function of that name, and call it. And so forth for each of the other tag names that might be found in the
            course of parsing a grammar file (<code>&lt;p></code> tags, <code>&lt;choice></code> tags).
<p>In this example, the dispatch functions <code>parse</code> and <code>parse_Element</code> simply find other methods in the same class. If your processing is very complex (or you have many different tag names),
you could break up your code into separate modules, and use dynamic importing to import each module and call whatever functions
you needed. Dynamic importing will be discussed in <a href="#regression" title="Chapter 16. Functional Programming">Chapter 16, <i>Functional Programming</i></a>.
<h2 id="kgp.commandline">10.6. Handling command-line arguments</h2>
<p>Python fully supports creating programs that can be run on the command line, complete with command-line arguments and either short-
   or long-style flags to specify various options. None of this is <abbr>XML</abbr>-specific, but this script makes good use of command-line processing, so it seemed like a good time to mention it.
<p>It's difficult to talk about command-line processing without understanding how command-line arguments are exposed to your
Python program, so let's write a simple program to see them.
<div class=example><h3>Example 10.20. Introducing <var>sys.argv</var></h3>
<p>If you have not already done so, you can <a href="http://diveintopython3.org/download/diveintopython3-examples-5.4.zip" title="Download example scripts">download this and other examples</a> used in this book.
<pre><code>
#argecho.py
import sys

for arg in sys.argv: <span>&#x2460;</span>
    print arg</pre><div class=calloutlist>
<ol>
<li>Each command-line argument passed to the program will be in <var>sys.argv</var>, which is just a list. Here you are printing each argument on a separate line.
<div class=example><h3>Example 10.21. The contents of <var>sys.argv</var></h3><pre class=screen>
<samp class=prompt>[you@localhost py]$ </samp>python argecho.py             <span>&#x2460;</span>
argecho.py
<samp class=prompt>[you@localhost py]$ </samp>python argecho.py abc def     <span>&#x2461;</span>
<samp>argecho.py
abc
def</samp>
<samp class=prompt>[you@localhost py]$ </samp>python argecho.py --help      <span>&#x2462;</span>
<samp>argecho.py
--help</samp>
<samp class=prompt>[you@localhost py]$ </samp>python argecho.py -m kant.xml <span>&#x2463;</span>
<samp>argecho.py
-m
kant.xml</span></pre><div class=calloutlist>
<ol>
<li>The first thing to know about <var>sys.argv</var> is that it contains the name of the script you're calling. You will actually use this knowledge to your advantage later,
            in <a href="#regression" title="Chapter 16. Functional Programming">Chapter 16, <i>Functional Programming</i></a>. Don't worry about it for now.
<li>Command-line arguments are separated by spaces, and each shows up as a separate element in the <var>sys.argv</var> list.
<li>Command-line flags, like <code>--help</code>, also show up as their own element in the <var>sys.argv</var> list.
<li>To make things even more interesting, some command-line flags themselves take arguments. For instance, here you have a flag
            (<code>-m</code>) which takes an argument (<code>kant.xml</code>). Both the flag itself and the flag's argument are simply sequential elements in the <var>sys.argv</var> list. No attempt is made to associate one with the other; all you get is a list.
<p>So as you can see, you certainly have all the information passed on the command line, but then again, it doesn't look like
it's going to be all that easy to actually use it. For simple programs that only take a single argument and have no flags,
you can simply use <code>sys.argv[1]</code> to access the argument. There's no shame in this; I do it all the time. For more complex programs, you need the <code>getopt</code> module.
<div class=example><h3>Example 10.22. Introducing <code>getopt</code></h3><pre><code>
def main(argv):       
    grammar = "kant.xml"                 <span>&#x2460;</span>
    try:              
        opts, args = getopt.getopt(argv, "hg:d", ["help", "grammar="]) <span>&#x2461;</span>
    except getopt.GetoptError:           <span>&#x2462;</span>
        usage()        <span>&#x2463;</span>
        sys.exit(2)   

...

if __name__ == "__main__":
    main(sys.argv[1:])</pre><div class=calloutlist>
<ol>
<li>First off, look at the bottom of the example and notice that you're calling the <code>main</code> function with <code>sys.argv[1:]</code>. Remember, <code>sys.argv[0]</code> is the name of the script that you're running; you don't care about that for command-line processing, so you chop it off
            and pass the rest of the list.
<li>This is where all the interesting processing happens. The <code>getopt</code> function of the <code>getopt</code> module takes three parameters: the argument list (which you got from <code>sys.argv[1:]</code>), a string containing all the possible single-character command-line flags that this program accepts, and a list of longer
            command-line flags that are equivalent to the single-character versions. This is quite confusing at first glance, and is
            explained in more detail below.
<li>If anything goes wrong trying to parse these command-line flags, <code>getopt</code> will raise an exception, which you catch. You told <code>getopt</code> all the flags you understand, so this probably means that the end user passed some command-line flag that you don't understand.
<li>As is standard practice in the <abbr>UNIX</abbr> world, when the script is passed flags it doesn't understand, you print out a summary of proper usage and exit gracefully.
             Note that I haven't shown the <code>usage</code> function here. You would still need to code that somewhere and have it print out the appropriate summary; it's not automatic.
<p>So what are all those parameters you pass to the <code>getopt</code> function?  Well, the first one is simply the raw list of command-line flags and arguments (not including the first element,
the script name, which you already chopped off before calling the <code>main</code> function). The second is the list of short command-line flags that the script accepts.
<div class=variablelist>
<h3><code>"hg:d"</code></h3>
<dl>
<dt><code>-h</code></dt>
<dd>print usage summary</dd>
<dt><code>-g ...</code></dt>
<dd>use specified grammar file or URL</dd>
<dt><code>-d</code></dt>
<dd>show debugging information while parsing</dd>
</dl>
<p>The first and third flags are simply standalone flags; you specify them or you don't, and they do things (print help) or change
state (turn on debugging). However, the second flag (<code>-g</code>) <em>must</em> be followed by an argument, which is the name of the grammar file to read from. In fact it can be a filename or a web address,
and you don't know which yet (you'll figure it out later), but you know it has to be <em>something</em>. So you tell <code>getopt</code> this by putting a colon after the <code>g</code> in that second parameter to the <code>getopt</code> function.
<p>To further complicate things, the script accepts either short flags (like <code>-h</code>) or long flags (like <code>--help</code>), and you want them to do the same thing. This is what the third parameter to <code>getopt</code> is for, to specify a list of the long flags that correspond to the short flags you specified in the second parameter.
<div class=variablelist>
<h3><code>["help", "grammar="]</code></h3>
<dl>
<dt><code>--help</code></dt>
<dd>print usage summary</dd>
<dt><code>--grammar ...</code></dt>
<dd>use specified grammar file or URL</dd>
</dl>
<p>Three things of note here:
<div class=orderedlist>
<ol>
<li>All long flags are preceded by two dashes on the command line, but you don't include those dashes when calling <code>getopt</code>. They are understood.

<li>The <code>--grammar</code> flag must always be followed by an additional argument, just like the <code>-g</code> flag. This is notated by an equals sign, <code>"grammar="</code>.

<li>The list of long flags is shorter than the list of short flags, because the <code>-d</code> flag does not have a corresponding long version. This is fine; only <code>-d</code> will turn on debugging. But the order of short and long flags needs to be the same, so you'll need to specify all the short
      flags that <em>do</em> have corresponding long flags first, then all the rest of the short flags.

</ol>
<p>Confused yet?  Let's look at the actual code and see if it makes sense in context.
<div class=example><h3>Example 10.23. Handling command-line arguments in <code>kgp.py</code></h3><pre><code>
def main(argv):        <span>&#x2460;</span>
    grammar = "kant.xml"                
    try:              
        opts, args = getopt.getopt(argv, "hg:d", ["help", "grammar="])
    except getopt.GetoptError:          
        usage()       
        sys.exit(2)   
    for opt, arg in opts:                <span>&#x2461;</span>
        if opt in ("-h", "--help"):      <span>&#x2462;</span>
            usage()   
            sys.exit()
        elif opt == '-d':                <span>&#x2463;</span>
            global _debug               
            _debug = 1
        elif opt in ("-g", "--grammar"): <span>&#x2464;</span>
            grammar = arg               

    source = "".join(args)               <span>&#x2465;</span>

    k = KantGenerator(grammar, source)
    print k.output()</pre><div class=calloutlist>
<ol>
<li>The <var>grammar</var> variable will keep track of the grammar file you're using. You initialize it here in case it's not specified on the command
            line (using either the <code>-g</code> or the <code>--grammar</code> flag).
<li>The <var>opts</var> variable that you get back from <code>getopt</code> contains a list of tuples: <var>flag</var> and <var>argument</var>. If the flag doesn't take an argument, then <var>arg</var> will simply be <code>None</code>. This makes it easier to loop through the flags.
<li><code>getopt</code> validates that the command-line flags are acceptable, but it doesn't do any sort of conversion between short and long flags.
             If you specify the <code>-h</code> flag, <var>opt</var> will contain <code>"-h"</code>; if you specify the <code>--help</code> flag, <var>opt</var> will contain <code>"--help"</code>. So you need to check for both.
<li>Remember, the <code>-d</code> flag didn't have a corresponding long flag, so you only need to check for the short form. If you find it, you set a global
            variable that you'll refer to later to print out debugging information. (I used this during the development of the script.
             What, you thought all these examples worked on the first try?)
<li>If you find a grammar file, either with a <code>-g</code> flag or a <code>--grammar</code> flag, you save the argument that followed it (stored in <var>arg</var>) into the <var>grammar</var> variable, overwriting the default that you initialized at the top of the <code>main</code> function.
<li>That's it. You've looped through and dealt with all the command-line flags. That means that anything left must be command-line
            arguments. These come back from the <code>getopt</code> function in the <var>args</var> variable. In this case, you're treating them as source material for the parser. If there are no command-line arguments
            specified, <var>args</var> will be an empty list, and <var>source</var> will end up as the empty string.
<h2 id="kgp.alltogether">10.7. Putting it all together</h2>
<p>You've covered a lot of ground. Let's step back and see how all the pieces fit together.
<p>To start with, this is a script that <a href="#kgp.commandline" title="10.6. Handling command-line arguments">takes its arguments on the command line</a>, using the <code>getopt</code> module.
<pre><code>
def main(argv):       
...
    try:              
        opts, args = getopt.getopt(argv, "hg:d", ["help", "grammar="])
    except getopt.GetoptError:          
...
    for opt, arg in opts:               
...</pre><p>You create a new instance of the <code>KantGenerator</code> class, and pass it the grammar file and source that may or may not have been specified on the command line.
<pre><code>
    k = KantGenerator(grammar, source)</pre><p>The <code>KantGenerator</code> instance automatically loads the grammar, which is an <abbr>XML</abbr> file. You use your custom <code>openAnything</code> function to open the file (which <a href="#kgp.openanything" title="10.1. Abstracting input sources">could be stored in a local file or a remote web server</a>), then use the built-in <code>minidom</code> parsing functions to <a href="#kgp.parse" title="9.3. Parsing XML">parse the <abbr>XML</abbr> into a tree of Python objects</a>.
<pre><code>
    def _load(self, source):
        sock = toolbox.openAnything(source)
        xmldoc = minidom.parse(sock).documentElement
        sock.close()</pre><p>Oh, and along the way, you take advantage of your knowledge of the structure of the <abbr>XML</abbr> document to <a href="#kgp.cache" title="10.3. Caching node lookups">set up a little cache of references</a>, which are just elements in the <abbr>XML</abbr> document.
<pre><code>
    def loadGrammar(self, grammar):       
        for ref in self.grammar.getElementsByTagName("ref"):
            self.refs[ref.attributes["id"].value] = ref     </pre><p>If you specified some source material on the command line, you use that; otherwise you rip through the grammar looking for
the "top-level" reference (that isn't referenced by anything else) and use that as a starting point.
<pre><code>
    def getDefaultSource(self):
        xrefs = {}
        for xref in self.grammar.getElementsByTagName("xref"):
            xrefs[xref.attributes["id"].value] = 1
        xrefs = xrefs.keys()
        standaloneXrefs = [e for e in self.refs.keys() if e not in xrefs]
        return '&lt;xref id="%s"/>' % random.choice(standaloneXrefs)</pre><p>Now you rip through the source material. The source material is also <abbr>XML</abbr>, and you parse it one node at a time. To keep the code separated and more maintainable, you use <a href="#kgp.handler" title="10.5. Creating separate handlers by node type">separate handlers for each node type</a>.
<pre><code>
    def parse_Element(self, node): 
        handlerMethod = getattr(self, "do_%s" % node.tagName)
        handlerMethod(node)</pre><p>You bounce through the grammar, <a href="#kgp.child" title="10.4. Finding direct children of a node">parsing all the children</a> of each <code>p</code> element,
<pre><code>
    def do_p(self, node):
...
        if doit:
            for child in node.childNodes: self.parse(child)</pre><p>replacing <code>choice</code> elements with a random child,
<pre><code>
    def do_choice(self, node):
        self.parse(self.randomChildElement(node))</pre><p>and replacing <code>xref</code> elements with a random child of the corresponding <code>ref</code> element, which you previously cached.
<pre><code>
    def do_xref(self, node):
        id = node.attributes["id"].value
        self.parse(self.randomChildElement(self.refs[id]))</pre><p>Eventually, you parse your way down to plain text,
<pre><code>
    def parse_Text(self, node):    
        text = node.data
...
            self.pieces.append(text)</pre><p>which you print out.
<pre><code>
def main(argv):       
...
    k = KantGenerator(grammar, source)
    print k.output()</pre><h2 id="kgp.summary">10.8. Summary</h2>
<p>Python comes with powerful libraries for parsing and manipulating <abbr>XML</abbr> documents. The <code>minidom</code> takes an <abbr>XML</abbr> file and parses it into Python objects, providing for random access to arbitrary elements. Furthermore, this chapter shows how Python can be used to create a "real" standalone command-line script, complete with command-line flags, command-line arguments,
   error handling, even the ability to take input from the piped result of a previous program.
<p>Before moving on to the next chapter, you should be comfortable doing all of these things:
<div class=itemizedlist>
<ul>
<li><a href="#kgp.stdio" title="10.2. Standard input, output, and error">Chaining programs</a> with standard input and output

<li><a href="#kgp.handler" title="10.5. Creating separate handlers by node type">Defining dynamic dispatchers</a> with <code>getattr</code>.

<li><a href="#kgp.commandline" title="10.6. Handling command-line arguments">Using command-line flags</a> and validating them with <code>getopt</code>
</ul>
<div class=chapter>
<h2 id="oa">Chapter 11. HTTP Web Services</h2>
<h2 id="oa.divein">11.1. Diving in</h2>
<p>You've learned about <a href="#dialect" title="Chapter 8. HTML Processing">HTML processing</a> and <a href="#kgp" title="Chapter 9. XML Processing">XML processing</a>, and along the way you saw <a href="#dialect.extract.urllib" title="Example 8.5. Introducing urllib">how to download a web page</a> and <a href="#kgp.openanything.urllib" title="Example 10.2. Parsing XML from a URL">how to parse XML from a URL</a>, but let's dive into the more general topic of HTTP web services.
<p>Simply stated, HTTP web services are programmatic ways of sending and receiving data from remote servers using the operations
of HTTP directly. If you want to get data from the server, use a straight HTTP GET; if you want to send new data to the server,
use HTTP POST. (Some more advanced HTTP web service APIs also define ways of modifying existing data and deleting data, using
HTTP PUT and HTTP DELETE.)  In other words, the &#8220;verbs&#8221; built into the HTTP protocol (GET, POST, PUT, and DELETE) map directly to application-level operations for receiving, sending,
modifying, and deleting data.
<p>The main advantage of this approach is simplicity, and its simplicity has proven popular with a lot of different sites. Data
-- usually XML data -- can be built and stored statically, or generated dynamically by a server-side script, and all major
languages include an HTTP library for downloading it. Debugging is also easier, because you can load up the web service in
any web browser and see the raw data. Modern browsers will even nicely format and pretty-print XML data for you, to allow
you to quickly navigate through it.
<p>Examples of pure XML-over-HTTP web services:
<div class=itemizedlist>
<ul>
<li><a href="http://www.amazon.com/webservices">Amazon API</a> allows you to retrieve product information from the Amazon.com online store.

<li><a href="http://www.nws.noaa.gov/alerts/">National Weather Service</a> (United States) and <a href="http://demo.xml.weather.gov.hk/">Hong Kong Observatory</a> (Hong Kong) offer weather alerts as a web service.

<li><a href="http://atomenabled.org/">Atom API</a> for managing web-based content.

<li><a href="http://syndic8.com/">Syndicated feeds</a> from weblogs and news sites bring you up-to-the-minute news from a variety of sites.

</ul>
<p>In later chapters, you'll explore APIs which use HTTP as a transport for sending and receiving data, but don't map application
semantics to the underlying HTTP semantics. (They tunnel everything over HTTP POST.)  But this chapter will concentrate on
using HTTP GET to get data from a remote server, and you'll explore several HTTP features you can use to get the maximum benefit
out of pure HTTP web services.
<p>Here is a more advanced version of the <code>openanything</code> module that you saw in <a href="#streams" title="Chapter 10. Scripts and Streams">the previous chapter</a>:
<div class=example><h3>Example 11.1. <code>openanything.py</code></h3>
<p>If you have not already done so, you can <a href="http://diveintopython3.org/download/diveintopython3-examples-5.4.zip" title="Download example scripts">download this and other examples</a> used in this book.
<pre><code>
import urllib2, urlparse, gzip
from StringIO import StringIO

USER_AGENT = 'OpenAnything/1.0 +http://diveintopython3.org/http_web_services/'

class SmartRedirectHandler(urllib2.HTTPRedirectHandler):    
    def http_error_301(self, req, fp, code, msg, headers):  
        result = urllib2.HTTPRedirectHandler.http_error_301(
            self, req, fp, code, msg, headers)              
        result.status = code              
        return result   

    def http_error_302(self, req, fp, code, msg, headers):  
        result = urllib2.HTTPRedirectHandler.http_error_302(
            self, req, fp, code, msg, headers)              
        result.status = code              
        return result   

class DefaultErrorHandler(urllib2.HTTPDefaultErrorHandler):   
    def http_error_default(self, req, fp, code, msg, headers):
        result = urllib2.HTTPError(         
            req.get_full_url(), code, msg, headers, fp)       
        result.status = code                
        return result     

def openAnything(source, etag=None, lastmodified=None, agent=USER_AGENT):
    '''URL, filename, or string --> stream

    This function lets you define parsers that take any input source
    (URL, pathname to local or network file, or actual data as a string)
    and deal with it in a uniform manner. Returned object is guaranteed
    to have all the basic stdio read methods (read, readline, readlines).
    Just .close() the object when you're done with it.

    If the etag argument is supplied, it will be used as the value of an
    If-None-Match request header.

    If the lastmodified argument is supplied, it must be a formatted
    date/time string in GMT (as returned in the Last-Modified header of
    a previous request). The formatted date/time will be used
    as the value of an If-Modified-Since request header.

    If the agent argument is supplied, it will be used as the value of a
    User-Agent request header.
    '''

    if hasattr(source, 'read'):
        return source

    if source == '-':
        return sys.stdin

    if urlparse.urlparse(source)[0] == 'http':  
        # open URL with urllib2                 
        request = urllib2.Request(source)       
        request.add_header('User-Agent', agent) 
        if etag:              
            request.add_header('If-None-Match', etag)             
        if lastmodified:      
            request.add_header('If-Modified-Since', lastmodified) 
        request.add_header('Accept-encoding', 'gzip')             
        opener = urllib2.build_opener(SmartRedirectHandler(), DefaultErrorHandler())
        return opener.open(request)             
    
    # try to open with native open function (if source is a filename)
    try:
        return open(source)
    except (IOError, OSError):
        pass

    # treat source as string
    return StringIO(str(source))

def fetch(source, etag=None, last_modified=None, agent=USER_AGENT):  
    '''Fetch data and metadata from a URL, file, stream, or string'''
    result = {}
    f = openAnything(source, etag, last_modified, agent)             
    result['data'] = f.read()    
    if hasattr(f, 'headers'):    
        # save ETag, if the server sent one        
        result['etag'] = f.headers.get('ETag')     
        # save Last-Modified header, if the server sent one          
        result['lastmodified'] = f.headers.get('Last-Modified')      
        if f.headers.get('content-encoding', '') == 'gzip':          
            # data came back gzip-compressed, decompress it          
            result['data'] = gzip.GzipFile(fileobj=StringIO(result['data']])).read()
    if hasattr(f, 'url'):        
        result['url'] = f.url    
        result['status'] = 200   
    if hasattr(f, 'status'):     
        result['status'] = f.status                
    f.close()  
    return result                
</pre><div class=itemizedlist>
<h3>Further reading</h3>
<ul>
<li>Paul Prescod believes that <a href="http://webservices.xml.com/pub/a/ws/2002/02/06/rest.html">pure HTTP web services are the future of the Internet</a>.

</ul>
<h2 id="oa.review">11.2. How not to fetch data over HTTP</h2>
<p>Let's say you want to download a resource over HTTP, such as a syndicated Atom feed. But you don't just want to download
   it once; you want to download it over and over again, every hour, to get the latest news from the site that's offering the
   news feed. Let's do it the quick-and-dirty way first, and then see how you can do better.
<div class=example><h3>Example 11.2. Downloading a feed the quick-and-dirty way</h3><pre class=screen>
<samp class=prompt>>>> </samp><kbd>import urllib</kbd>
<samp class=prompt>>>> </samp><kbd>data = urllib.urlopen('http://diveintomark.org/xml/atom.xml').read()</kbd>    <span>&#x2460;</span>
<samp class=prompt>>>> </samp><kbd>print data</kbd>
<samp>&lt;?xml version="1.0" encoding="iso-8859-1"?>
&lt;feed version="0.3"
  xmlns="http://purl.org/atom/ns#"
  xmlns:dc="http://purl.org/dc/elements/1.1/"
  xml:lang="en">
  &lt;title mode="escaped">dive into mark&lt;/title>
  &lt;link rel="alternate" type="text/html" href="http://diveintomark.org/"/>
  &lt;-- rest of feed omitted for brevity --></span>
</pre><div class=calloutlist>
<ol>
<li>Downloading anything over HTTP is incredibly easy in Python; in fact, it's a one-liner. The <code>urllib</code> module has a handy <code>urlopen</code> function that takes the address of the page you want, and returns a file-like object that you can just <code>read()</code> from to get the full contents of the page. It just can't get much easier.
<p>So what's wrong with this?  Well, for a quick one-off during testing or development, there's nothing wrong with it. I do
it all the time. I wanted the contents of the feed, and I got the contents of the feed. The same technique works for any
web page. But once you start thinking in terms of a web service that you want to access on a regular basis -- and remember,
you said you were planning on retrieving this syndicated feed once an hour -- then you're being inefficient, and you're being
rude.
<p>Let's talk about some of the basic features of HTTP.
<h2 id="oa.features">11.3. Features of HTTP</h2>
<p>There are five important features of HTTP which you should support.
<h3>11.3.1. <code>User-Agent</code></h3>
<p>The <code>User-Agent</code> is simply a way for a client to tell a server who it is when it requests a web page, a syndicated feed, or any sort of web
   service over HTTP. When the client requests a resource, it should always announce who it is, as specifically as possible.
   This allows the server-side administrator to get in touch with the client-side developer if anything is going fantastically
   wrong.
<p>By default, Python sends a generic <code>User-Agent</code>: <code>Python-urllib/1.15</code>. In the next section, you'll see how to change this to something more specific.
<h3>11.3.2. Redirects</h3>
<p>Sometimes resources move around. Web sites get reorganized, pages move to new addresses. Even web services can reorganize.
   A syndicated feed at <code>http://example.com/index.xml</code> might be moved to <code>http://example.com/xml/atom.xml</code>. Or an entire domain might move, as an organization expands and reorganizes; for instance, <code>http://www.example.com/index.xml</code> might be redirected to <code>http://server-farm-1.example.com/index.xml</code>.
<p>Every time you request any kind of resource from an HTTP server, the server includes a status code in its response. Status
   code <code>200</code> means &#8220;everything's normal, here's the page you asked for&#8221;. Status code <code>404</code> means &#8220;page not found&#8221;. (You've probably seen 404 errors while browsing the web.)
<p>HTTP has two different ways of signifying that a resource has moved. Status code <code>302</code> is a <em>temporary redirect</em>; it means &#8220;oops, that got moved over here temporarily&#8221; (and then gives the temporary address in a <code>Location:</code> header). Status code <code>301</code> is a <em>permanent redirect</em>; it means &#8220;oops, that got moved permanently&#8221; (and then gives the new address in a <code>Location:</code> header). If you get a <code>302</code> status code and a new address, the HTTP specification says you should use the new address to get what you asked for, but
   the next time you want to access the same resource, you should retry the old address. But if you get a <code>301</code> status code and a new address, you're supposed to use the new address from then on.
<p><code>urllib.urlopen</code> will automatically &#8220;follow&#8221; redirects when it receives the appropriate status code from the HTTP server, but unfortunately, it doesn't tell you when
   it does so. You'll end up getting data you asked for, but you'll never know that the underlying library &#8220;helpfully&#8221; followed a redirect for you. So you'll continue pounding away at the old address, and each time you'll get redirected to
   the new address. That's two round trips instead of one: not very efficient!  Later in this chapter, you'll see how to work
   around this so you can deal with permanent redirects properly and efficiently.
<h3>11.3.3. <code>Last-Modified</code>/<code>If-Modified-Since</code></h3>
<p>Some data changes all the time. The home page of CNN.com is constantly updating every few minutes. On the other hand, the
   home page of Google.com only changes once every few weeks (when they put up a special holiday logo, or advertise a new service).
   Web services are no different; usually the server knows when the data you requested last changed, and HTTP provides a way
   for the server to include this last-modified date along with the data you requested.
<p>If you ask for the same data a second time (or third, or fourth), you can tell the server the last-modified date that you
   got last time: you send an <code>If-Modified-Since</code> header with your request, with the date you got back from the server last time. If the data hasn't changed since then, the
   server sends back a special HTTP status code <code>304</code>, which means &#8220;this data hasn't changed since the last time you asked for it&#8221;. Why is this an improvement?  Because when the server sends a <code>304</code>, <em>it doesn't re-send the data</em>. All you get is the status code. So you don't need to download the same data over and over again if it hasn't changed;
   the server assumes you have the data cached locally.
<p>All modern web browsers support last-modified date checking. If you've ever visited a page, re-visited the same page a day
   later and found that it hadn't changed, and wondered why it loaded so quickly the second time -- this could be why. Your
   web browser cached the contents of the page locally the first time, and when you visited the second time, your browser automatically
   sent the last-modified date it got from the server the first time. The server simply says <code>304: Not Modified</code>, so your browser knows to load the page from its cache. Web services can be this smart too.
<p>Python's URL library has no built-in support for last-modified date checking, but since you can add arbitrary headers to each request
   and read arbitrary headers in each response, you can add support for it yourself.
<h3>11.3.4. <code>ETag</code>/<code>If-None-Match</code></h3>
<p>ETags are an alternate way to accomplish the same thing as the last-modified date checking: don't re-download data that hasn't
   changed. The way it works is, the server sends some sort of hash of the data (in an <code>ETag</code> header) along with the data you requested. Exactly how this hash is determined is entirely up to the server. The second
   time you request the same data, you include the ETag hash in an <code>If-None-Match:</code> header, and if the data hasn't changed, the server will send you back a <code>304</code> status code. As with the last-modified date checking, the server <em>just</em> sends the <code>304</code>; it doesn't send you the same data a second time. By including the ETag hash in your second request, you're telling the
   server that there's no need to re-send the same data if it still matches this hash, since you still have the data from the
   last time.
<p>Python's URL library has no built-in support for ETags, but you'll see how to add it later in this chapter.
<h3>11.3.5. Compression</h3>
<p>The last important HTTP feature is gzip compression. When you talk about HTTP web services, you're almost always talking
   about moving XML back and forth over the wire. XML is text, and quite verbose text at that, and text generally compresses
   well. When you request a resource over HTTP, you can ask the server that, if it has any new data to send you, to please send
   it in compressed format. You include the <code>Accept-encoding: gzip</code> header in your request, and if the server supports compression, it will send you back gzip-compressed data and mark it with
   a <code>Content-encoding: gzip</code> header.
<p>Python's URL library has no built-in support for gzip compression per se, but you can add arbitrary headers to the request. And
Python comes with a separate <code>gzip</code> module, which has functions you can use to decompress the data yourself.
<p>Note that <a href="#oa.review" title="11.2. How not to fetch data over HTTP">our little one-line script</a> to download a syndicated feed did not support any of these HTTP features. Let's see how you can improve it.
<h2 id="oa.debug">11.4. Debugging HTTP web services</h2>
<p>First, let's turn on the debugging features of Python's HTTP library and see what's being sent over the wire. This will be useful throughout the chapter, as you add more and
   more features.
<div class=example><h3>Example 11.3. Debugging HTTP</h3><pre class=screen>
<samp class=prompt>>>> </samp><kbd>import httplib</kbd>
<samp class=prompt>>>> </samp><kbd>httplib.HTTPConnection.debuglevel = 1</kbd>             <span>&#x2460;</span>
<samp class=prompt>>>> </samp><kbd>import urllib</kbd>
<samp class=prompt>>>> </samp><kbd>feeddata = urllib.urlopen('http://diveintomark.org/xml/atom.xml').read()</kbd>
connect: (diveintomark.org, 80)     <span>&#x2461;</span>
send: '
GET /xml/atom.xml HTTP/1.0          <span>&#x2462;</span>
Host: diveintomark.org              <span>&#x2463;</span>
User-agent: Python-urllib/1.15      <span>&#x2464;</span>
'
reply: 'HTTP/1.1 200 OK\r\n'        <span>&#x2465;</span>
header: Date: Wed, 14 Apr 2004 22:27:30 GMT
header: Server: Apache/2.0.49 (Debian GNU/Linux)
header: Content-Type: application/atom+xml
header: Last-Modified: Wed, 14 Apr 2004 22:14:38 GMT  <span>&#x2466;</span>
header: ETag: "e8284-68e0-4de30f80" <span>&#x2467;</span>
header: Accept-Ranges: bytes
header: Content-Length: 26848
header: Connection: close
</pre><div class=calloutlist>
<ol>
<li><code>urllib</code> relies on another standard Python library, <code>httplib</code>. Normally you don't need to <code>import httplib</code> directly (<code>urllib</code> does that automatically), but you will here so you can set the debugging flag on the <code>HTTPConnection</code> class that <code>urllib</code> uses internally to connect to the HTTP server. This is an incredibly useful technique. Some other Python libraries have similar debug flags, but there's no particular standard for naming them or turning them on; you need to read
         the documentation of each library to see if such a feature is available.
<li>Now that the debugging flag is set, information on the the HTTP request and response is printed out in real time. The first
         thing it tells you is that you're connecting to the server <code>diveintomark.org</code> on port 80, which is the standard port for HTTP.
<li>When you request the Atom feed, <code>urllib</code> sends three lines to the server. The first line specifies the HTTP verb you're using, and the path of the resource (minus
         the domain name). All the requests in this chapter will use <code>GET</code>, but in the next chapter on <abbr>SOAP</abbr>, you'll see that it uses <code>POST</code> for everything. The basic syntax is the same, regardless of the verb.
<li>The second line is the <code>Host</code> header, which specifies the domain name of the service you're accessing. This is important, because a single HTTP server
         can host multiple separate domains. My server currently hosts 12 domains; other servers can host hundreds or even thousands.
<li>The third line is the <code>User-Agent</code> header. What you see here is the generic <code>User-Agent</code> that the <code>urllib</code> library adds by default. In the next section, you'll see how to customize this to be more specific.
<li>The server replies with a status code and a bunch of headers (and possibly some data, which got stored in the <var>feeddata</var> variable). The status code here is <code>200</code>, meaning &#8220;everything's normal, here's the data you requested&#8221;. The server also tells you the date it responded to your request, some information about the server itself, and the content
         type of the data it's giving you. Depending on your application, this might be useful, or not. It's certainly reassuring
         that you thought you were asking for an Atom feed, and lo and behold, you're getting an Atom feed (<code>application/atom+xml</code>, which is the registered content type for Atom feeds).
<li>The server tells you when this Atom feed was last modified (in this case, about 13 minutes ago). You can send this date back
         to the server the next time you request the same feed, and the server can do last-modified checking.
<li>The server also tells you that this Atom feed has an ETag hash of <code>"e8284-68e0-4de30f80"</code>. The hash doesn't mean anything by itself; there's nothing you can do with it, except send it back to the server the next
         time you request this same feed. Then the server can use it to tell you if the data has changed or not.
<h2 id="oa.useragent">11.5. Setting the <code>User-Agent</code></h2>
<p>The first step to improving your HTTP web services client is to identify yourself properly with a <code>User-Agent</code>. To do that, you need to move beyond the basic <code>urllib</code> and dive into <code>urllib2</code>.
<div class=example><h3>Example 11.4. Introducing <code>urllib2</code></h3><pre class=screen>
<samp class=prompt>>>> </samp><kbd>import httplib</kbd>
<samp class=prompt>>>> </samp><kbd>httplib.HTTPConnection.debuglevel = 1</kbd>           <span>&#x2460;</span>
<samp class=prompt>>>> </samp><kbd>import urllib2</kbd>
<samp class=prompt>>>> </samp><kbd>request = urllib2.Request('http://diveintomark.org/xml/atom.xml')</kbd> <span>&#x2461;</span>
<samp class=prompt>>>> </samp><kbd>opener = urllib2.build_opener()</kbd>                 <span>&#x2462;</span>
<samp class=prompt>>>> </samp><kbd>feeddata = opener.open(request).read()</kbd>          <span>&#x2463;</span>
connect: (diveintomark.org, 80)
send: '
GET /xml/atom.xml HTTP/1.0
Host: diveintomark.org
User-agent: Python-urllib/2.1
'
reply: 'HTTP/1.1 200 OK\r\n'
header: Date: Wed, 14 Apr 2004 23:23:12 GMT
header: Server: Apache/2.0.49 (Debian GNU/Linux)
header: Content-Type: application/atom+xml
header: Last-Modified: Wed, 14 Apr 2004 22:14:38 GMT
header: ETag: "e8284-68e0-4de30f80"
header: Accept-Ranges: bytes
header: Content-Length: 26848
header: Connection: close
</pre><div class=calloutlist>
<ol>
<li>If you still have your Python <abbr>IDE</abbr> open from the previous section's example, you can skip this, but this turns on <a href="#oa.debug" title="11.4. Debugging HTTP web services">HTTP debugging</a> so you can see what you're actually sending over the wire, and what gets sent back.
<li>Fetching an HTTP resource with <code>urllib2</code> is a three-step process, for good reasons that will become clear shortly. The first step is to create a <code>Request</code> object, which takes the URL of the resource you'll eventually get around to retrieving. Note that this step doesn't actually
            retrieve anything yet.
<li>The second step is to build a URL opener. This can take any number of handlers, which control how responses are handled.
             But you can also build an opener without any custom handlers, which is what you're doing here. You'll see how to define
            and use custom handlers later in this chapter when you explore redirects.
<li>The final step is to tell the opener to open the URL, using the <code>Request</code> object you created. As you can see from all the debugging information that gets printed, this step actually retrieves the
            resource and stores the returned data in <var>feeddata</var>.
<div class=example><h3>Example 11.5. Adding headers with the <code>Request</code></h3><pre class=screen>
<samp class=prompt>>>> </samp><kbd>request</kbd>            <span>&#x2460;</span>
&lt;urllib2.Request instance at 0x00250AA8>
<samp class=prompt>>>> </samp><kbd>request.get_full_url()</kbd>
http://diveintomark.org/xml/atom.xml
<samp class=prompt>>>> </samp><kbd>request.add_header('User-Agent',</kbd>
<samp class=prompt>...    </samp><kbd>'OpenAnything/1.0 +http://diveintopython3.org/')</kbd>    <span>&#x2461;</span>
<samp class=prompt>>>> </samp><kbd>feeddata = opener.open(request).read()</kbd>                 <span>&#x2462;</span>
connect: (diveintomark.org, 80)
send: '
GET /xml/atom.xml HTTP/1.0
Host: diveintomark.org
User-agent: OpenAnything/1.0 +http://diveintopython3.org/   <span>&#x2463;</span>
'
reply: 'HTTP/1.1 200 OK\r\n'
header: Date: Wed, 14 Apr 2004 23:45:17 GMT
header: Server: Apache/2.0.49 (Debian GNU/Linux)
header: Content-Type: application/atom+xml
header: Last-Modified: Wed, 14 Apr 2004 22:14:38 GMT
header: ETag: "e8284-68e0-4de30f80"
header: Accept-Ranges: bytes
header: Content-Length: 26848
header: Connection: close
</pre><div class=calloutlist>
<ol>
<li>You're continuing from the previous example; you've already created a <code>Request</code> object with the URL you want to access.
<li>Using the <code>add_header</code> method on the <code>Request</code> object, you can add arbitrary HTTP headers to the request. The first argument is the header, the second is the value you're
            providing for that header. Convention dictates that a <code>User-Agent</code> should be in this specific format: an application name, followed by a slash, followed by a version number. The rest is free-form,
            and you'll see a lot of variations in the wild, but somewhere it should include a URL of your application. The <code>User-Agent</code> is usually logged by the server along with other details of your request, and including a URL of your application allows
            server administrators looking through their access logs to contact you if something is wrong.
<li>The <var>opener</var> object you created before can be reused too, and it will retrieve the same feed again, but with your custom <code>User-Agent</code> header.
<li>And here's you sending your custom <code>User-Agent</code>, in place of the generic one that Python sends by default. If you look closely, you'll notice that you defined a <code>User-Agent</code> header, but you actually sent a <code>User-agent</code> header. See the difference?  <code>urllib2</code> changed the case so that only the first letter was capitalized. It doesn't really matter; HTTP specifies that header field
            names are completely case-insensitive.
<h2 id="oa.etags">11.6. Handling <code>Last-Modified</code> and <code>ETag</code></h2>
<p>Now that you know how to add custom HTTP headers to your web service requests, let's look at adding support for <code>Last-Modified</code> and <code>ETag</code> headers.
<p>These examples show the output with debugging turned off. If you still have it turned on from the previous section, you can
turn it off by setting <code>httplib.HTTPConnection.debuglevel = 0</code>. Or you can just leave debugging on, if that helps you.
<div class=example><h3 id="oa.etags.example.1">Example 11.6. Testing <code>Last-Modified</code></h3><pre class=screen>
<samp class=prompt>>>> </samp><kbd>import urllib2</kbd>
<samp class=prompt>>>> </samp><kbd>request = urllib2.Request('http://diveintomark.org/xml/atom.xml')</kbd>
<samp class=prompt>>>> </samp><kbd>opener = urllib2.build_opener()</kbd>
<samp class=prompt>>>> </samp><kbd>firstdatastream = opener.open(request)</kbd>
<samp class=prompt>>>> </samp><kbd>firstdatastream.headers.dict</kbd>     <span>&#x2460;</span>
<samp>{'date': 'Thu, 15 Apr 2004 20:42:41 GMT', 
 'server': 'Apache/2.0.49 (Debian GNU/Linux)', 
 'content-type': 'application/atom+xml',
 'last-modified': 'Thu, 15 Apr 2004 19:45:21 GMT', 
 'etag': '"e842a-3e53-55d97640"',
 'content-length': '15955', 
 'accept-ranges': 'bytes', 
 'connection': 'close'}</samp>
<samp class=prompt>>>> </samp><kbd>request.add_header('If-Modified-Since',</kbd>
<samp class=prompt>...    </samp>firstdatastream.headers.get('Last-Modified'))  <span>&#x2461;</span>
<samp class=prompt>>>> </samp><kbd>seconddatastream = opener.open(request)</kbd>            <span>&#x2462;</span>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in ?
  File "c:\python23\lib\urllib2.py", line 326, in open
    '_open', req)
  File "c:\python23\lib\urllib2.py", line 306, in _call_chain
    result = func(*args)
  File "c:\python23\lib\urllib2.py", line 901, in http_open
    return self.do_open(httplib.HTTP, req)
  File "c:\python23\lib\urllib2.py", line 895, in do_open
    return self.parent.error('http', req, fp, code, msg, hdrs)
  File "c:\python23\lib\urllib2.py", line 352, in error
    return self._call_chain(*args)
  File "c:\python23\lib\urllib2.py", line 306, in _call_chain
    result = func(*args)
  File "c:\python23\lib\urllib2.py", line 412, in http_error_default
    raise HTTPError(req.get_full_url(), code, msg, hdrs, fp)
urllib2.HTTPError: HTTP Error 304: Not Modified</span>
</pre><div class=calloutlist>
<ol>
<li>Remember all those HTTP headers you saw printed out when you turned on debugging?  This is how you can get access to them
            programmatically: <var>firstdatastream.headers</var> is <a href="#fileinfo.userdict" title="5.5. Exploring UserDict: A Wrapper Class">an object that acts like a dictionary</a> and allows you to get any of the individual headers returned from the HTTP server.
<li>On the second request, you add the <code>If-Modified-Since</code> header with the last-modified date from the first request. If the data hasn't changed, the server should return a <code>304</code> status code.
<li>Sure enough, the data hasn't changed. You can see from the traceback that <code>urllib2</code> throws a special exception, <code>HTTPError</code>, in response to the <code>304</code> status code. This is a little unusual, and not entirely helpful. After all, it's not an error; you specifically asked the
            server not to send you any data if it hadn't changed, and the data didn't change, so the server told you it wasn't sending
            you any data. That's not an error; that's exactly what you were hoping for.
<p><code>urllib2</code> also raises an <code>HTTPError</code> exception for conditions that you would think of as errors, such as <code>404</code> (page not found). In fact, it will raise <code>HTTPError</code> for <em>any</em> status code other than <code>200</code> (OK), <code>301</code> (permanent redirect), or <code>302</code> (temporary redirect). It would be more helpful for your purposes to capture the status code and simply return it, without
throwing an exception. To do that, you'll need to define a custom URL handler.
<div class=example><h3>Example 11.7. Defining URL handlers</h3>
<p>This custom URL handler is part of <code>openanything.py</code>.
<pre><code>
class DefaultErrorHandler(urllib2.HTTPDefaultErrorHandler):    <span>&#x2460;</span>
    def http_error_default(self, req, fp, code, msg, headers): <span>&#x2461;</span>
        result = urllib2.HTTPError(         
            req.get_full_url(), code, msg, headers, fp)       
        result.status = code                 <span>&#x2462;</span>
        return result     
</pre><div class=calloutlist>
<ol>
<li><code>urllib2</code> is designed around URL handlers. Each handler is just a class that can define any number of methods. When something happens
            -- like an HTTP error, or even a <code>304</code> code -- <code>urllib2</code> introspects into the list of defined handlers for a method that can handle it. You used a similar introspection in <a href="#kgp" title="Chapter 9. XML Processing">Chapter 9, <i>XML Processing</i></a> to define handlers for different node types, but <code>urllib2</code> is more flexible, and introspects over as many handlers as are defined for the current request.
<li><code>urllib2</code> searches through the defined handlers and calls the <code>http_error_default</code> method when it encounters a <code>304</code> status code from the server. By defining a custom error handler, you can prevent <code>urllib2</code> from raising an exception. Instead, you create the <code>HTTPError</code> object, but return it instead of raising it.
<li>This is the key part: before returning, you save the status code returned by the HTTP server. This will allow you easy access
            to it from the calling program.
<div class=example><h3>Example 11.8. Using custom URL handlers</h3><pre class=screen>
<samp class=prompt>>>> </samp><kbd>request.headers</kbd>         <span>&#x2460;</span>
{'If-modified-since': 'Thu, 15 Apr 2004 19:45:21 GMT'}
<samp class=prompt>>>> </samp><kbd>import openanything</kbd>
<samp class=prompt>>>> </samp><kbd>opener = urllib2.build_opener(</kbd>
<samp class=prompt>...    </samp>openanything.DefaultErrorHandler())   <span>&#x2461;</span>
<samp class=prompt>>>> </samp><kbd>seconddatastream = opener.open(request)</kbd>
<samp class=prompt>>>> </samp><kbd>seconddatastream.status</kbd> <span>&#x2462;</span>
304
<samp class=prompt>>>> </samp><kbd>seconddatastream.read()</kbd> <span>&#x2463;</span>
''
</pre><div class=calloutlist>
<ol>
<li>You're continuing the previous example, so the <code>Request</code> object is already set up, and you've already added the <code>If-Modified-Since</code> header.
<li>This is the key: now that you've defined your custom URL handler, you need to tell <code>urllib2</code> to use it. Remember how I said that <code>urllib2</code> broke up the process of accessing an HTTP resource into three steps, and for good reason?  This is why building the URL opener
            is its own step, because you can build it with your own custom URL handlers that override <code>urllib2</code>'s default behavior.
<li>Now you can quietly open the resource, and what you get back is an object that, along with the usual headers (use <var>seconddatastream.headers.dict</var> to acess them), also contains the HTTP status code. In this case, as you expected, the status is <code>304</code>, meaning this data hasn't changed since the last time you asked for it.
<li>Note that when the server sends back a <code>304</code> status code, it doesn't re-send the data. That's the whole point: to save bandwidth by not re-downloading data that hasn't
            changed. So if you actually want that data, you'll need to cache it locally the first time you get it.
<p>Handling <code>ETag</code> works much the same way, but instead of checking for <code>Last-Modified</code> and sending <code>If-Modified-Since</code>, you check for <code>ETag</code> and send <code>If-None-Match</code>. Let's start with a fresh <abbr>IDE</abbr> session.
<div class=example><h3 id="oa.etags.example">Example 11.9. Supporting <code>ETag</code>/<code>If-None-Match</code></h3><pre class=screen>
<samp class=prompt>>>> </samp><kbd>import urllib2, openanything</kbd>
<samp class=prompt>>>> </samp><kbd>request = urllib2.Request('http://diveintomark.org/xml/atom.xml')</kbd>
<samp class=prompt>>>> </samp><kbd>opener = urllib2.build_opener(</kbd>
<samp class=prompt>...    </samp>openanything.DefaultErrorHandler())
<samp class=prompt>>>> </samp><kbd>firstdatastream = opener.open(request)</kbd>
<samp class=prompt>>>> </samp><kbd>firstdatastream.headers.get('ETag')</kbd>        <span>&#x2460;</span>
'"e842a-3e53-55d97640"'
<samp class=prompt>>>> </samp><kbd>firstdata = firstdatastream.read()</kbd>
<samp class=prompt>>>> </samp><kbd>print firstdata</kbd>          <span>&#x2461;</span>
<samp>&lt;?xml version="1.0" encoding="iso-8859-1"?>
&lt;feed version="0.3"
  xmlns="http://purl.org/atom/ns#"
  xmlns:dc="http://purl.org/dc/elements/1.1/"
  xml:lang="en">
  &lt;title mode="escaped">dive into mark&lt;/title>
  &lt;link rel="alternate" type="text/html" href="http://diveintomark.org/"/>
  &lt;-- rest of feed omitted for brevity --></samp>
<samp class=prompt>>>> </samp><kbd>request.add_header('If-None-Match',</kbd>
<samp class=prompt>...    </samp>firstdatastream.headers.get('ETag'))   <span>&#x2462;</span>
<samp class=prompt>>>> </samp><kbd>seconddatastream = opener.open(request)</kbd>
<samp class=prompt>>>> </samp><kbd>seconddatastream.status</kbd>  <span>&#x2463;</span>
304
<samp class=prompt>>>> </samp><kbd>seconddatastream.read()</kbd>  <span>&#x2464;</span>
''
</pre><div class=calloutlist>
<ol>
<li>Using the <var>firstdatastream.headers</var> pseudo-dictionary, you can get the <code>ETag</code> returned from the server. (What happens if the server didn't send back an <code>ETag</code>?  Then this line would return <code>None</code>.)
<li>OK, you got the data.
<li>Now set up the second call by setting the <code>If-None-Match</code> header to the <code>ETag</code> you got from the first call.
<li>The second call succeeds quietly (without throwing an exception), and once again you see that the server has sent back a <code>304</code> status code. Based on the <code>ETag</code> you sent the second time, it knows that the data hasn't changed.
<li>Regardless of whether the <code>304</code> is triggered by <code>Last-Modified</code> date checking or <code>ETag</code> hash matching, you'll never get the data along with the <code>304</code>. That's the whole point.
<table id="tip.etag.vs.lastmodified" class=note border="0" summary="">

<td rowspan="2" align="center" valign="top" width="1%"><img src="images/note.png" alt="Note" title="" width="24" height="24"><td colspan="2" align="left" valign="top" width="99%">In these examples, the HTTP server has supported both <code>Last-Modified</code> and <code>ETag</code> headers, but not all servers do. As a web services client, you should be prepared to support both, but you must code defensively
      in case a server only supports one or the other, or neither.
<h2 id="oa.redirect">11.7. Handling redirects</h2>
<p>You can support permanent and temporary redirects using a different kind of custom URL handler.
<p>First, let's see why a redirect handler is necessary in the first place.
<div class=example><h3>Example 11.10. Accessing web services without a redirect handler</h3><pre class=screen>
<samp class=prompt>>>> </samp><kbd>import urllib2, httplib</kbd>
<samp class=prompt>>>> </samp><kbd>httplib.HTTPConnection.debuglevel = 1</kbd>           <span>&#x2460;</span>
<samp class=prompt>>>> </samp><kbd>request = urllib2.Request(</kbd>
<samp class=prompt>...    </samp>'http://diveintomark.org/redir/example301.xml') <span>&#x2461;</span>
<samp class=prompt>>>> </samp><kbd>opener = urllib2.build_opener()</kbd>
<samp class=prompt>>>> </samp><kbd>f = opener.open(request)</kbd>
<samp>connect: (diveintomark.org, 80)
send: '
GET /redir/example301.xml HTTP/1.0
Host: diveintomark.org
User-agent: Python-urllib/2.1
'
reply: 'HTTP/1.1 301 Moved Permanently\r\n'</span>             <span>&#x2462;</span>
<samp>header: Date: Thu, 15 Apr 2004 22:06:25 GMT
header: Server: Apache/2.0.49 (Debian GNU/Linux)
header: Location: http://diveintomark.org/xml/atom.xml</span>  <span>&#x2463;</span>
<samp>header: Content-Length: 338
header: Connection: close
header: Content-Type: text/html; charset=iso-8859-1
connect: (diveintomark.org, 80)
send: '
GET /xml/atom.xml HTTP/1.0</span>            <span>&#x2464;</span>
<samp>Host: diveintomark.org
User-agent: Python-urllib/2.1
'
reply: 'HTTP/1.1 200 OK\r\n'
header: Date: Thu, 15 Apr 2004 22:06:25 GMT
header: Server: Apache/2.0.49 (Debian GNU/Linux)
header: Last-Modified: Thu, 15 Apr 2004 19:45:21 GMT
header: ETag: "e842a-3e53-55d97640"
header: Accept-Ranges: bytes
header: Content-Length: 15955
header: Connection: close
header: Content-Type: application/atom+xml</samp>
<samp class=prompt>>>> </samp><kbd>f.url</kbd>           <span>&#x2465;</span>
'http://diveintomark.org/xml/atom.xml'
<samp class=prompt>>>> </samp><kbd>f.headers.dict</kbd>
<samp>{'content-length': '15955', 
'accept-ranges': 'bytes', 
'server': 'Apache/2.0.49 (Debian GNU/Linux)', 
'last-modified': 'Thu, 15 Apr 2004 19:45:21 GMT', 
'connection': 'close', 
'etag': '"e842a-3e53-55d97640"', 
'date': 'Thu, 15 Apr 2004 22:06:25 GMT', 
'content-type': 'application/atom+xml'}</samp>
<samp class=prompt>>>> </samp><kbd>f.status</kbd>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in ?
AttributeError: addinfourl instance has no attribute 'status'</span>
</pre><div class=calloutlist>
<ol>
<li>You'll be better able to see what's happening if you turn on debugging.
<li>This is a URL which I have set up to permanently redirect to my Atom feed at <code>http://diveintomark.org/xml/atom.xml</code>.
<li>Sure enough, when you try to download the data at that address, the server sends back a <code>301</code> status code, telling you that the resource has moved permanently.
<li>The server also sends back a <code>Location:</code> header that gives the new address of this data.
<li><code>urllib2</code> notices the redirect status code and automatically tries to retrieve the data at the new location specified in the <code>Location:</code> header.
<li>The object you get back from the <var>opener</var> contains the new permanent address and all the headers returned from the second request (retrieved from the new permanent
            address). But the status code is missing, so you have no way of knowing programmatically whether this redirect was temporary
            or permanent. And that matters very much: if it was a temporary redirect, then you should continue to ask for the data at
            the old location. But if it was a permanent redirect (as this was), you should ask for the data at the new location from
            now on.
<p>This is suboptimal, but easy to fix. <code>urllib2</code> doesn't behave exactly as you want it to when it encounters a <code>301</code> or <code>302</code>, so let's override its behavior. How?  With a custom URL handler, <a href="#oa.etags" title="11.6. Handling Last-Modified and ETag">just like you did to handle <code>304</code> codes</a>.
<div class=example><h3>Example 11.11. Defining the redirect handler</h3>
<p>This class is defined in <code>openanything.py</code>.
<pre><code>
class SmartRedirectHandler(urllib2.HTTPRedirectHandler):     <span>&#x2460;</span>
    def http_error_301(self, req, fp, code, msg, headers):  
        result = urllib2.HTTPRedirectHandler.http_error_301( <span>&#x2461;</span>
            self, req, fp, code, msg, headers)              
        result.status = code               <span>&#x2462;</span>
        return result   

    def http_error_302(self, req, fp, code, msg, headers):   <span>&#x2463;</span>
        result = urllib2.HTTPRedirectHandler.http_error_302(
            self, req, fp, code, msg, headers)              
        result.status = code              
        return result   
</pre><div class=calloutlist>
<ol>
<li>Redirect behavior is defined in <code>urllib2</code> in a class called <code>HTTPRedirectHandler</code>. You don't want to completely override the behavior, you just want to extend it a little, so you'll subclass <code>HTTPRedirectHandler</code> so you can call the ancestor class to do all the hard work.
<li>When it encounters a <code>301</code> status code from the server, <code>urllib2</code> will search through its handlers and call the <code>http_error_301</code> method.  The first thing ours does is just call the <code>http_error_301</code> method in the ancestor, which handles the grunt work of looking for the <code>Location:</code> header and following the redirect to the new address.
<li>Here's the key: before you return, you store the status code (<code>301</code>), so that the calling program can access it later.
<li>Temporary redirects (status code <code>302</code>) work the same way: override the <code>http_error_302</code> method, call the ancestor, and save the status code before returning.
<p>So what has this bought us?  You can now build a URL opener with the custom redirect handler, and it will still automatically
follow redirects, but now it will also expose the redirect status code.
<div class=example><h3>Example 11.12. Using the redirect handler to detect permanent redirects</h3><pre class=screen>
<samp class=prompt>>>> </samp><kbd>request = urllib2.Request('http://diveintomark.org/redir/example301.xml')</kbd>
<samp class=prompt>>>> </samp><kbd>import openanything, httplib</kbd>
<samp class=prompt>>>> </samp><kbd>httplib.HTTPConnection.debuglevel = 1</kbd>
<samp class=prompt>>>> </samp><kbd>opener = urllib2.build_opener(</kbd>
<samp class=prompt>...    </samp>openanything.SmartRedirectHandler())           <span>&#x2460;</span>
<samp class=prompt>>>> </samp><kbd>f = opener.open(request)</kbd>
<samp>connect: (diveintomark.org, 80)
send: 'GET /redir/example301.xml HTTP/1.0
Host: diveintomark.org
User-agent: Python-urllib/2.1
'
reply: 'HTTP/1.1 301 Moved Permanently\r\n'</span>            <span>&#x2461;</span>
<samp>header: Date: Thu, 15 Apr 2004 22:13:21 GMT
header: Server: Apache/2.0.49 (Debian GNU/Linux)
header: Location: http://diveintomark.org/xml/atom.xml
header: Content-Length: 338
header: Connection: close
header: Content-Type: text/html; charset=iso-8859-1
connect: (diveintomark.org, 80)
send: '
GET /xml/atom.xml HTTP/1.0
Host: diveintomark.org
User-agent: Python-urllib/2.1
'
reply: 'HTTP/1.1 200 OK\r\n'
header: Date: Thu, 15 Apr 2004 22:13:21 GMT
header: Server: Apache/2.0.49 (Debian GNU/Linux)
header: Last-Modified: Thu, 15 Apr 2004 19:45:21 GMT
header: ETag: "e842a-3e53-55d97640"
header: Accept-Ranges: bytes
header: Content-Length: 15955
header: Connection: close
header: Content-Type: application/atom+xml
</samp>
<samp class=prompt>>>> </samp><kbd>f.status</kbd>       <span>&#x2462;</span>
301
<samp class=prompt>>>> </samp><kbd>f.url</kbd>
'http://diveintomark.org/xml/atom.xml'
</pre><div class=calloutlist>
<ol>
<li>First, build a URL opener with the redirect handler you just defined.
<li>You sent off a request, and you got a <code>301</code> status code in response. At this point, the <code>http_error_301</code> method gets called. You call the ancestor method, which follows the redirect and sends a request at the new location (<code>http://diveintomark.org/xml/atom.xml</code>).
<li>This is the payoff: now, not only do you have access to the new URL, but you have access to the redirect status code, so you
            can tell that this was a permanent redirect. The next time you request this data, you should request it from the new location
            (<code>http://diveintomark.org/xml/atom.xml</code>, as specified in <var>f.url</var>). If you had stored the location in a configuration file or a database, you need to update that so you don't keep pounding
            the server with requests at the old address. It's time to update your address book.
<p>The same redirect handler can also tell you that you <em>shouldn't</em> update your address book.
<div class=example><h3>Example 11.13. Using the redirect handler to detect temporary redirects</h3><pre class=screen>
<samp class=prompt>>>> </samp><kbd>request = urllib2.Request(</kbd>
<samp class=prompt>...    </samp>'http://diveintomark.org/redir/example302.xml')   <span>&#x2460;</span>
<samp class=prompt>>>> </samp><kbd>f = opener.open(request)</kbd>
<samp>connect: (diveintomark.org, 80)
send: '
GET /redir/example302.xml HTTP/1.0
Host: diveintomark.org
User-agent: Python-urllib/2.1
'
reply: 'HTTP/1.1 302 Found\r\n'</span>         <span>&#x2461;</span>
<samp>header: Date: Thu, 15 Apr 2004 22:18:21 GMT
header: Server: Apache/2.0.49 (Debian GNU/Linux)
header: Location: http://diveintomark.org/xml/atom.xml
header: Content-Length: 314
header: Connection: close
header: Content-Type: text/html; charset=iso-8859-1
connect: (diveintomark.org, 80)
send: '
GET /xml/atom.xml HTTP/1.0</span>              <span>&#x2462;</span>
<samp>Host: diveintomark.org
User-agent: Python-urllib/2.1
'
reply: 'HTTP/1.1 200 OK\r\n'
header: Date: Thu, 15 Apr 2004 22:18:21 GMT
header: Server: Apache/2.0.49 (Debian GNU/Linux)
header: Last-Modified: Thu, 15 Apr 2004 19:45:21 GMT
header: ETag: "e842a-3e53-55d97640"
header: Accept-Ranges: bytes
header: Content-Length: 15955
header: Connection: close
header: Content-Type: application/atom+xml</samp>
<samp class=prompt>>>> </samp><kbd>f.status</kbd>          <span>&#x2463;</span>
302
<samp class=prompt>>>> </samp><kbd>f.url</kbd>
http://diveintomark.org/xml/atom.xml
</pre><div class=calloutlist>
<ol>
<li>This is a sample URL I've set up that is configured to tell clients to <em>temporarily</em> redirect to <code>http://diveintomark.org/xml/atom.xml</code>.
<li>The server sends back a <code>302</code> status code, indicating a temporary redirect. The temporary new location of the data is given in the <code>Location:</code> header.
<li><code>urllib2</code> calls your <code>http_error_302</code> method, which calls the ancestor method of the same name in <code>urllib2.HTTPRedirectHandler</code>, which follows the redirect to the new location. Then your <code>http_error_302</code> method stores the status code (<code>302</code>) so the calling application can get it later.
<li>And here you are, having successfully followed the redirect to <code>http://diveintomark.org/xml/atom.xml</code>. <var>f.status</var> tells you that this was a temporary redirect, which means that you should continue to request data from the original address
            (<code>http://diveintomark.org/redir/example302.xml</code>). Maybe it will redirect next time too, but maybe not. Maybe it will redirect to a different address. It's not for you
            to say. The server said this redirect was only temporary, so you should respect that. And now you're exposing enough information
            that the calling application can respect that.
<h2 id="oa.gzip">11.8. Handling compressed data</h2>
<p>The last important HTTP feature you want to support is compression. Many web services have the ability to send data compressed,
   which can cut down the amount of data sent over the wire by 60% or more. This is especially true of XML web services, since
   XML data compresses very well.
<p>Servers won't give you compressed data unless you tell them you can handle it.
<div class=example><h3>Example 11.14. Telling the server you would like compressed data</h3><pre class=screen>
<samp class=prompt>>>> </samp><kbd>import urllib2, httplib</kbd>
<samp class=prompt>>>> </samp><kbd>httplib.HTTPConnection.debuglevel = 1</kbd>
<samp class=prompt>>>> </samp><kbd>request = urllib2.Request('http://diveintomark.org/xml/atom.xml')</kbd>
<samp class=prompt>>>> </samp><kbd>request.add_header('Accept-encoding', 'gzip')</kbd>        <span>&#x2460;</span>
<samp class=prompt>>>> </samp><kbd>opener = urllib2.build_opener()</kbd>
<samp class=prompt>>>> </samp><kbd>f = opener.open(request)</kbd>
<samp>connect: (diveintomark.org, 80)
send: '
GET /xml/atom.xml HTTP/1.0
Host: diveintomark.org
User-agent: Python-urllib/2.1
Accept-encoding: gzip</span><span>&#x2461;</span>
<samp>'
reply: 'HTTP/1.1 200 OK\r\n'
header: Date: Thu, 15 Apr 2004 22:24:39 GMT
header: Server: Apache/2.0.49 (Debian GNU/Linux)
header: Last-Modified: Thu, 15 Apr 2004 19:45:21 GMT
header: ETag: "e842a-3e53-55d97640"
header: Accept-Ranges: bytes
header: Vary: Accept-Encoding
header: Content-Encoding: gzip</span>         <span>&#x2462;</span>
header: Content-Length: 6289           <span>&#x2463;</span>
<samp>header: Connection: close
header: Content-Type: application/atom+xml</span>
</pre><div class=calloutlist>
<ol>
<li>This is the key: once you've created your <code>Request</code> object, add an <code>Accept-encoding</code> header to tell the server you can accept gzip-encoded data. <code>gzip</code> is the name of the compression algorithm you're using. In theory there could be other compression algorithms, but <code>gzip</code> is the compression algorithm used by 99% of web servers.
<li>There's your header going across the wire.
<li>And here's what the server sends back: the <code>Content-Encoding: gzip</code> header means that the data you're about to receive has been gzip-compressed.
<li>The <code>Content-Length</code> header is the length of the compressed data, not the uncompressed data. As you'll see in a minute, the actual length of
            the uncompressed data was 15955, so gzip compression cut your bandwidth by over 60%!
<div class=example><h3>Example 11.15. Decompressing the data</h3><pre class=screen>
<samp class=prompt>>>> </samp><kbd>compresseddata = f.read()</kbd>            <span>&#x2460;</span>
<samp class=prompt>>>> </samp><kbd>len(compresseddata)</kbd>
6289
<samp class=prompt>>>> </samp><kbd>import StringIO</kbd>
<samp class=prompt>>>> </samp><kbd>compressedstream = StringIO.StringIO(compresseddata)</kbd>   <span>&#x2461;</span>
<samp class=prompt>>>> </samp><kbd>import gzip</kbd>
<samp class=prompt>>>> </samp><kbd>gzipper = gzip.GzipFile(fileobj=compressedstream)</kbd>      <span>&#x2462;</span>
<samp class=prompt>>>> </samp><kbd>data = gzipper.read()</kbd>                <span>&#x2463;</span>
<samp class=prompt>>>> </samp><kbd>print data</kbd>         <span>&#x2464;</span>
<samp>&lt;?xml version="1.0" encoding="iso-8859-1"?>
&lt;feed version="0.3"
  xmlns="http://purl.org/atom/ns#"
  xmlns:dc="http://purl.org/dc/elements/1.1/"
  xml:lang="en">
  &lt;title mode="escaped">dive into mark&lt;/title>
  &lt;link rel="alternate" type="text/html" href="http://diveintomark.org/"/>
  &lt;-- rest of feed omitted for brevity --></samp>
<samp class=prompt>>>> </samp><kbd>len(data)</kbd>
15955
</pre><div class=calloutlist>
<ol>
<li>Continuing from the previous example, <var>f</var> is the file-like object returned from the URL opener. Using its <code>read()</code> method would ordinarily get you the uncompressed data, but since this data has been gzip-compressed, this is just the first
            step towards getting the data you really want.
<li>OK, this step is a little bit of messy workaround. Python has a <code>gzip</code> module, which reads (and actually writes) gzip-compressed files on disk. But you don't have a file on disk, you have a gzip-compressed
            buffer in memory, and you don't want to write out a temporary file just so you can uncompress it. So what you're going to
            do is create a file-like object out of the in-memory data (<var>compresseddata</var>), using the <code>StringIO</code> module. You first saw the <code>StringIO</code> module in <a href="#kgp.openanything.stringio.example" title="Example 10.4. Introducing StringIO">the previous chapter</a>, but now you've found another use for it.
<li>Now you can create an instance of <code>GzipFile</code>, and tell it that its &#8220;file&#8221; is the file-like object <var>compressedstream</var>.
<li>This is the line that does all the actual work: &#8220;reading&#8221; from <code>GzipFile</code> will decompress the data. Strange?  Yes, but it makes sense in a twisted kind of way. <var>gzipper</var> is a file-like object which represents a gzip-compressed file. That &#8220;file&#8221; is not a real file on disk, though; <var>gzipper</var> is really just &#8220;reading&#8221; from the file-like object you created with <code>StringIO</code> to wrap the compressed data, which is only in memory in the variable <var>compresseddata</var>. And where did that compressed data come from?  You originally downloaded it from a remote HTTP server by &#8220;reading&#8221; from the file-like object you built with <code>urllib2.build_opener</code>. And amazingly, this all just works. Every step in the chain has no idea that the previous step is faking it.
<li>Look ma, real data. (15955 bytes of it, in fact.)<p>&#8220;But wait!&#8221; I hear you cry. &#8220;This could be even easier!&#8221;  I know what you're thinking. You're thinking that <var>opener.open</var> returns a file-like object, so why not cut out the <code>StringIO</code> middleman and just pass <var>f</var> directly to <code>GzipFile</code>?  OK, maybe you weren't thinking that, but don't worry about it, because it doesn't work.
<div class=example><h3>Example 11.16. Decompressing the data directly from the server</h3><pre class=screen>
<samp class=prompt>>>> </samp><kbd>f = opener.open(request)</kbd><span>&#x2460;</span>
<samp class=prompt>>>> </samp><kbd>f.headers.get('Content-Encoding')</kbd>         <span>&#x2461;</span>
'gzip'
<samp class=prompt>>>> </samp><kbd>data = gzip.GzipFile(fileobj=f).read()</kbd>    <span>&#x2462;</span>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in ?
  File "c:\python23\lib\gzip.py", line 217, in read
    self._read(readsize)
  File "c:\python23\lib\gzip.py", line 252, in _read
    pos = self.fileobj.tell()   # Save current position
AttributeError: addinfourl instance has no attribute 'tell'</span>
</pre><div class=calloutlist>
<ol>
<li>Continuing from the previous example, you already have a <code>Request</code> object set up with an <code>Accept-encoding: gzip</code> header.
<li>Simply opening the request will get you the headers (though not download any data yet). As you can see from the returned
<code>Content-Encoding</code> header, this data has been sent gzip-compressed.
<li>Since <code>opener.open</code> returns a file-like object, and you know from the headers that when you read it, you're going to get gzip-compressed data,
            why not simply pass that file-like object directly to <code>GzipFile</code>?  As you &#8220;read&#8221; from the <code>GzipFile</code> instance, it will &#8220;read&#8221; compressed data from the remote HTTP server and decompress it on the fly. It's a good idea, but unfortunately it doesn't
            work. Because of the way gzip compression works, <code>GzipFile</code> needs to save its position and move forwards and backwards through the compressed file. This doesn't work when the &#8220;file&#8221; is a stream of bytes coming from a remote server; all you can do with it is retrieve bytes one at a time, not move back and
            forth through the data stream. So the inelegant hack of using <code>StringIO</code> is the best solution: download the compressed data, create a file-like object out of it with <code>StringIO</code>, and then decompress the data from that.
<h2 id="oa.alltogether">11.9. Putting it all together</h2>
<p>You've seen all the pieces for building an intelligent HTTP web services client. Now let's see how they all fit together.
<div class=example><h3>Example 11.17. The <code>openanything</code> function</h3>
<p>This function is defined in <code>openanything.py</code>.
<pre><code>
def openAnything(source, etag=None, lastmodified=None, agent=USER_AGENT):
    # non-HTTP code omitted for brevity
    if urlparse.urlparse(source)[0] == 'http':   <span>&#x2460;</span>
        # open URL with urllib2                 
        request = urllib2.Request(source)       
        request.add_header('User-Agent', agent)  <span>&#x2461;</span>
        if etag:              
            request.add_header('If-None-Match', etag)              <span>&#x2462;</span>
        if lastmodified:      
            request.add_header('If-Modified-Since', lastmodified)  <span>&#x2463;</span>
        request.add_header('Accept-encoding', 'gzip')              <span>&#x2464;</span>
        opener = urllib2.build_opener(SmartRedirectHandler(), DefaultErrorHandler()) <span>&#x2465;</span>
        return opener.open(request)              <span>&#x2466;</span>
</pre><div class=calloutlist>
<ol>
<li><code>urlparse</code> is a handy utility module for, you guessed it, parsing URLs. It's primary function, also called <code>urlparse</code>, takes a URL and splits it into a tuple of (scheme, domain, path, params, query string parameters, and fragment identifier).
             Of these, the only thing you care about is the scheme, to make sure that you're dealing with an HTTP URL (which <code>urllib2</code> can handle).
<li>You identify yourself to the HTTP server with the <code>User-Agent</code> passed in by the calling function. If no <code>User-Agent</code> was specified, you use a default one defined earlier in the <code>openanything.py</code> module. You never use the default one defined by <code>urllib2</code>.
<li>If an <code>ETag</code> hash was given, send it in the <code>If-None-Match</code> header.
<li>If a last-modified date was given, send it in the <code>If-Modified-Since</code> header.
<li>Tell the server you would like compressed data if possible.
<li>Build a URL opener that uses <em>both</em> of the custom URL handlers: <code>SmartRedirectHandler</code> for handling <code>301</code> and <code>302</code> redirects, and <code>DefaultErrorHandler</code> for handling <code>304</code>, <code>404</code>, and other error conditions gracefully.
<li>That's it!  Open the URL and return a file-like object to the caller.
<div class=example><h3>Example 11.18. The <code>fetch</code> function</h3>
<p>This function is defined in <code>openanything.py</code>.
<pre><code>
def fetch(source, etag=None, last_modified=None, agent=USER_AGENT):  
    '''Fetch data and metadata from a URL, file, stream, or string'''
    result = {}
    f = openAnything(source, etag, last_modified, agent)              <span>&#x2460;</span>
    result['data'] = f.read()     <span>&#x2461;</span>
    if hasattr(f, 'headers'):    
        # save ETag, if the server sent one        
        result['etag'] = f.headers.get('ETag')      <span>&#x2462;</span>
        # save Last-Modified header, if the server sent one          
        result['lastmodified'] = f.headers.get('Last-Modified')       <span>&#x2463;</span>
        if f.headers.get('content-encoding', '') == 'gzip':           <span>&#x2464;</span>
            # data came back gzip-compressed, decompress it          
            result['data'] = gzip.GzipFile(fileobj=StringIO(result['data']])).read()
    if hasattr(f, 'url'):         <span>&#x2465;</span>
        result['url'] = f.url    
        result['status'] = 200   
    if hasattr(f, 'status'):      <span>&#x2466;</span>
        result['status'] = f.status                
    f.close()  
    return result                
</pre><div class=calloutlist>
<ol>
<li>First, you call the <code>openAnything</code> function with a URL, <code>ETag</code> hash, <code>Last-Modified</code> date, and <code>User-Agent</code>.
<li>Read the actual data returned from the server. This may be compressed; if so, you'll decompress it later.
<li>Save the <code>ETag</code> hash returned from the server, so the calling application can pass it back to you next time, and you can pass it on to <code>openAnything</code>, which can stick it in the <code>If-None-Match</code> header and send it to the remote server.
<li>Save the <code>Last-Modified</code> date too.
<li>If the server says that it sent compressed data, decompress it.
<li>If you got a URL back from the server, save it, and assume that the status code is <code>200</code> until you find out otherwise.
<li>If one of the custom URL handlers captured a status code, then save that too.
<div class=example><h3>Example 11.19. Using <code>openanything.py</code></h3><pre class=screen>
<samp class=prompt>>>> </samp><kbd>import openanything</kbd>
<samp class=prompt>>>> </samp><kbd>useragent = 'MyHTTPWebServicesApp/1.0'</kbd>
<samp class=prompt>>>> </samp><kbd>url = 'http://diveintopython3.org/redir/example301.xml'</kbd>
<samp class=prompt>>>> </samp><kbd>params = openanything.fetch(url, agent=useragent)</kbd>              <span>&#x2460;</span>
<samp class=prompt>>>> </samp><kbd>params</kbd>   <span>&#x2461;</span>
<samp>{'url': 'http://diveintomark.org/xml/atom.xml', 
'lastmodified': 'Thu, 15 Apr 2004 19:45:21 GMT', 
'etag': '"e842a-3e53-55d97640"', 
'status': 301,
'data': '&lt;?xml version="1.0" encoding="iso-8859-1"?>
&lt;feed version="0.3"
&lt;-- rest of data omitted for brevity -->'}</samp>
<samp class=prompt>>>> </samp><kbd>if params['status'] == 301:</kbd><span>&#x2462;</span>
<samp class=prompt>...    </samp>url = params['url']
<samp class=prompt>>>> </samp><kbd>newparams = openanything.fetch(</kbd>
<samp class=prompt>...    </samp>url, params['etag'], params['lastmodified'], useragent)    <span>&#x2463;</span>
<samp class=prompt>>>> </samp><kbd>newparams</kbd>
<samp>{'url': 'http://diveintomark.org/xml/atom.xml', 
'lastmodified': None, 
'etag': '"e842a-3e53-55d97640"', 
'status': 304,
'data': ''}</span>  <span>&#x2464;</span>
</pre><div class=calloutlist>
<ol>
<li>The very first time you fetch a resource, you don't have an <code>ETag</code> hash or <code>Last-Modified</code> date, so you'll leave those out. (They're <a href="#apihelper.optional" title="4.2. Using Optional and Named Arguments">optional parameters</a>.)
<li>What you get back is a dictionary of several useful headers, the HTTP status code, and the actual data returned from the server.
             <code>openanything</code> handles the gzip compression internally; you don't care about that at this level.
<li>If you ever get a <code>301</code> status code, that's a permanent redirect, and you need to update your URL to the new address.
<li>The second time you fetch the same resource, you have all sorts of information to pass back: a (possibly updated) URL, the
<code>ETag</code> from the last time, the <code>Last-Modified</code> date from the last time, and of course your <code>User-Agent</code>.
<li>What you get back is again a dictionary, but the data hasn't changed, so all you got was a <code>304</code> status code and no data.
<h2 id="oa.summary">11.10. Summary</h2>
<p>The <code>openanything.py</code> and its functions should now make perfect sense.
<p>There are 5 important features of HTTP web services that every client should support:
<div class=itemizedlist>
<ul>
<li>Identifying your application <a href="#oa.useragent" title="11.5. Setting the User-Agent">by setting a proper <code>User-Agent</code></a>.

<li>Handling <a href="#oa.redirect" title="11.7. Handling redirects">permanent redirects properly</a>.

<li>Supporting <a href="#oa.etags" title="11.6. Handling Last-Modified and ETag"><code>Last-Modified</code> date checking</a> to avoid re-downloading data that hasn't changed.

<li>Supporting <a href="#oa.etags.example" title="Example 11.9. Supporting ETag/If-None-Match"><code>ETag</code> hashes</a> to avoid re-downloading data that hasn't changed.

<li>Supporting <a href="#oa.gzip" title="11.8. Handling compressed data">gzip compression</a> to reduce bandwidth even when data <em>has</em> changed.

</ul>
<div class=chapter>
<h2 id="roman">Chapter 13. Unit Testing</h2>
<h2 id="roman.intro">13.1. Introduction to Roman numerals</h2>
<p>In previous chapters, you &#8220;dived in&#8221; by immediately looking at code and trying to understand it as quickly as possible. Now that you have some Python under your belt, you're going to step back and look at the steps that happen <em>before</em> the code gets written.
<p>In the next few chapters, you're going to write, debug, and optimize a set of utility functions to convert to and from Roman
numerals. You saw the mechanics of constructing and validating Roman numerals in <a href="#re.roman" title="7.3. Case Study: Roman Numerals">Section 7.3, &#8220;Case Study: Roman Numerals&#8221;</a>, but now let's step back and consider what it would take to expand that into a two-way utility.
<p><a href="#re.roman" title="7.3. Case Study: Roman Numerals">The rules for Roman numerals</a> lead to a number of interesting observations:
<div class=orderedlist>
<ol>
<li>There is only one correct way to represent a particular number as Roman numerals.
<li>The converse is also true: if a string of characters is a valid Roman numeral, it represents only one number (<i class=foreignphrase><abbr>i.e.</abbr></i> it can only be read one way).

<li>There is a limited range of numbers that can be expressed as Roman numerals, specifically <code>1</code> through <code>3999</code>. (The Romans did have several ways of expressing larger numbers, for instance by having a bar over a numeral to represent
      that its normal value should be multiplied by <code>1000</code>, but you're not going to deal with that. For the purposes of this chapter, let's stipulate that Roman numerals go from <code>1</code> to <code>3999</code>.)

<li>There is no way to represent <code>0</code> in Roman numerals. (Amazingly, the ancient Romans had no concept of <code>0</code> as a number. Numbers were for counting things you had; how can you count what you don't have?)

<li>There is no way to represent negative numbers in Roman numerals.
<li>There is no way to represent fractions or non-integer numbers in Roman numerals.
</ol>
<p>Given all of this, what would you expect out of a set of functions to convert to and from Roman numerals?
<div class=orderedlist><h3 id="roman.requirements"><code>roman.py</code> requirements</h3>
<ol>
<li><code>to_roman()</code> should return the Roman numeral representation for all integers <code>1</code> to <code>3999</code>.

<li><code>to_roman()</code> should fail when given an integer outside the range <code>1</code> to <code>3999</code>.

<li><code>to_roman()</code> should fail when given a non-integer number.

<li><code>from_roman()</code> should take a valid Roman numeral and return the number that it represents.

<li><code>from_roman()</code> should fail when given an invalid Roman numeral.

<li>If you take a number, convert it to Roman numerals, then convert that back to a number, you should end up with the number
      you started with. So <code>from_roman(to_roman(n)) == n</code> for all <var>n</var> in <code>1..3999</code>.

<li><code>to_roman()</code> should always return a Roman numeral using uppercase letters.

<li><code>from_roman()</code> should only accept uppercase Roman numerals (<i class=foreignphrase><abbr>i.e.</abbr></i> it should fail when given lowercase input).

</ol>
<div class=itemizedlist>
<h3>Further reading</h3>
<ul>
<li><a href="http://www.wilkiecollins.demon.co.uk/roman/front.htm">This site</a> has more on Roman numerals, including a fascinating <a href="http://www.wilkiecollins.demon.co.uk/roman/intro.htm">history</a> of how Romans and other civilizations really used them (short answer: haphazardly and inconsistently).

</ul>
<h2 id="roman.failure">13.5. Testing for failure</h2>
<p>It is not enough to test that functions succeed when given good input; you must also test that they fail when given bad input. And not just any sort of failure; they must fail in the way you expect.
<p>Remember the <a href="#roman.requirements">other requirements</a> for <code>to_roman()</code>:
<div class=orderedlist>
<ol start="2">
<li><code>to_roman()</code> should fail when given an integer outside the range <code>1</code> to <code>3999</code>.

<li><code>to_roman()</code> should fail when given a non-integer number.

</ol>
<p>In Python, functions indicate failure by raising <a href="#fileinfo.exception" title="6.1. Handling Exceptions">exceptions</a>, and the <code>unittest</code> module provides methods for testing whether a function raises a particular exception when given bad input.
<div class=example><h3 id="roman.tobadinput.example">Example 13.3. Testing bad input to <code>to_roman()</code></h3><pre><code>
class ToRomanBadInput(unittest.TestCase):          
    def testTooLarge(self):      
        """to_roman should fail with large input""" 
        self.assertRaises(roman.OutOfRangeError, roman.to_roman, 4000) <span>&#x2460;</span>

    def testZero(self):          
        """to_roman should fail with 0 input"""     
        self.assertRaises(roman.OutOfRangeError, roman.to_roman, 0)    <span>&#x2461;</span>

    def testNegative(self):      
        """to_roman should fail with negative input"""                
        self.assertRaises(roman.OutOfRangeError, roman.to_roman, -1)  

    def testNonInteger(self):    
        """to_roman should fail with non-integer input"""             
        self.assertRaises(roman.NotIntegerError, roman.to_roman, 0.5)  <span>&#x2462;</span></pre><div class=calloutlist>
<ol>
<li>The <code>TestCase</code> class of the <code>unittest</code> provides the <code>assertRaises</code> method, which takes the following arguments: the exception you're expecting, the function you're testing, and the arguments
            you're passing that function. (If the function you're testing takes more than one argument, pass them all to <code>assertRaises</code>, in order, and it will pass them right along to the function you're testing.)  Pay close attention to what you're doing here:
            instead of calling <code>to_roman()</code> directly and manually checking that it raises a particular exception (by wrapping it in a <a href="#fileinfo.exception" title="6.1. Handling Exceptions"><code>try...except</code> block</a>), <code>assertRaises</code> has encapsulated all of that for us. All you do is give it the exception (<code>roman.OutOfRangeError</code>), the function (<code>to_roman()</code>), and <code>to_roman()</code>'s arguments (<code>4000</code>), and <code>assertRaises</code> takes care of calling <code>to_roman()</code> and checking to make sure that it raises <code>roman.OutOfRangeError</code>. (Also note that you're passing the <code>to_roman()</code> function itself as an argument; you're not calling it, and you're not passing the name of it as a string. Have I mentioned
            recently how handy it is that <a href="#odbchelper.objects" title="2.4. Everything Is an Object">everything in Python is an object</a>, including functions and exceptions?)
<li>Along with testing numbers that are too large, you need to test numbers that are too small. Remember, Roman numerals cannot
            express <code>0</code> or negative numbers, so you have a test case for each of those (<code>testZero</code> and <code>testNegative</code>). In <code>testZero</code>, you are testing that <code>to_roman()</code> raises a <code>roman.OutOfRangeError</code> exception when called with <code>0</code>; if it does <em>not</em> raise a <code>roman.OutOfRangeError</code> (either because it returns an actual value, or because it raises some other exception), this test is considered failed.
<li><a href="#roman.requirements">Requirement #3</a> specifies that <code>to_roman()</code> cannot accept a non-integer number, so here you test to make sure that <code>to_roman()</code> raises a <code>roman.NotIntegerError</code> exception when called with <code>0.5</code>. If <code>to_roman()</code> does not raise a <code>roman.NotIntegerError</code>, this test is considered failed.
<p>The next two <a href="#roman.requirements">requirements</a> are similar to the first three, except they apply to <code>from_roman()</code> instead of <code>to_roman()</code>:
<div class=orderedlist>
<ol start="4">
<li><code>from_roman()</code> should take a valid Roman numeral and return the number that it represents.

<li><code>from_roman()</code> should fail when given an invalid Roman numeral.

</ol>
<p>Requirement #4 is handled in the same way as <a href="#roman.testtoromanknownvalues.example" title="Example 13.2. testToRomanKnownValues">requirement #1</a>, iterating through a sampling of known values and testing each in turn. Requirement #5 is handled in the same way as requirements
#2 and #3, by testing a series of bad inputs and making sure <code>from_roman()</code> raises the appropriate exception.
<div class=example><h3 id="roman.frombadinput.example">Example 13.4. Testing bad input to <code>from_roman()</code></h3><pre><code>
class FromRomanBadInput(unittest.TestCase):  
    def testTooManyRepeatedNumerals(self):   
        """from_roman should fail with too many repeated numerals"""              
        for s in ('MMMM', 'DD', 'CCCC', 'LL', 'XXXX', 'VV', 'IIII'):             
            self.assertRaises(roman.InvalidRomanNumeralError, roman.from_roman, s) <span>&#x2460;</span>

    def testRepeatedPairs(self):             
        """from_roman should fail with repeated pairs of numerals"""              
        for s in ('CMCM', 'CDCD', 'XCXC', 'XLXL', 'IXIX', 'IVIV'):               
            self.assertRaises(roman.InvalidRomanNumeralError, roman.from_roman, s)

    def testMalformedAntecedent(self):       
        """from_roman should fail with malformed antecedents""" 
        for s in ('IIMXCC', 'VX', 'DCM', 'CMM', 'IXIV',
'MCMC', 'XCX', 'IVI', 'LM', 'LD', 'LC'):     
            self.assertRaises(roman.InvalidRomanNumeralError, roman.from_roman, s)</pre><div class=calloutlist>
<ol>
<li>Not much new to say about these; the pattern is exactly the same as the one you used to test bad input to <code>to_roman()</code>. I will briefly note that you have another exception: <code>roman.InvalidRomanNumeralError</code>. That makes a total of three custom exceptions that will need to be defined in <code>roman.py</code> (along with <code>roman.OutOfRangeError</code> and <code>roman.NotIntegerError</code>). You'll see how to define these custom exceptions when you actually start writing <code>roman.py</code>, later in this chapter.
<h2 id="roman.sanity">13.6. Testing for sanity</h2>
<p>Often, you will find that a unit of code contains a set of reciprocal functions, usually in the form of conversion functions
   where one converts A to B and the other converts B to A. In these cases, it is useful to create a &#8220;sanity check&#8221; to make sure that you can convert A to B and back to A without losing precision, incurring rounding errors, or triggering
   any other sort of bug.
<p>Consider this <a href="#roman.requirements">requirement</a>:
<div class=orderedlist>
<ol start="6">
<li>If you take a number, convert it to Roman numerals, then convert that back to a number, you should end up with the number
      you started with. So <code>from_roman(to_roman(n)) == n</code> for all <var>n</var> in <code>1..3999</code>.

</ol>
<div class=example><h3 id="roman.sanity.example">Example 13.5. Testing <code>to_roman()</code> against <code>from_roman()</code></h3><pre><code>
class SanityCheck(unittest.TestCase):        
    def testSanity(self):  
        """from_roman(to_roman(n))==n for all n"""
        for integer in range(1, 4000):        <span>&#x2460;</span> <span>&#x2461;</span>
            numeral = roman.to_roman(integer) 
            result = roman.from_roman(numeral)
            self.assertEqual(integer, result) <span>&#x2462;</span></pre><div class=calloutlist>
<ol>
<li>You've seen <a href="#odbchelper.multiassign.range" title="Example 3.20. Assigning Consecutive Values">the <code>range</code> function</a> before, but here it is called with two arguments, which returns a list of integers starting at the first argument (<code>1</code>) and counting consecutively up to <em>but not including</em> the second argument (<code>4000</code>). Thus, <code>1..3999</code>, which is the valid range for converting to Roman numerals.
<li>I just wanted to mention in passing that <var>integer</var> is not a keyword in Python; here it's just a variable name like any other.
<li>The actual testing logic here is straightforward: take a number (<var>integer</var>), convert it to a Roman numeral (<var>numeral</var>), then convert it back to a number (<var>result</var>) and make sure you end up with the same number you started with. If not, <code>assertEqual</code> will raise an exception and the test will immediately be considered failed. If all the numbers match, <code>assertEqual</code> will always return silently, the entire <code>testSanity</code> method will eventually return silently, and the test will be considered passed.
<p>The <a href="#roman.requirements">last two requirements</a> are different from the others because they seem both arbitrary and trivial:
<div class=orderedlist>
<ol start="7">
<li><code>to_roman()</code> should always return a Roman numeral using uppercase letters.

<li><code>from_roman()</code> should only accept uppercase Roman numerals (<i class=foreignphrase><abbr>i.e.</abbr></i> it should fail when given lowercase input).

</ol>
<p>In fact, they are somewhat arbitrary. You could, for instance, have stipulated that <code>from_roman()</code> accept lowercase and mixed case input. But they are not completely arbitrary; if <code>to_roman()</code> is always returning uppercase output, then <code>from_roman()</code> must at least accept uppercase input, or the &#8220;sanity check&#8221; (requirement #6) would fail. The fact that it <em>only</em> accepts uppercase input is arbitrary, but as any systems integrator will tell you, case always matters, so it's worth specifying
the behavior up front. And if it's worth specifying, it's worth testing.
<div class=example><h3>Example 13.6. Testing for case</h3><pre><code>
class CaseCheck(unittest.TestCase): 
    def testToRomanCase(self):      
        """to_roman should always return uppercase"""  
        for integer in range(1, 4000):                
            numeral = roman.to_roman(integer)          
            self.assertEqual(numeral, numeral.upper())         <span>&#x2460;</span>

    def testFromRomanCase(self):    
        """from_roman should only accept uppercase input"""
        for integer in range(1, 4000):                
            numeral = roman.to_roman(integer)          
            roman.from_roman(numeral.upper()) <span>&#x2461;</span> <span>&#x2462;</span>
            self.assertRaises(roman.InvalidRomanNumeralError,
            roman.from_roman, numeral.lower())   <span>&#x2463;</span></pre><div class=calloutlist>
<ol>
<li>The most interesting thing about this test case is all the things it doesn't test. It doesn't test that the value returned
            from <code>to_roman()</code> is <a href="#roman.testtoromanknownvalues.example" title="Example 13.2. testToRomanKnownValues">right</a> or even <a href="#roman.sanity.example" title="Example 13.5. Testing to_roman against from_roman">consistent</a>; those questions are answered by separate test cases. You have a whole test case just to test for uppercase-ness. You might
            be tempted to combine this with the <a href="#roman.sanity.example" title="Example 13.5. Testing to_roman against from_roman">sanity check</a>, since both run through the entire range of values and call <code>to_roman()</code>.
<sup>[<a name="d0e32781" href="#ftn.d0e32781">6</a>]</sup>  But that would violate one of the <a href="#roman.success" title="13.4. Testing for success">fundamental rules</a>: each test case should answer only a single question. Imagine that you combined this case check with the sanity check, and
            then that test case failed. You would need to do further analysis to figure out which part of the test case failed to determine
            what the problem was. If you need to analyze the results of your unit testing just to figure out what they mean, it's a sure
            sign that you've mis-designed your test cases.
<li>There's a similar lesson to be learned here: even though &#8220;you know&#8221; that <code>to_roman()</code> always returns uppercase, you are explicitly converting its return value to uppercase here to test that <code>from_roman()</code> accepts uppercase input. Why?  Because the fact that <code>to_roman()</code> always returns uppercase is an independent requirement. If you changed that requirement so that, for instance, it always
            returned lowercase, the <code>testToRomanCase</code> test case would need to change, but this test case would still work. This was another of the <a href="#roman.success" title="13.4. Testing for success">fundamental rules</a>: each test case must be able to work in isolation from any of the others. Every test case is an island.
<li>Note that you're not assigning the return value of <code>from_roman()</code> to anything. This is legal syntax in Python; if a function returns a value but nobody's listening, Python just throws away the return value. In this case, that's what you want. This test case doesn't test anything about the return
            value; it just tests that <code>from_roman()</code> accepts the uppercase input without raising an exception.
<li>This is a complicated line, but it's very similar to what you did in the <code>ToRomanBadInput</code> and <code>FromRomanBadInput</code> tests. You are testing to make sure that calling a particular function (<code>roman.from_roman</code>) with a particular value (<code>numeral.lower()</code>, the lowercase version of the current Roman numeral in the loop) raises a particular exception (<code>roman.InvalidRomanNumeralError</code>). If it does (each time through the loop), the test passes; if even one time it does something else (like raises a different
            exception, or returning a value without raising an exception at all), the test fails.
<p>In the next chapter, you'll see how to write code that passes these tests.
<div class=footnotes><br><hr width="100" align="left">
<div class=footnote>
<p><sup>[<a name="ftn.d0e32781" href="#d0e32781">6</a>] </sup>&#8220;I can resist everything except temptation.&#8221; --Oscar Wilde
<div class=chapter>
<h2 id="roman1.5">Chapter 14. Test-First Programming</h2>
<h2 id="roman.stage1">14.1. <code>roman.py</code>, stage 1</h2>
<p>Now that the unit tests are complete, it's time to start writing the code that the test cases are attempting to test. You're
   going to do this in stages, so you can see all the unit tests fail, then watch them pass one by one as you fill in the gaps
   in <code>roman.py</code>.
<div class=example><h3>Example 14.1. <code>roman1.py</code></h3>
<p>This file is available in <code>py/roman/stage1/</code> in the examples directory.
<p>If you have not already done so, you can <a href="http://diveintopython3.org/download/diveintopython3-examples-5.4.zip" title="Download example scripts">download this and other examples</a> used in this book.
<pre><code>
"""Convert to and from Roman numerals"""

#Define exceptions
class RomanError(Exception): pass                <span>&#x2460;</span>
class OutOfRangeError(RomanError): pass          <span>&#x2461;</span>
class NotIntegerError(RomanError): pass
class InvalidRomanNumeralError(RomanError): pass <span>&#x2462;</span>

def to_roman(n):
    """convert integer to Roman numeral"""
    pass     <span>&#x2463;</span>

def from_roman(s):
    """convert Roman numeral to integer"""
    pass
</pre><div class=calloutlist>
<ol>
<li>This is how you define your own custom exceptions in Python. Exceptions are classes, and you create your own by subclassing existing exceptions. It is strongly recommended (but not
            required) that you subclass <code>Exception</code>, which is the base class that all built-in exceptions inherit from. Here I am defining <code>RomanError</code> (inherited from <code>Exception</code>) to act as the base class for all my other custom exceptions to follow. This is a matter of style; I could just as easily
            have inherited each individual exception from the <code>Exception</code> class directly.
<li>The <code>OutOfRangeError</code> and <code>NotIntegerError</code> exceptions will eventually be used by <code>to_roman()</code> to flag various forms of invalid input, as specified in <a href="#roman.tobadinput.example" title="Example 13.3. Testing bad input to to_roman"><code>ToRomanBadInput</code></a>.
<li>The <code>InvalidRomanNumeralError</code> exception will eventually be used by <code>from_roman()</code> to flag invalid input, as specified in <a href="#roman.frombadinput.example" title="Example 13.4. Testing bad input to from_roman"><code>FromRomanBadInput</code></a>.
<li>At this stage, you want to define the <abbr>API</abbr> of each of your functions, but you don't want to code them yet, so you stub them out using the Python reserved word <a href="#fileinfo.class.simplest" title="Example 5.3. The Simplest Python Class"><code>pass</code></a>.
<p>Now for the big moment (drum roll please): you're finally going to run the unit test against this stubby little module. At
this point, every test case should fail. In fact, if any test case passes in stage 1, you should go back to <code>romantest.py</code> and re-evaluate why you coded a test so useless that it passes with do-nothing functions.
<li>At this stage, you want to define the <abbr>API</abbr> of each of your functions, but you don't want to code them yet, so you stub them out using the Python reserved word <a href="#fileinfo.class.simplest" title="Example 5.3. The Simplest Python Class"><code>pass</code></a>.
<p>Run <code>romantest1.py</code> with the <code>-v</code> command-line option, which will give more verbose output so you can see exactly what's going on as each test case runs. 
With any luck, your output should look like this:
<div class=example><h3 id="roman.stage1.output">Example 14.2. Output of <code>romantest1.py</code> against <code>roman1.py</code></h3><pre class=screen><samp>from_roman should only accept uppercase input ... ERROR
to_roman should always return uppercase ... ERROR
from_roman should fail with malformed antecedents ... FAIL
from_roman should fail with repeated pairs of numerals ... FAIL
from_roman should fail with too many repeated numerals ... FAIL
from_roman should give known result with known input ... FAIL
to_roman should give known result with known input ... FAIL
from_roman(to_roman(n))==n for all n ... FAIL
to_roman should fail with non-integer input ... FAIL
to_roman should fail with negative input ... FAIL
to_roman should fail with large input ... FAIL
to_roman should fail with 0 input ... FAIL

======================================================================
ERROR: from_roman should only accept uppercase input
----------------------------------------------------------------------
</span><samp class=traceback>Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage1\romantest1.py", line 154, in testFromRomanCase
    roman1.from_roman(numeral.upper())
AttributeError: 'None' object has no attribute 'upper'</span><samp>
======================================================================
ERROR: to_roman should always return uppercase
----------------------------------------------------------------------
</span><samp class=traceback>Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage1\romantest1.py", line 148, in testToRomanCase
    self.assertEqual(numeral, numeral.upper())
AttributeError: 'None' object has no attribute 'upper'</span><samp>
======================================================================
FAIL: from_roman should fail with malformed antecedents
----------------------------------------------------------------------
</span><samp class=traceback>Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage1\romantest1.py", line 133, in testMalformedAntecedent
    self.assertRaises(roman1.InvalidRomanNumeralError, roman1.from_roman, s)
  File "c:\python21\lib\unittest.py", line 266, in failUnlessRaises
    raise self.failureException, excName
AssertionError: InvalidRomanNumeralError</span><samp>
======================================================================
FAIL: from_roman should fail with repeated pairs of numerals
----------------------------------------------------------------------
</span><samp class=traceback>Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage1\romantest1.py", line 127, in testRepeatedPairs
    self.assertRaises(roman1.InvalidRomanNumeralError, roman1.from_roman, s)
  File "c:\python21\lib\unittest.py", line 266, in failUnlessRaises
    raise self.failureException, excName
AssertionError: InvalidRomanNumeralError</span><samp>
======================================================================
FAIL: from_roman should fail with too many repeated numerals
----------------------------------------------------------------------
</span><samp class=traceback>Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage1\romantest1.py", line 122, in testTooManyRepeatedNumerals
    self.assertRaises(roman1.InvalidRomanNumeralError, roman1.from_roman, s)
  File "c:\python21\lib\unittest.py", line 266, in failUnlessRaises
    raise self.failureException, excName
AssertionError: InvalidRomanNumeralError</span><samp>
======================================================================
FAIL: from_roman should give known result with known input
----------------------------------------------------------------------
</span><samp class=traceback>Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage1\romantest1.py", line 99, in testFromRomanKnownValues
    self.assertEqual(integer, result)
  File "c:\python21\lib\unittest.py", line 273, in failUnlessEqual
    raise self.failureException, (msg or '%s != %s' % (first, second))
AssertionError: 1 != None</span><samp>
======================================================================
FAIL: to_roman should give known result with known input
----------------------------------------------------------------------
</span><samp class=traceback>Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage1\romantest1.py", line 93, in testToRomanKnownValues
    self.assertEqual(numeral, result)
  File "c:\python21\lib\unittest.py", line 273, in failUnlessEqual
    raise self.failureException, (msg or '%s != %s' % (first, second))
AssertionError: I != None</span><samp>
======================================================================
FAIL: from_roman(to_roman(n))==n for all n
----------------------------------------------------------------------
</span><samp class=traceback>Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage1\romantest1.py", line 141, in testSanity
    self.assertEqual(integer, result)
  File "c:\python21\lib\unittest.py", line 273, in failUnlessEqual
    raise self.failureException, (msg or '%s != %s' % (first, second))
AssertionError: 1 != None</span><samp>
======================================================================
FAIL: to_roman should fail with non-integer input
----------------------------------------------------------------------
</span><samp class=traceback>Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage1\romantest1.py", line 116, in testNonInteger
    self.assertRaises(roman1.NotIntegerError, roman1.to_roman, 0.5)
  File "c:\python21\lib\unittest.py", line 266, in failUnlessRaises
    raise self.failureException, excName
AssertionError: NotIntegerError</span><samp>
======================================================================
FAIL: to_roman should fail with negative input
----------------------------------------------------------------------
</span><samp class=traceback>Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage1\romantest1.py", line 112, in testNegative
    self.assertRaises(roman1.OutOfRangeError, roman1.to_roman, -1)
  File "c:\python21\lib\unittest.py", line 266, in failUnlessRaises
    raise self.failureException, excName
AssertionError: OutOfRangeError</span><samp>
======================================================================
FAIL: to_roman should fail with large input
----------------------------------------------------------------------
</span><samp class=traceback>Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage1\romantest1.py", line 104, in testTooLarge
    self.assertRaises(roman1.OutOfRangeError, roman1.to_roman, 4000)
  File "c:\python21\lib\unittest.py", line 266, in failUnlessRaises
    raise self.failureException, excName
AssertionError: OutOfRangeError</span><samp>
======================================================================
FAIL: to_roman should fail with 0 input               </span><span>&#x2460;</span><samp>
----------------------------------------------------------------------
</span><samp class=traceback>Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage1\romantest1.py", line 108, in testZero
    self.assertRaises(roman1.OutOfRangeError, roman1.to_roman, 0)
  File "c:\python21\lib\unittest.py", line 266, in failUnlessRaises
    raise self.failureException, excName
AssertionError: OutOfRangeError    </span><span>&#x2461;</span><samp>
----------------------------------------------------------------------
Ran 12 tests in 0.040s             </span><span>&#x2462;</span><samp>

FAILED (failures=10, errors=2)     </span><span>&#x2463;</span></pre><div class=calloutlist>
<h2 id="roman.stage2">14.2. <code>roman.py</code>, stage 2</h2>
<p>Now that you have the framework of the <code>roman</code> module laid out, it's time to start writing code and passing test cases.
<div class=example><h3 id="roman.stage2.example">Example 14.3. <code>roman2.py</code></h3>
<p>This file is available in <code>py/roman/stage2/</code> in the examples directory.
<p>If you have not already done so, you can <a href="http://diveintopython3.org/download/diveintopython3-examples-5.4.zip" title="Download example scripts">download this and other examples</a> used in this book.
<pre><code>
"""Convert to and from Roman numerals"""

#Define exceptions
class RomanError(Exception): pass
class OutOfRangeError(RomanError): pass
class NotIntegerError(RomanError): pass
class InvalidRomanNumeralError(RomanError): pass

#Define digit mapping
romanNumeralMap = (('M',  1000), <span>&#x2460;</span>
 ('CM', 900),
 ('D',  500),
 ('CD', 400),
 ('C',  100),
 ('XC', 90),
 ('L',  50),
 ('XL', 40),
 ('X',  10),
 ('IX', 9),
 ('V',  5),
 ('IV', 4),
 ('I',  1))

def to_roman(n):
    """convert integer to Roman numeral"""
    result = ""
    for numeral, integer in romanNumeralMap:
        while n >= integer:      <span>&#x2461;</span>
            result += numeral
            n -= integer
    return result

def from_roman(s):
    """convert Roman numeral to integer"""
    pass
</pre><div class=calloutlist>
<ol>
<li><var>romanNumeralMap</var> is a tuple of tuples which defines three things:
<div class=orderedlist>
<ol>
<li>The character representations of the most basic Roman numerals. Note that this is not just the single-character Roman numerals;
   you're also defining two-character pairs like <code>CM</code> (&#8220;one hundred less than one thousand&#8221;); this will make the <code>to_roman()</code> code simpler later.

<li>The order of the Roman numerals. They are listed in descending value order, from <code>M</code> all the way down to <code>I</code>.

<li>The value of each Roman numeral. Each inner tuple is a pair of <code>(<var>numeral</var>, <var>value</var>)</code>.

</ol>
<li>Here's where your rich data structure pays off, because you don't need any special logic to handle the subtraction rule. 
            To convert to Roman numerals, you simply iterate through <var>romanNumeralMap</var> looking for the largest integer value less than or equal to the input. Once found, you add the Roman numeral representation
            to the end of the output, subtract the corresponding integer value from the input, lather, rinse, repeat.
<div class=example><h3>Example 14.4. How <code>to_roman()</code> works</h3>
<p>If you're not clear how <code>to_roman()</code> works, add a <code>print</code> statement to the end of the <code>while</code> loop:<pre><code>
        while n >= integer:
            result += numeral
            n -= integer
            print 'subtracting', integer, 'from input, adding', numeral, 'to output'</pre><pre class=screen>
<samp class=prompt>>>> </samp><kbd>import roman2</kbd>
<samp class=prompt>>>> </samp><kbd>roman2.to_roman(1424)</kbd>
<samp>subtracting 1000 from input, adding M to output
subtracting 400 from input, adding CD to output
subtracting 10 from input, adding X to output
subtracting 10 from input, adding X to output
subtracting 4 from input, adding IV to output
'MCDXXIV'</span>
</pre><p>So <code>to_roman()</code> appears to work, at least in this manual spot check. But will it pass the unit testing?  Well no, not entirely.
<div class=example><h3>Example 14.5. Output of <code>romantest2.py</code> against <code>roman2.py</code></h3>
<p>Remember to run <code>romantest2.py</code> with the <code>-v</code> command-line flag to enable verbose mode.
<pre class=screen><samp>from_roman should only accept uppercase input ... FAIL
to_roman should always return uppercase ... ok</span><span>&#x2460;</span><samp>
from_roman should fail with malformed antecedents ... FAIL
from_roman should fail with repeated pairs of numerals ... FAIL
from_roman should fail with too many repeated numerals ... FAIL
from_roman should give known result with known input ... FAIL
to_roman should give known result with known input ... ok       </span><span>&#x2461;</span><samp>
from_roman(to_roman(n))==n for all n ... FAIL
to_roman should fail with non-integer input ... FAIL            </span><span>&#x2462;</span><samp>
to_roman should fail with negative input ... FAIL
to_roman should fail with large input ... FAIL
to_roman should fail with 0 input ... FAIL</span></pre><div class=calloutlist>
<ol>
<li><code>to_roman()</code> does, in fact, always return uppercase, because <var>romanNumeralMap</var> defines the Roman numeral representations as uppercase. So this test passes already.
<li>Here's the big news: this version of the <code>to_roman()</code> function passes the <a href="#roman.testtoromanknownvalues.example" title="Example 13.2. testToRomanKnownValues">known values test</a>. Remember, it's not comprehensive, but it does put the function through its paces with a variety of good inputs, including
            inputs that produce every single-character Roman numeral, the largest possible input (<code>3999</code>), and the input that produces the longest possible Roman numeral (<code>3888</code>). At this point, you can be reasonably confident that the function works for any good input value you could throw at it.
<li>However, the function does not &#8220;work&#8221; for bad values; it fails every single <a href="#roman.tobadinput.example" title="Example 13.3. Testing bad input to to_roman">bad input test</a>. That makes sense, because you didn't include any checks for bad input. Those test cases look for specific exceptions to
            be raised (via <code>assertRaises</code>), and you're never raising them. You'll do that in the next stage.
<p>Here's the rest of the output of the unit test, listing the details of all the failures. You're down to 10.
<pre class=screen><samp>
======================================================================
FAIL: from_roman should only accept uppercase input
----------------------------------------------------------------------
</span><samp class=traceback>Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage2\romantest2.py", line 156, in testFromRomanCase
    roman2.from_roman, numeral.lower())
  File "c:\python21\lib\unittest.py", line 266, in failUnlessRaises
    raise self.failureException, excName
AssertionError: InvalidRomanNumeralError</span><samp>
======================================================================
FAIL: from_roman should fail with malformed antecedents
----------------------------------------------------------------------
</span><samp class=traceback>Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage2\romantest2.py", line 133, in testMalformedAntecedent
    self.assertRaises(roman2.InvalidRomanNumeralError, roman2.from_roman, s)
  File "c:\python21\lib\unittest.py", line 266, in failUnlessRaises
    raise self.failureException, excName
AssertionError: InvalidRomanNumeralError</span><samp>
======================================================================
FAIL: from_roman should fail with repeated pairs of numerals
----------------------------------------------------------------------
</span><samp class=traceback>Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage2\romantest2.py", line 127, in testRepeatedPairs
    self.assertRaises(roman2.InvalidRomanNumeralError, roman2.from_roman, s)
  File "c:\python21\lib\unittest.py", line 266, in failUnlessRaises
    raise self.failureException, excName
AssertionError: InvalidRomanNumeralError</span><samp>
======================================================================
FAIL: from_roman should fail with too many repeated numerals
----------------------------------------------------------------------
</span><samp class=traceback>Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage2\romantest2.py", line 122, in testTooManyRepeatedNumerals
    self.assertRaises(roman2.InvalidRomanNumeralError, roman2.from_roman, s)
  File "c:\python21\lib\unittest.py", line 266, in failUnlessRaises
    raise self.failureException, excName
AssertionError: InvalidRomanNumeralError</span><samp>
======================================================================
FAIL: from_roman should give known result with known input
----------------------------------------------------------------------
</span><samp class=traceback>Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage2\romantest2.py", line 99, in testFromRomanKnownValues
    self.assertEqual(integer, result)
  File "c:\python21\lib\unittest.py", line 273, in failUnlessEqual
    raise self.failureException, (msg or '%s != %s' % (first, second))
AssertionError: 1 != None</span><samp>
======================================================================
FAIL: from_roman(to_roman(n))==n for all n
----------------------------------------------------------------------
</span><samp class=traceback>Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage2\romantest2.py", line 141, in testSanity
    self.assertEqual(integer, result)
  File "c:\python21\lib\unittest.py", line 273, in failUnlessEqual
    raise self.failureException, (msg or '%s != %s' % (first, second))
AssertionError: 1 != None</span><samp>
======================================================================
FAIL: to_roman should fail with non-integer input
----------------------------------------------------------------------
</span><samp class=traceback>Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage2\romantest2.py", line 116, in testNonInteger
    self.assertRaises(roman2.NotIntegerError, roman2.to_roman, 0.5)
  File "c:\python21\lib\unittest.py", line 266, in failUnlessRaises
    raise self.failureException, excName
AssertionError: NotIntegerError</span><samp>
======================================================================
FAIL: to_roman should fail with negative input
----------------------------------------------------------------------
</span><samp class=traceback>Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage2\romantest2.py", line 112, in testNegative
    self.assertRaises(roman2.OutOfRangeError, roman2.to_roman, -1)
  File "c:\python21\lib\unittest.py", line 266, in failUnlessRaises
    raise self.failureException, excName
AssertionError: OutOfRangeError</span><samp>
======================================================================
FAIL: to_roman should fail with large input
----------------------------------------------------------------------
</span><samp class=traceback>Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage2\romantest2.py", line 104, in testTooLarge
    self.assertRaises(roman2.OutOfRangeError, roman2.to_roman, 4000)
  File "c:\python21\lib\unittest.py", line 266, in failUnlessRaises
    raise self.failureException, excName
AssertionError: OutOfRangeError</span><samp>
======================================================================
FAIL: to_roman should fail with 0 input
----------------------------------------------------------------------
</span><samp class=traceback>Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage2\romantest2.py", line 108, in testZero
    self.assertRaises(roman2.OutOfRangeError, roman2.to_roman, 0)
  File "c:\python21\lib\unittest.py", line 266, in failUnlessRaises
    raise self.failureException, excName
AssertionError: OutOfRangeError</span><samp>
----------------------------------------------------------------------
Ran 12 tests in 0.320s

FAILED (failures=10)</span></pre><h2 id="roman.stage3">14.3. <code>roman.py</code>, stage 3</h2>
<p>Now that <code>to_roman()</code> behaves correctly with good input (integers from <code>1</code> to <code>3999</code>), it's time to make it behave correctly with bad input (everything else).
<div class=example><h3>Example 14.6. <code>roman3.py</code></h3>
<p>This file is available in <code>py/roman/stage3/</code> in the examples directory.
<p>If you have not already done so, you can <a href="http://diveintopython3.org/download/diveintopython3-examples-5.4.zip" title="Download example scripts">download this and other examples</a> used in this book.
<pre><code>
"""Convert to and from Roman numerals"""

#Define exceptions
class RomanError(Exception): pass
class OutOfRangeError(RomanError): pass
class NotIntegerError(RomanError): pass
class InvalidRomanNumeralError(RomanError): pass

#Define digit mapping
romanNumeralMap = (('M',  1000),
 ('CM', 900),
 ('D',  500),
 ('CD', 400),
 ('C',  100),
 ('XC', 90),
 ('L',  50),
 ('XL', 40),
 ('X',  10),
 ('IX', 9),
 ('V',  5),
 ('IV', 4),
 ('I',  1))

def to_roman(n):
    """convert integer to Roman numeral"""
    if not (0 &lt; n &lt; 4000):         <span>&#x2460;</span>
        raise OutOfRangeError, "number out of range (must be 1..3999)" <span>&#x2461;</span>
    if int(n) &lt;> n:                <span>&#x2462;</span>
        raise NotIntegerError, "non-integers can not be converted"

    result = ""  <span>&#x2463;</span>
    for numeral, integer in romanNumeralMap:
        while n >= integer:
            result += numeral
            n -= integer
    return result

def from_roman(s):
    """convert Roman numeral to integer"""
    pass
</pre><div class=calloutlist>
<ol>
<li>This is a nice Pythonic shortcut: multiple comparisons at once. This is equivalent to <code>if not ((0 &lt; n) and (n &lt; 4000))</code>, but it's much easier to read. This is the range check, and it should catch inputs that are too large, negative, or zero.
<li>You raise exceptions yourself with the <code>raise</code> statement. You can raise any of the built-in exceptions, or you can raise any of your custom exceptions that you've defined.
             The second parameter, the error message, is optional; if given, it is displayed in the traceback that is printed if the exception
            is never handled.
<li>This is the non-integer check. Non-integers can not be converted to Roman numerals.
<li>The rest of the function is unchanged.
<div class=example><h3>Example 14.7. Watching <code>to_roman()</code> handle bad input</h3><pre class=screen>
<samp class=prompt>>>> </samp><kbd>import roman3</kbd>
<samp class=prompt>>>> </samp><kbd>roman3.to_roman(4000)</kbd>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;interactive input>", line 1, in ?
  File "roman3.py", line 27, in to_roman
    raise OutOfRangeError, "number out of range (must be 1..3999)"
OutOfRangeError: number out of range (must be 1..3999)</samp>
<samp class=prompt>>>> </samp><kbd>roman3.to_roman(1.5)</kbd>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;interactive input>", line 1, in ?
  File "roman3.py", line 29, in to_roman
    raise NotIntegerError, "non-integers can not be converted"
NotIntegerError: non-integers can not be converted</span>
</pre><div class=example><h3>Example 14.8. Output of <code>romantest3.py</code> against <code>roman3.py</code></h3><pre class=screen><samp>from_roman should only accept uppercase input ... FAIL
to_roman should always return uppercase ... ok
from_roman should fail with malformed antecedents ... FAIL
from_roman should fail with repeated pairs of numerals ... FAIL
from_roman should fail with too many repeated numerals ... FAIL
from_roman should give known result with known input ... FAIL
to_roman should give known result with known input ... ok </span><span>&#x2460;</span><samp>
from_roman(to_roman(n))==n for all n ... FAIL
to_roman should fail with non-integer input ... ok        </span><span>&#x2461;</span><samp>
to_roman should fail with negative input ... ok           </span><span>&#x2462;</span><samp>
to_roman should fail with large input ... ok
to_roman should fail with 0 input ... ok</span></pre><div class=calloutlist>
<ol>
<li><code>to_roman()</code> still passes the <a href="#roman.testtoromanknownvalues.example" title="Example 13.2. testToRomanKnownValues">known values test</a>, which is comforting. All the tests that passed in <a href="#roman.stage2" title="14.2. roman.py, stage 2">stage 2</a> still pass, so the latest code hasn't broken anything.
<li>More exciting is the fact that all of the <a href="#roman.tobadinput.example" title="Example 13.3. Testing bad input to to_roman">bad input tests</a> now pass. This test, <code>testNonInteger</code>, passes because of the <code>int(n) &lt;> n</code> check. When a non-integer is passed to <code>to_roman()</code>, the <code>int(n) &lt;> n</code> check notices it and raises the <code>NotIntegerError</code> exception, which is what <code>testNonInteger</code> is looking for.
<li>This test, <code>testNegative</code>, passes because of the <code>not (0 &lt; n &lt; 4000)</code> check, which raises an <code>OutOfRangeError</code> exception, which is what <code>testNegative</code> is looking for.
<pre class=screen><samp>
======================================================================
FAIL: from_roman should only accept uppercase input
----------------------------------------------------------------------
</span><samp class=traceback>Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage3\romantest3.py", line 156, in testFromRomanCase
    roman3.from_roman, numeral.lower())
  File "c:\python21\lib\unittest.py", line 266, in failUnlessRaises
    raise self.failureException, excName
AssertionError: InvalidRomanNumeralError</span><samp>
======================================================================
FAIL: from_roman should fail with malformed antecedents
----------------------------------------------------------------------
</span><samp class=traceback>Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage3\romantest3.py", line 133, in testMalformedAntecedent
    self.assertRaises(roman3.InvalidRomanNumeralError, roman3.from_roman, s)
  File "c:\python21\lib\unittest.py", line 266, in failUnlessRaises
    raise self.failureException, excName
AssertionError: InvalidRomanNumeralError</span><samp>
======================================================================
FAIL: from_roman should fail with repeated pairs of numerals
----------------------------------------------------------------------
</span><samp class=traceback>Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage3\romantest3.py", line 127, in testRepeatedPairs
    self.assertRaises(roman3.InvalidRomanNumeralError, roman3.from_roman, s)
  File "c:\python21\lib\unittest.py", line 266, in failUnlessRaises
    raise self.failureException, excName
AssertionError: InvalidRomanNumeralError</span><samp>
======================================================================
FAIL: from_roman should fail with too many repeated numerals
----------------------------------------------------------------------
</span><samp class=traceback>Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage3\romantest3.py", line 122, in testTooManyRepeatedNumerals
    self.assertRaises(roman3.InvalidRomanNumeralError, roman3.from_roman, s)
  File "c:\python21\lib\unittest.py", line 266, in failUnlessRaises
    raise self.failureException, excName
AssertionError: InvalidRomanNumeralError</span><samp>
======================================================================
FAIL: from_roman should give known result with known input
----------------------------------------------------------------------
</span><samp class=traceback>Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage3\romantest3.py", line 99, in testFromRomanKnownValues
    self.assertEqual(integer, result)
  File "c:\python21\lib\unittest.py", line 273, in failUnlessEqual
    raise self.failureException, (msg or '%s != %s' % (first, second))
AssertionError: 1 != None</span><samp>
======================================================================
FAIL: from_roman(to_roman(n))==n for all n
----------------------------------------------------------------------
</span><samp class=traceback>Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage3\romantest3.py", line 141, in testSanity
    self.assertEqual(integer, result)
  File "c:\python21\lib\unittest.py", line 273, in failUnlessEqual
    raise self.failureException, (msg or '%s != %s' % (first, second))
AssertionError: 1 != None</span><samp>
----------------------------------------------------------------------
Ran 12 tests in 0.401s

FAILED (failures=6)</span> <span>&#x2460;</span></pre><div class=calloutlist>
<ol>
<li>You're down to 6 failures, and all of them involve <code>from_roman()</code>: the known values test, the three separate bad input tests, the case check, and the sanity check. That means that <code>to_roman()</code> has passed all the tests it can pass by itself. (It's involved in the sanity check, but that also requires that <code>from_roman()</code> be written, which it isn't yet.)  Which means that you must stop coding <code>to_roman()</code> now. No tweaking, no twiddling, no extra checks &#8220;just in case&#8221;. Stop. Now. Back away from the keyboard.
<table class=note border="0" summary="">

<td rowspan="2" align="center" valign="top" width="1%"><img src="images/note.png" alt="Note" title="" width="24" height="24"><td colspan="2" align="left" valign="top" width="99%">The most important thing that comprehensive unit testing can tell you is when to stop coding. When all the unit tests for
      a function pass, stop coding the function. When all the unit tests for an entire module pass, stop coding the module.
<h2 id="roman.stage4">14.4. <code>roman.py</code>, stage 4</h2>
<p>Now that <code>to_roman()</code> is done, it's time to start coding <code>from_roman()</code>. Thanks to the rich data structure that maps individual Roman numerals to integer values, this is no more difficult than
   the <code>to_roman()</code> function.
<div class=example><h3>Example 14.9. <code>roman4.py</code></h3>
<p>This file is available in <code>py/roman/stage4/</code> in the examples directory.
<p>If you have not already done so, you can <a href="http://diveintopython3.org/download/diveintopython3-examples-5.4.zip" title="Download example scripts">download this and other examples</a> used in this book.
<pre><code>
"""Convert to and from Roman numerals"""

#Define exceptions
class RomanError(Exception): pass
class OutOfRangeError(RomanError): pass
class NotIntegerError(RomanError): pass
class InvalidRomanNumeralError(RomanError): pass

#Define digit mapping
romanNumeralMap = (('M',  1000),
 ('CM', 900),
 ('D',  500),
 ('CD', 400),
 ('C',  100),
 ('XC', 90),
 ('L',  50),
 ('XL', 40),
 ('X',  10),
 ('IX', 9),
 ('V',  5),
 ('IV', 4),
 ('I',  1))

# to_roman function omitted for clarity (it hasn't changed)

def from_roman(s):
    """convert Roman numeral to integer"""
    result = 0
    index = 0
    for numeral, integer in romanNumeralMap:
        while s[index:index+len(numeral)] == numeral: <span>&#x2460;</span>
            result += integer
            index += len(numeral)
    return result
</pre><div class=calloutlist>
<ol>
<li>The pattern here is the same as <a href="#roman.stage2.example" title="Example 14.3. roman2.py"><code>to_roman()</code></a>. You iterate through your Roman numeral data structure (a tuple of tuples), and instead of matching the highest integer
            values as often as possible, you match the &#8220;highest&#8221; Roman numeral character strings as often as possible.
<div class=example><h3>Example 14.10. How <code>from_roman()</code> works</h3>
<p>If you're not clear how <code>from_roman()</code> works, add a <code>print</code> statement to the end of the <code>while</code> loop:<pre><code>
        while s[index:index+len(numeral)] == numeral:
            result += integer
            index += len(numeral)
            print 'found', numeral, 'of length', len(numeral), ', adding', integer</pre><pre class=screen>
<samp class=prompt>>>> </samp><kbd>import roman4</kbd>
<samp class=prompt>>>> </samp><kbd>roman4.from_roman('MCMLXXII')</kbd>
<samp>found M , of length 1, adding 1000
found CM , of length 2, adding 900
found L , of length 1, adding 50
found X , of length 1, adding 10
found X , of length 1, adding 10
found I , of length 1, adding 1
found I , of length 1, adding 1
1972</span></pre><div class=example><h3>Example 14.11. Output of <code>romantest4.py</code> against <code>roman4.py</code></h3><pre class=screen><samp>from_roman should only accept uppercase input ... FAIL
to_roman should always return uppercase ... ok
from_roman should fail with malformed antecedents ... FAIL
from_roman should fail with repeated pairs of numerals ... FAIL
from_roman should fail with too many repeated numerals ... FAIL
from_roman should give known result with known input ... ok </span><span>&#x2460;</span><samp>
to_roman should give known result with known input ... ok
from_roman(to_roman(n))==n for all n ... ok</span><span>&#x2461;</span><samp>
to_roman should fail with non-integer input ... ok
to_roman should fail with negative input ... ok
to_roman should fail with large input ... ok
to_roman should fail with 0 input ... ok</span></pre><div class=calloutlist>
<ol>
<li>Two pieces of exciting news here. The first is that <code>from_roman()</code> works for good input, at least for all the <a href="#roman.testtoromanknownvalues.example" title="Example 13.2. testToRomanKnownValues">known values</a> you test.
<li>The second is that the <a href="#roman.sanity.example" title="Example 13.5. Testing to_roman against from_roman">sanity check</a> also passed. Combined with the known values tests, you can be reasonably sure that both <code>to_roman()</code> and <code>from_roman()</code> work properly for all possible good values. (This is not guaranteed; it is theoretically possible that <code>to_roman()</code> has a bug that produces the wrong Roman numeral for some particular set of inputs, <em>and</em> that <code>from_roman()</code> has a reciprocal bug that produces the same wrong integer values for exactly that set of Roman numerals that <code>to_roman()</code> generated incorrectly. Depending on your application and your requirements, this possibility may bother you; if so, write
            more comprehensive test cases until it doesn't bother you.)
<pre class=screen><samp>
======================================================================
FAIL: from_roman should only accept uppercase input
----------------------------------------------------------------------
</span><samp class=traceback>Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage4\romantest4.py", line 156, in testFromRomanCase
    roman4.from_roman, numeral.lower())
  File "c:\python21\lib\unittest.py", line 266, in failUnlessRaises
    raise self.failureException, excName
AssertionError: InvalidRomanNumeralError</span><samp>
======================================================================
FAIL: from_roman should fail with malformed antecedents
----------------------------------------------------------------------
</span><samp class=traceback>Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage4\romantest4.py", line 133, in testMalformedAntecedent
    self.assertRaises(roman4.InvalidRomanNumeralError, roman4.from_roman, s)
  File "c:\python21\lib\unittest.py", line 266, in failUnlessRaises
    raise self.failureException, excName
AssertionError: InvalidRomanNumeralError</span><samp>
======================================================================
FAIL: from_roman should fail with repeated pairs of numerals
----------------------------------------------------------------------
</span><samp class=traceback>Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage4\romantest4.py", line 127, in testRepeatedPairs
    self.assertRaises(roman4.InvalidRomanNumeralError, roman4.from_roman, s)
  File "c:\python21\lib\unittest.py", line 266, in failUnlessRaises
    raise self.failureException, excName
AssertionError: InvalidRomanNumeralError</span><samp>
======================================================================
FAIL: from_roman should fail with too many repeated numerals
----------------------------------------------------------------------
</span><samp class=traceback>Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage4\romantest4.py", line 122, in testTooManyRepeatedNumerals
    self.assertRaises(roman4.InvalidRomanNumeralError, roman4.from_roman, s)
  File "c:\python21\lib\unittest.py", line 266, in failUnlessRaises
    raise self.failureException, excName
AssertionError: InvalidRomanNumeralError</span><samp>
----------------------------------------------------------------------
Ran 12 tests in 1.222s

FAILED (failures=4)</span></pre><h2 id="roman.stage5">14.5. <code>roman.py</code>, stage 5</h2>
<p>Now that <code>from_roman()</code> works properly with good input, it's time to fit in the last piece of the puzzle: making it work properly with bad input.
   That means finding a way to look at a string and determine if it's a valid Roman numeral. This is inherently more difficult
   than <a href="#roman.stage3" title="14.3. roman.py, stage 3">validating numeric input</a> in <code>to_roman()</code>, but you have a powerful tool at your disposal: regular expressions.
<p>If you're not familiar with regular expressions and didn't read <a href="#re" title="Chapter 7. Regular Expressions">Chapter 7, <i>Regular Expressions</i></a>, now would be a good time.
<p>As you saw in <a href="#re.roman" title="7.3. Case Study: Roman Numerals">Section 7.3, &#8220;Case Study: Roman Numerals&#8221;</a>, there are several simple rules for constructing a Roman numeral, using the letters <code>M</code>, <code>D</code>, <code>C</code>, <code>L</code>, <code>X</code>, <code>V</code>, and <code>I</code>. Let's review the rules:
<div class=orderedlist>
<ol>
<li>Characters are additive. <code>I</code> is <code>1</code>, <code>II</code> is <code>2</code>, and <code>III</code> is <code>3</code>. <code>VI</code> is <code>6</code> (literally, &#8220;<code>5</code> and <code>1</code>&#8221;), <code>VII</code> is <code>7</code>, and <code>VIII</code> is <code>8</code>.

<li>The tens characters (<code>I</code>, <code>X</code>, <code>C</code>, and <code>M</code>) can be repeated up to three times. At <code>4</code>, you need to subtract from the next highest fives character. You can't represent <code>4</code> as <code>IIII</code>; instead, it is represented as <code>IV</code> (&#8220;<code>1</code> less than <code>5</code>&#8221;). <code>40</code> is written as <code>XL</code> (&#8220;<code>10</code> less than <code>50</code>&#8221;), <code>41</code> as <code>XLI</code>, <code>42</code> as <code>XLII</code>, <code>43</code> as <code>XLIII</code>, and then <code>44</code> as <code>XLIV</code> (&#8220;<code>10</code> less than <code>50</code>, then <code>1</code> less than <code>5</code>&#8221;).

<li>Similarly, at <code>9</code>, you need to subtract from the next highest tens character: <code>8</code> is <code>VIII</code>, but <code>9</code> is <code>IX</code> (&#8220;<code>1</code> less than <code>10</code>&#8221;), not <code>VIIII</code> (since the <code>I</code> character can not be repeated four times). <code>90</code> is <code>XC</code>, <code>900</code> is <code>CM</code>.

<li>The fives characters can not be repeated. <code>10</code> is always represented as <code>X</code>, never as <code>VV</code>. <code>100</code> is always <code>C</code>, never <code>LL</code>.

<li>Roman numerals are always written highest to lowest, and read left to right, so order of characters matters very much. <code>DC</code> is <code>600</code>; <code>CD</code> is a completely different number (<code>400</code>, &#8220;<code>100</code> less than <code>500</code>&#8221;). <code>CI</code> is <code>101</code>; <code>IC</code> is not even a valid Roman numeral (because you can't subtract <code>1</code> directly from <code>100</code>; you would need to write it as <code>XCIX</code>, &#8220;<code>10</code> less than <code>100</code>, then <code>1</code> less than <code>10</code>&#8221;).

</ol>
<div class=example><h3>Example 14.12. <code>roman5.py</code></h3>
<p>This file is available in <code>py/roman/stage5/</code> in the examples directory.
<p>If you have not already done so, you can <a href="http://diveintopython3.org/download/diveintopython3-examples-5.4.zip" title="Download example scripts">download this and other examples</a> used in this book.
<pre><code>
"""Convert to and from Roman numerals"""
import re

#Define exceptions
class RomanError(Exception): pass
class OutOfRangeError(RomanError): pass
class NotIntegerError(RomanError): pass
class InvalidRomanNumeralError(RomanError): pass

#Define digit mapping
romanNumeralMap = (('M',  1000),
 ('CM', 900),
 ('D',  500),
 ('CD', 400),
 ('C',  100),
 ('XC', 90),
 ('L',  50),
 ('XL', 40),
 ('X',  10),
 ('IX', 9),
 ('V',  5),
 ('IV', 4),
 ('I',  1))

def to_roman(n):
    """convert integer to Roman numeral"""
    if not (0 &lt; n &lt; 4000):
        raise OutOfRangeError, "number out of range (must be 1..3999)"
    if int(n) &lt;> n:
        raise NotIntegerError, "non-integers can not be converted"

    result = ""
    for numeral, integer in romanNumeralMap:
        while n >= integer:
            result += numeral
            n -= integer
    return result

#Define pattern to detect valid Roman numerals
romanNumeralPattern = '^M?M?M?(CM|CD|D?C?C?C?)(XC|XL|L?X?X?X?)(IX|IV|V?I?I?I?)$' <span>&#x2460;</span>

def from_roman(s):
    """convert Roman numeral to integer"""
    if not re.search(romanNumeralPattern, s):<span>&#x2461;</span>
        raise InvalidRomanNumeralError, 'Invalid Roman numeral: %s' % s

    result = 0
    index = 0
    for numeral, integer in romanNumeralMap:
        while s[index:index+len(numeral)] == numeral:
            result += integer
            index += len(numeral)
    return result
</pre><div class=calloutlist>
<ol>
<li>This is just a continuation of the pattern you discussed in <a href="#re.roman" title="7.3. Case Study: Roman Numerals">Section 7.3, &#8220;Case Study: Roman Numerals&#8221;</a>. The tens places is either <code>XC</code> (<code>90</code>), <code>XL</code> (<code>40</code>), or an optional <code>L</code> followed by 0 to 3 optional <code>X</code> characters. The ones place is either <code>IX</code> (<code>9</code>), <code>IV</code> (<code>4</code>), or an optional <code>V</code> followed by 0 to 3 optional <code>I</code> characters.
<li>Having encoded all that logic into a regular expression, the code to check for invalid Roman numerals becomes trivial. If
<code>re.search</code> returns an object, then the regular expression matched and the input is valid; otherwise, the input is invalid.
<p>At this point, you are allowed to be skeptical that that big ugly regular expression could possibly catch all the types of
invalid Roman numerals. But don't take my word for it, look at the results:
<div class=example><h3>Example 14.13. Output of <code>romantest5.py</code> against <code>roman5.py</code></h3><pre class=screen><samp>
from_roman should only accept uppercase input ... ok          </span><span>&#x2460;</span><samp>
to_roman should always return uppercase ... ok
from_roman should fail with malformed antecedents ... ok      </span><span>&#x2461;</span><samp>
from_roman should fail with repeated pairs of numerals ... ok </span><span>&#x2462;</span><samp>
from_roman should fail with too many repeated numerals ... ok
from_roman should give known result with known input ... ok
to_roman should give known result with known input ... ok
from_roman(to_roman(n))==n for all n ... ok
to_roman should fail with non-integer input ... ok
to_roman should fail with negative input ... ok
to_roman should fail with large input ... ok
to_roman should fail with 0 input ... ok

----------------------------------------------------------------------
Ran 12 tests in 2.864s

OK     </span><span>&#x2463;</span></pre><div class=calloutlist>
<ol>
<li>One thing I didn't mention about regular expressions is that, by default, they are case-sensitive. Since the regular expression
<var>romanNumeralPattern</var> was expressed in uppercase characters, the <code>re.search</code> check will reject any input that isn't completely uppercase. So the uppercase input test passes.
<li>More importantly, the bad input tests pass. For instance, the malformed antecedents test checks cases like <code>MCMC</code>. As you've seen, this does not match the regular expression, so <code>from_roman()</code> raises an <code>InvalidRomanNumeralError</code> exception, which is what the malformed antecedents test case is looking for, so the test passes.
<li>In fact, all the bad input tests pass. This regular expression catches everything you could think of when you made your test
            cases.
<li>And the anticlimax award of the year goes to the word &#8220;<code>OK</code>&#8221;, which is printed by the <code>unittest</code> module when all the tests pass.
<table class=note border="0" summary="">

<td rowspan="2" align="center" valign="top" width="1%"><img src="images/note.png" alt="Note" title="" width="24" height="24"><td colspan="2" align="left" valign="top" width="99%">When all of your tests pass, stop coding.
<div class=chapter>
<h2 id="roman2">Chapter 15. Refactoring</h2>
<h2 id="roman.bugs">15.1. Handling bugs</h2>
<p>Despite your best efforts to write comprehensive unit tests, bugs happen. What do I mean by &#8220;bug&#8221;?  A bug is a test case you haven't written yet.
<div class=example><h3>Example 15.1. The bug</h3><pre class=screen><samp class=prompt>>>> </samp><kbd>import roman5</kbd>
<samp class=prompt>>>> </samp><kbd>roman5.from_roman("")</kbd> <span>&#x2460;</span>
0</pre><div class=calloutlist>
<ol>
<li>Remember in the <a href="#roman.stage5" title="14.5. roman.py, stage 5">previous section</a> when you kept seeing that an empty string would match the regular expression you were using to check for valid Roman numerals?
             Well, it turns out that this is still true for the final version of the regular expression. And that's a bug; you want an
            empty string to raise an <code>InvalidRomanNumeralError</code> exception just like any other sequence of characters that don't represent a valid Roman numeral.
<p>After reproducing the bug, and before fixing it, you should write a test case that fails, thus illustrating the bug.
<div class=example><h3>Example 15.2. Testing for the bug (<code>romantest61.py</code>)</h3><pre><code>
class FromRomanBadInput(unittest.TestCase):  

    # previous test cases omitted for clarity (they haven't changed)

    def testBlank(self):
        """from_roman should fail with blank string"""
        self.assertRaises(roman.InvalidRomanNumeralError, roman.from_roman, "") <span>&#x2460;</span>
</pre><div class=calloutlist>
<ol>
<li>Pretty simple stuff here. Call <code>from_roman()</code> with an empty string and make sure it raises an <code>InvalidRomanNumeralError</code> exception. The hard part was finding the bug; now that you know about it, testing for it is the easy part.
<p>Since your code has a bug, and you now have a test case that tests this bug, the test case will fail:
<div class=example><h3>Example 15.3. Output of <code>romantest61.py</code> against <code>roman61.py</code></h3><pre class=screen><samp>from_roman should only accept uppercase input ... ok
to_roman should always return uppercase ... ok
from_roman should fail with blank string ... FAIL
from_roman should fail with malformed antecedents ... ok
from_roman should fail with repeated pairs of numerals ... ok
from_roman should fail with too many repeated numerals ... ok
from_roman should give known result with known input ... ok
to_roman should give known result with known input ... ok
from_roman(to_roman(n))==n for all n ... ok
to_roman should fail with non-integer input ... ok
to_roman should fail with negative input ... ok
to_roman should fail with large input ... ok
to_roman should fail with 0 input ... ok

======================================================================
FAIL: from_roman should fail with blank string
----------------------------------------------------------------------
</span><samp class=traceback>Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage6\romantest61.py", line 137, in testBlank
    self.assertRaises(roman61.InvalidRomanNumeralError, roman61.from_roman, "")
  File "c:\python21\lib\unittest.py", line 266, in failUnlessRaises
    raise self.failureException, excName
AssertionError: InvalidRomanNumeralError</span><samp>
----------------------------------------------------------------------
Ran 13 tests in 2.864s

FAILED (failures=1)</span></pre><p><em>Now</em> you can fix the bug.
<div class=example><h3>Example 15.4. Fixing the bug (<code>roman62.py</code>)</h3>
<p>This file is available in <code>py/roman/stage6/</code> in the examples directory.
<pre><code>
def from_roman(s):
    """convert Roman numeral to integer"""
    if not s: <span>&#x2460;</span>
        raise InvalidRomanNumeralError, 'Input can not be blank'
    if not re.search(romanNumeralPattern, s):
        raise InvalidRomanNumeralError, 'Invalid Roman numeral: %s' % s

    result = 0
    index = 0
    for numeral, integer in romanNumeralMap:
        while s[index:index+len(numeral)] == numeral:
            result += integer
            index += len(numeral)
    return result
</pre><div class=calloutlist>
<ol>
<li>Only two lines of code are required: an explicit check for an empty string, and a <code>raise</code> statement.
<div class=example><h3>Example 15.5. Output of <code>romantest62.py</code> against <code>roman62.py</code></h3><pre class=screen><samp>from_roman should only accept uppercase input ... ok
to_roman should always return uppercase ... ok
from_roman should fail with blank string ... ok </span><span>&#x2460;</span><samp>
from_roman should fail with malformed antecedents ... ok
from_roman should fail with repeated pairs of numerals ... ok
from_roman should fail with too many repeated numerals ... ok
from_roman should give known result with known input ... ok
to_roman should give known result with known input ... ok
from_roman(to_roman(n))==n for all n ... ok
to_roman should fail with non-integer input ... ok
to_roman should fail with negative input ... ok
to_roman should fail with large input ... ok
to_roman should fail with 0 input ... ok

----------------------------------------------------------------------
Ran 13 tests in 2.834s

OK</span> <span>&#x2461;</span></pre><div class=calloutlist>
<ol>
<li>The blank string test case now passes, so the bug is fixed.
<li>All the other test cases still pass, which means that this bug fix didn't break anything else. Stop coding.
<p>Coding this way does not make fixing bugs any easier. Simple bugs (like this one) require simple test cases; complex bugs
will require complex test cases. In a testing-centric environment, it may <em>seem</em> like it takes longer to fix a bug, since you need to articulate in code exactly what the bug is (to write the test case),
then fix the bug itself. Then if the test case doesn't pass right away, you need to figure out whether the fix was wrong,
or whether the test case itself has a bug in it. However, in the long run, this back-and-forth between test code and code
tested pays for itself, because it makes it more likely that bugs are fixed correctly the first time. Also, since you can
easily re-run <em>all</em> the test cases along with your new one, you are much less likely to break old code when fixing new code. Today's unit test
is tomorrow's regression test.
<h2 id="roman.change">15.2. Handling changing requirements</h2>
<p>Despite your best efforts to pin your customers to the ground and extract exact requirements from them on pain of horrible
   nasty things involving scissors and hot wax, requirements will change. Most customers don't know what they want until they
   see it, and even if they do, they aren't that good at articulating what they want precisely enough to be useful. And even
   if they do, they'll want more in the next release anyway. So be prepared to update your test cases as requirements change.
<p>Suppose, for instance, that you wanted to expand the range of the Roman numeral conversion functions. Remember <a href="#roman.divein" title="13.2. Diving in">the rule</a> that said that no character could be repeated more than three times?  Well, the Romans were willing to make an exception
to that rule by having 4 <code>M</code> characters in a row to represent <code>4000</code>. If you make this change, you'll be able to expand the range of convertible numbers from <code>1..3999</code> to <code>1..4999</code>. But first, you need to make some changes to the test cases.
<div class=example><h3>Example 15.6. Modifying test cases for new requirements (<code>romantest71.py</code>)</h3>
<p>This file is available in <code>py/roman/stage7/</code> in the examples directory.
<p>If you have not already done so, you can <a href="http://diveintopython3.org/download/diveintopython3-examples-5.4.zip" title="Download example scripts">download this and other examples</a> used in this book.
<pre><code>
import roman71
import unittest

class KnownValues(unittest.TestCase):
    knownValues = ( (1, 'I'),
  (2, 'II'),
  (3, 'III'),
  (4, 'IV'),
  (5, 'V'),
  (6, 'VI'),
  (7, 'VII'),
  (8, 'VIII'),
  (9, 'IX'),
  (10, 'X'),
  (50, 'L'),
  (100, 'C'),
  (500, 'D'),
  (1000, 'M'),
  (31, 'XXXI'),
  (148, 'CXLVIII'),
  (294, 'CCXCIV'),
  (312, 'CCCXII'),
  (421, 'CDXXI'),
  (528, 'DXXVIII'),
  (621, 'DCXXI'),
  (782, 'DCCLXXXII'),
  (870, 'DCCCLXX'),
  (941, 'CMXLI'),
  (1043, 'MXLIII'),
  (1110, 'MCX'),
  (1226, 'MCCXXVI'),
  (1301, 'MCCCI'),
  (1485, 'MCDLXXXV'),
  (1509, 'MDIX'),
  (1607, 'MDCVII'),
  (1754, 'MDCCLIV'),
  (1832, 'MDCCCXXXII'),
  (1993, 'MCMXCIII'),
  (2074, 'MMLXXIV'),
  (2152, 'MMCLII'),
  (2212, 'MMCCXII'),
  (2343, 'MMCCCXLIII'),
  (2499, 'MMCDXCIX'),
  (2574, 'MMDLXXIV'),
  (2646, 'MMDCXLVI'),
  (2723, 'MMDCCXXIII'),
  (2892, 'MMDCCCXCII'),
  (2975, 'MMCMLXXV'),
  (3051, 'MMMLI'),
  (3185, 'MMMCLXXXV'),
  (3250, 'MMMCCL'),
  (3313, 'MMMCCCXIII'),
  (3408, 'MMMCDVIII'),
  (3501, 'MMMDI'),
  (3610, 'MMMDCX'),
  (3743, 'MMMDCCXLIII'),
  (3844, 'MMMDCCCXLIV'),
  (3888, 'MMMDCCCLXXXVIII'),
  (3940, 'MMMCMXL'),
  (3999, 'MMMCMXCIX'),
  (4000, 'MMMM'),   <span>&#x2460;</span>
  (4500, 'MMMMD'),
  (4888, 'MMMMDCCCLXXXVIII'),
  (4999, 'MMMMCMXCIX'))

    def testToRomanKnownValues(self):
        """to_roman should give known result with known input"""
        for integer, numeral in self.knownValues:
            result = roman71.to_roman(integer)
            self.assertEqual(numeral, result)

    def testFromRomanKnownValues(self):
        """from_roman should give known result with known input"""
        for integer, numeral in self.knownValues:
            result = roman71.from_roman(numeral)
            self.assertEqual(integer, result)

class ToRomanBadInput(unittest.TestCase):
    def testTooLarge(self):
        """to_roman should fail with large input"""
        self.assertRaises(roman71.OutOfRangeError, roman71.to_roman, 5000) <span>&#x2461;</span>

    def testZero(self):
        """to_roman should fail with 0 input"""
        self.assertRaises(roman71.OutOfRangeError, roman71.to_roman, 0)

    def testNegative(self):
        """to_roman should fail with negative input"""
        self.assertRaises(roman71.OutOfRangeError, roman71.to_roman, -1)

    def testNonInteger(self):
        """to_roman should fail with non-integer input"""
        self.assertRaises(roman71.NotIntegerError, roman71.to_roman, 0.5)

class FromRomanBadInput(unittest.TestCase):
    def testTooManyRepeatedNumerals(self):
        """from_roman should fail with too many repeated numerals"""
        for s in ('MMMMM', 'DD', 'CCCC', 'LL', 'XXXX', 'VV', 'IIII'):     <span>&#x2462;</span>
            self.assertRaises(roman71.InvalidRomanNumeralError, roman71.from_roman, s)

    def testRepeatedPairs(self):
        """from_roman should fail with repeated pairs of numerals"""
        for s in ('CMCM', 'CDCD', 'XCXC', 'XLXL', 'IXIX', 'IVIV'):
            self.assertRaises(roman71.InvalidRomanNumeralError, roman71.from_roman, s)

    def testMalformedAntecedent(self):
        """from_roman should fail with malformed antecedents"""
        for s in ('IIMXCC', 'VX', 'DCM', 'CMM', 'IXIV',
'MCMC', 'XCX', 'IVI', 'LM', 'LD', 'LC'):
            self.assertRaises(roman71.InvalidRomanNumeralError, roman71.from_roman, s)

    def testBlank(self):
        """from_roman should fail with blank string"""
        self.assertRaises(roman71.InvalidRomanNumeralError, roman71.from_roman, "")

class SanityCheck(unittest.TestCase):
    def testSanity(self):
        """from_roman(to_roman(n))==n for all n"""
        for integer in range(1, 5000):<span>&#x2463;</span>
            numeral = roman71.to_roman(integer)
            result = roman71.from_roman(numeral)
            self.assertEqual(integer, result)

class CaseCheck(unittest.TestCase):
    def testToRomanCase(self):
        """to_roman should always return uppercase"""
        for integer in range(1, 5000):
            numeral = roman71.to_roman(integer)
            self.assertEqual(numeral, numeral.upper())

    def testFromRomanCase(self):
        """from_roman should only accept uppercase input"""
        for integer in range(1, 5000):
            numeral = roman71.to_roman(integer)
            roman71.from_roman(numeral.upper())
            self.assertRaises(roman71.InvalidRomanNumeralError,
            roman71.from_roman, numeral.lower())

if __name__ == "__main__":
    unittest.main()
</pre><div class=calloutlist>
<ol>
<li>The existing known values don't change (they're all still reasonable values to test), but you need to add a few more in the
<code>4000</code> range. Here I've included <code>4000</code> (the shortest), <code>4500</code> (the second shortest), <code>4888</code> (the longest), and <code>4999</code> (the largest).
<li>The definition of &#8220;large input&#8221; has changed. This test used to call <code>to_roman()</code> with <code>4000</code> and expect an error; now that <code>4000-4999</code> are good values, you need to bump this up to <code>5000</code>.
<li>The definition of &#8220;too many repeated numerals&#8221; has also changed. This test used to call <code>from_roman()</code> with <code>'MMMM'</code> and expect an error; now that <code>MMMM</code> is considered a valid Roman numeral, you need to bump this up to <code>'MMMMM'</code>.
<li>The sanity check and case checks loop through every number in the range, from <code>1</code> to <code>3999</code>. Since the range has now expanded, these <code>for</code> loops need to be updated as well to go up to <code>4999</code>.
<p>Now your test cases are up to date with the new requirements, but your code is not, so you expect several of the test cases
to fail.
<div class=example><h3>Example 15.7. Output of <code>romantest71.py</code> against <code>roman71.py</code></h3><pre class=screen><samp>
from_roman should only accept uppercase input ... ERROR        </span><span>&#x2460;</span><samp>
to_roman should always return uppercase ... ERROR
from_roman should fail with blank string ... ok
from_roman should fail with malformed antecedents ... ok
from_roman should fail with repeated pairs of numerals ... ok
from_roman should fail with too many repeated numerals ... ok
from_roman should give known result with known input ... ERROR </span><span>&#x2461;</span><samp>
to_roman should give known result with known input ... ERROR   </span><span>&#x2462;</span><samp>
from_roman(to_roman(n))==n for all n ... ERROR</span><span>&#x2463;</span><samp>
to_roman should fail with non-integer input ... ok
to_roman should fail with negative input ... ok
to_roman should fail with large input ... ok
to_roman should fail with 0 input ... ok
</span></pre><div class=calloutlist>
<ol>
<li>Our case checks now fail because they loop from <code>1</code> to <code>4999</code>, but <code>to_roman()</code> only accepts numbers from <code>1</code> to <code>3999</code>, so it will fail as soon the test case hits <code>4000</code>.
<li>The <code>from_roman()</code> known values test will fail as soon as it hits <code>'MMMM'</code>, because <code>from_roman()</code> still thinks this is an invalid Roman numeral.
<li>The <code>to_roman()</code> known values test will fail as soon as it hits <code>4000</code>, because <code>to_roman()</code> still thinks this is out of range.
<li>The sanity check will also fail as soon as it hits <code>4000</code>, because <code>to_roman()</code> still thinks this is out of range.
<pre class=screen><samp>
======================================================================
ERROR: from_roman should only accept uppercase input
----------------------------------------------------------------------
</span><samp class=traceback>Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage7\romantest71.py", line 161, in testFromRomanCase
    numeral = roman71.to_roman(integer)
  File "roman71.py", line 28, in to_roman
    raise OutOfRangeError, "number out of range (must be 1..3999)"
OutOfRangeError: number out of range (must be 1..3999)</span><samp>
======================================================================
ERROR: to_roman should always return uppercase
----------------------------------------------------------------------
</span><samp class=traceback>Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage7\romantest71.py", line 155, in testToRomanCase
    numeral = roman71.to_roman(integer)
  File "roman71.py", line 28, in to_roman
    raise OutOfRangeError, "number out of range (must be 1..3999)"
OutOfRangeError: number out of range (must be 1..3999)</span><samp>
======================================================================
ERROR: from_roman should give known result with known input
----------------------------------------------------------------------
</span><samp class=traceback>Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage7\romantest71.py", line 102, in testFromRomanKnownValues
    result = roman71.from_roman(numeral)
  File "roman71.py", line 47, in from_roman
    raise InvalidRomanNumeralError, 'Invalid Roman numeral: %s' % s
InvalidRomanNumeralError: Invalid Roman numeral: MMMM</span><samp>
======================================================================
ERROR: to_roman should give known result with known input
----------------------------------------------------------------------
</span><samp class=traceback>Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage7\romantest71.py", line 96, in testToRomanKnownValues
    result = roman71.to_roman(integer)
  File "roman71.py", line 28, in to_roman
    raise OutOfRangeError, "number out of range (must be 1..3999)"
OutOfRangeError: number out of range (must be 1..3999)</span><samp>
======================================================================
ERROR: from_roman(to_roman(n))==n for all n
----------------------------------------------------------------------
</span><samp class=traceback>Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage7\romantest71.py", line 147, in testSanity
    numeral = roman71.to_roman(integer)
  File "roman71.py", line 28, in to_roman
    raise OutOfRangeError, "number out of range (must be 1..3999)"
OutOfRangeError: number out of range (must be 1..3999)</span><samp>
----------------------------------------------------------------------
Ran 13 tests in 2.213s

FAILED (errors=5)</span></pre><p>Now that you have test cases that fail due to the new requirements, you can think about fixing the code to bring it in line
with the test cases. (One thing that takes some getting used to when you first start coding unit tests is that the code being
tested is never &#8220;ahead&#8221; of the test cases. While it's behind, you still have some work to do, and as soon as it catches up to the test cases, you
stop coding.)
<div class=example><h3>Example 15.8. Coding the new requirements (<code>roman72.py</code>)</h3>
<p>This file is available in <code>py/roman/stage7/</code> in the examples directory.
<pre><code>
"""Convert to and from Roman numerals"""
import re

#Define exceptions
class RomanError(Exception): pass
class OutOfRangeError(RomanError): pass
class NotIntegerError(RomanError): pass
class InvalidRomanNumeralError(RomanError): pass

#Define digit mapping
romanNumeralMap = (('M',  1000),
 ('CM', 900),
 ('D',  500),
 ('CD', 400),
 ('C',  100),
 ('XC', 90),
 ('L',  50),
 ('XL', 40),
 ('X',  10),
 ('IX', 9),
 ('V',  5),
 ('IV', 4),
 ('I',  1))

def to_roman(n):
    """convert integer to Roman numeral"""
    if not (0 &lt; n &lt; 5000):   <span>&#x2460;</span>
        raise OutOfRangeError, "number out of range (must be 1..4999)"
    if int(n) &lt;> n:
        raise NotIntegerError, "non-integers can not be converted"

    result = ""
    for numeral, integer in romanNumeralMap:
        while n >= integer:
            result += numeral
            n -= integer
    return result

#Define pattern to detect valid Roman numerals
romanNumeralPattern = '^M?M?M?M?(CM|CD|D?C?C?C?)(XC|XL|L?X?X?X?)(IX|IV|V?I?I?I?)$' <span>&#x2461;</span>

def from_roman(s):
    """convert Roman numeral to integer"""
    if not s:
        raise InvalidRomanNumeralError, 'Input can not be blank'
    if not re.search(romanNumeralPattern, s):
        raise InvalidRomanNumeralError, 'Invalid Roman numeral: %s' % s

    result = 0
    index = 0
    for numeral, integer in romanNumeralMap:
        while s[index:index+len(numeral)] == numeral:
            result += integer
            index += len(numeral)
    return result
</pre><div class=calloutlist>
<ol>
<li><code>to_roman()</code> only needs one small change, in the range check. Where you used to check <code>0 &lt; n &lt; 4000</code>, you now check <code>0 &lt; n &lt; 5000</code>. And you change the error message that you <code>raise</code> to reflect the new acceptable range (<code>1..4999</code> instead of <code>1..3999</code>). You don't need to make any changes to the rest of the function; it handles the new cases already. (It merrily adds <code>'M'</code> for each thousand that it finds; given <code>4000</code>, it will spit out <code>'MMMM'</code>. The only reason it didn't do this before is that you explicitly stopped it with the range check.)
<li>You don't need to make any changes to <code>from_roman()</code> at all. The only change is to <var>romanNumeralPattern</var>; if you look closely, you'll notice that you added another optional <code>M</code> in the first section of the regular expression. This will allow up to 4 <code>M</code> characters instead of 3, meaning you will allow the Roman numeral equivalents of <code>4999</code> instead of <code>3999</code>. The actual <code>from_roman()</code> function is completely general; it just looks for repeated Roman numeral characters and adds them up, without caring how
         many times they repeat. The only reason it didn't handle <code>'MMMM'</code> before is that you explicitly stopped it with the regular expression pattern matching.
<p>You may be skeptical that these two small changes are all that you need. Hey, don't take my word for it; see for yourself:
<div class=example><h3 id="roman.roman72.output">Example 15.9. Output of <code>romantest72.py</code> against <code>roman72.py</code></h3><pre class=screen><samp>from_roman should only accept uppercase input ... ok
to_roman should always return uppercase ... ok
from_roman should fail with blank string ... ok
from_roman should fail with malformed antecedents ... ok
from_roman should fail with repeated pairs of numerals ... ok
from_roman should fail with too many repeated numerals ... ok
from_roman should give known result with known input ... ok
to_roman should give known result with known input ... ok
from_roman(to_roman(n))==n for all n ... ok
to_roman should fail with non-integer input ... ok
to_roman should fail with negative input ... ok
to_roman should fail with large input ... ok
to_roman should fail with 0 input ... ok

----------------------------------------------------------------------
Ran 13 tests in 3.685s

OK</span> <span>&#x2460;</span></pre><div class=calloutlist>
<ol>
<li>All the test cases pass. Stop coding.
<p>Comprehensive unit testing means never having to rely on a programmer who says &#8220;Trust me.&#8221;
<h2 id="roman.refactoring">15.3. Refactoring</h2>
<p>The best thing about comprehensive unit testing is not the feeling you get when all your test cases finally pass, or even
   the feeling you get when someone else blames you for breaking their code and you can actually <em>prove</em> that you didn't. The best thing about unit testing is that it gives you the freedom to refactor mercilessly.
<p>Refactoring is the process of taking working code and making it work better. Usually, &#8220;better&#8221; means &#8220;faster&#8221;, although it can also mean &#8220;using less memory&#8221;, or &#8220;using less disk space&#8221;, or simply &#8220;more elegantly&#8221;. Whatever it means to you, to your project, in your environment, refactoring is important to the long-term health of any
program.
<p>Here, &#8220;better&#8221; means &#8220;faster&#8221;. Specifically, the <code>from_roman()</code> function is slower than it needs to be, because of that big nasty regular expression that you use to validate Roman numerals.
It's probably not worth trying to do away with the regular expression altogether (it would be difficult, and it might not
end up any faster), but you can speed up the function by precompiling the regular expression.
<div class=example><h3>Example 15.10. Compiling regular expressions</h3><pre class=screen>
<samp class=prompt>>>> </samp><kbd>import re</kbd>
<samp class=prompt>>>> </samp><kbd>pattern = '^M?M?M?$'</kbd>
<samp class=prompt>>>> </samp><kbd>re.search(pattern, 'M')</kbd>               <span>&#x2460;</span>
&lt;SRE_Match object at 01090490>
<samp class=prompt>>>> </samp><kbd>compiledPattern = re.compile(pattern)</kbd> <span>&#x2461;</span>
<samp class=prompt>>>> </samp><kbd>compiledPattern</kbd>
&lt;SRE_Pattern object at 00F06E28>
<samp class=prompt>>>> </samp><kbd>dir(compiledPattern)</kbd><span>&#x2462;</span>
['findall', 'match', 'scanner', 'search', 'split', 'sub', 'subn']
<samp class=prompt>>>> </samp><kbd>compiledPattern.search('M')</kbd>           <span>&#x2463;</span>
&lt;SRE_Match object at 01104928></pre><div class=calloutlist>
<ol>
<li>This is the syntax you've seen before: <code>re.search</code> takes a regular expression as a string (<var>pattern</var>) and a string to match against it (<code>'M'</code>). If the pattern matches, the function returns a match object which can be queried to find out exactly what matched and
            how.
<li>This is the new syntax: <code>re.compile</code> takes a regular expression as a string and returns a pattern object. Note there is no string to match here. Compiling a
            regular expression has nothing to do with matching it against any specific strings (like <code>'M'</code>); it only involves the regular expression itself.
<li>The compiled pattern object returned from <code>re.compile</code> has several useful-looking functions, including several (like <code>search</code> and <code>sub</code>) that are available directly in the <code>re</code> module.
<li>Calling the compiled pattern object's <code>search</code> function with the string <code>'M'</code> accomplishes the same thing as calling <code>re.search</code> with both the regular expression and the string <code>'M'</code>. Only much, much faster. (In fact, the <code>re.search</code> function simply compiles the regular expression and calls the resulting pattern object's <code>search</code> method for you.)
<table class=note border="0" summary="">

<td rowspan="2" align="center" valign="top" width="1%"><img src="images/note.png" alt="Note" title="" width="24" height="24"><td colspan="2" align="left" valign="top" width="99%">Whenever you are going to use a regular expression more than once, you should compile it to get a pattern object, then call
      the methods on the pattern object directly.
<div class=example><h3>Example 15.11. Compiled regular expressions in <code>roman81.py</code></h3>
<p>This file is available in <code>py/roman/stage8/</code> in the examples directory.
<p>If you have not already done so, you can <a href="http://diveintopython3.org/download/diveintopython3-examples-5.4.zip" title="Download example scripts">download this and other examples</a> used in this book.
<pre><code>
# to_roman and rest of module omitted for clarity

romanNumeralPattern = \
    re.compile('^M?M?M?M?(CM|CD|D?C?C?C?)(XC|XL|L?X?X?X?)(IX|IV|V?I?I?I?)$') <span>&#x2460;</span>

def from_roman(s):
    """convert Roman numeral to integer"""
    if not s:
        raise InvalidRomanNumeralError, 'Input can not be blank'
    if not romanNumeralPattern.search(s):<span>&#x2461;</span>
        raise InvalidRomanNumeralError, 'Invalid Roman numeral: %s' % s

    result = 0
    index = 0
    for numeral, integer in romanNumeralMap:
        while s[index:index+len(numeral)] == numeral:
            result += integer
            index += len(numeral)
    return result
</pre><div class=calloutlist>
<ol>
<li>This looks very similar, but in fact a lot has changed. <var>romanNumeralPattern</var> is no longer a string; it is a pattern object which was returned from <code>re.compile</code>.
<li>That means that you can call methods on <var>romanNumeralPattern</var> directly. This will be much, much faster than calling <code>re.search</code> every time. The regular expression is compiled once and stored in <var>romanNumeralPattern</var> when the module is first imported; then, every time you call <code>from_roman()</code>, you can immediately match the input string against the regular expression, without any intermediate steps occurring under
            the covers.
<p>So how much faster is it to compile regular expressions?  See for yourself:
<div class=example><h3 id="roman.stage8.1.output">Example 15.12. Output of <code>romantest81.py</code> against <code>roman81.py</code></h3><pre class=screen>.............         <span>&#x2460;</span><samp>
----------------------------------------------------------------------
Ran 13 tests in 3.385s </span><span>&#x2461;</span><samp>

OK</span>   <span>&#x2462;</span></pre><div class=calloutlist>
<ol>
<li>Just a note in passing here: this time, I ran the unit test <em>without</em> the <code>-v</code> option, so instead of the full <code>docstring</code> for each test, you only get a dot for each test that passes. (If a test failed, you'd get an <code>F</code>, and if it had an error, you'd get an <code>E</code>. You'd still get complete tracebacks for each failure and error, so you could track down any problems.)
<li>You ran <code>13</code> tests in <code>3.385</code> seconds, compared to <a href="#roman.roman72.output" title="Example 15.9. Output of romantest72.py against roman72.py"><code>3.685</code> seconds</a> without precompiling the regular expressions. That's an <code>8%</code> improvement overall, and remember that most of the time spent during the unit test is spent doing other things. (Separately,
            I time-tested the regular expressions by themselves, apart from the rest of the unit tests, and found that compiling this
            regular expression speeds up the <code>search</code> by an average of <code>54%</code>.)  Not bad for such a simple fix.
<li>Oh, and in case you were wondering, precompiling the regular expression didn't break anything, and you just proved it.
<p>There is one other performance optimization that I want to try. Given the complexity of regular expression syntax, it should
come as no surprise that there is frequently more than one way to write the same expression. After some discussion about
this module on <a href="http://groups.google.com/groups?group=comp.lang.python">comp.lang.python</a>, someone suggested that I try using the <code>{<var>m</var>,<var>n</var>}</code> syntax for the optional repeated characters.
<div class=example><h3>Example 15.13. <code>roman82.py</code></h3>
<p>This file is available in <code>py/roman/stage8/</code> in the examples directory.
<p>If you have not already done so, you can <a href="http://diveintopython3.org/download/diveintopython3-examples-5.4.zip" title="Download example scripts">download this and other examples</a> used in this book.
<pre><code>
# rest of program omitted for clarity

#old version
#romanNumeralPattern = \
#   re.compile('^M?M?M?M?(CM|CD|D?C?C?C?)(XC|XL|L?X?X?X?)(IX|IV|V?I?I?I?)$')

#new version
romanNumeralPattern = \
    re.compile('^M{0,4}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})$') <span>&#x2460;</span>
</pre><div class=calloutlist>
<ol>
<li>You have replaced <code>M?M?M?M?</code> with <code>M{0,4}</code>. Both mean the same thing: &#8220;match 0 to 4 <code>M</code> characters&#8221;. Similarly, <code>C?C?C?</code> became <code>C{0,3}</code> (&#8220;match 0 to 3 <code>C</code> characters&#8221;) and so forth for <code>X</code> and <code>I</code>.
<p>This form of the regular expression is a little shorter (though not any more readable). The big question is, is it any faster?
<div class=example><h3>Example 15.14. Output of <code>romantest82.py</code> against <code>roman82.py</code></h3><pre class=screen><samp>.............
----------------------------------------------------------------------
Ran 13 tests in 3.315s </span><span>&#x2460;</span><samp>

OK</span>   <span>&#x2461;</span></pre><div class=calloutlist>
<ol>
<li>Overall, the unit tests run 2% faster with this form of regular expression. That doesn't sound exciting, but remember that
            the <code>search</code> function is a small part of the overall unit test; most of the time is spent doing other things. (Separately, I time-tested
            just the regular expressions, and found that the <code>search</code> function is <code>11%</code> faster with this syntax.)  By precompiling the regular expression and rewriting part of it to use this new syntax, you've
            improved the regular expression performance by over <code>60%</code>, and improved the overall performance of the entire unit test by over <code>10%</code>.
<li>More important than any performance boost is the fact that the module still works perfectly. This is the freedom I was talking
            about earlier: the freedom to tweak, change, or rewrite any piece of it and verify that you haven't messed anything up in
            the process. This is not a license to endlessly tweak your code just for the sake of tweaking it; you had a very specific
            objective (&#8220;make <code>from_roman()</code> faster&#8221;), and you were able to accomplish that objective without any lingering doubts about whether you introduced new bugs in the
            process.
<p>One other tweak I would like to make, and then I promise I'll stop refactoring and put this module to bed. As you've seen
repeatedly, regular expressions can get pretty hairy and unreadable pretty quickly. I wouldn't like to come back to this
module in six months and try to maintain it. Sure, the test cases pass, so I know that it works, but if I can't figure out
<em>how</em> it works, it's still going to be difficult to add new features, fix new bugs, or otherwise maintain it. As you saw in <a href="#re.verbose" title="7.5. Verbose Regular Expressions">Section 7.5, &#8220;Verbose Regular Expressions&#8221;</a>, Python provides a way to document your logic line-by-line.
<div class=example><h3>Example 15.15. <code>roman83.py</code></h3>
<p>This file is available in <code>py/roman/stage8/</code> in the examples directory.
<p>If you have not already done so, you can <a href="http://diveintopython3.org/download/diveintopython3-examples-5.4.zip" title="Download example scripts">download this and other examples</a> used in this book.
<pre><code>
# rest of program omitted for clarity

#old version
#romanNumeralPattern = \
#   re.compile('^M{0,4}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})$')

#new version
romanNumeralPattern = re.compile('''
    ^ # beginning of string
    M{0,4}              # thousands - 0 to 4 M's
    (CM|CD|D?C{0,3})    # hundreds - 900 (CM), 400 (CD), 0-300 (0 to 3 C's),
      #            or 500-800 (D, followed by 0 to 3 C's)
    (XC|XL|L?X{0,3})    # tens - 90 (XC), 40 (XL), 0-30 (0 to 3 X's),
      #        or 50-80 (L, followed by 0 to 3 X's)
    (IX|IV|V?I{0,3})    # ones - 9 (IX), 4 (IV), 0-3 (0 to 3 I's),
      #        or 5-8 (V, followed by 0 to 3 I's)
    $ # end of string
    ''', re.VERBOSE) <span>&#x2460;</span>
</pre><div class=calloutlist>
<ol>
<li>The <code>re.compile</code> function can take an optional second argument, which is a set of one or more flags that control various options about the
            compiled regular expression. Here you're specifying the <code>re.VERBOSE</code> flag, which tells Python that there are in-line comments within the regular expression itself. The comments and all the whitespace around them are
<em>not</em> considered part of the regular expression; the <code>re.compile</code> function simply strips them all out when it compiles the expression. This new, &#8220;verbose&#8221; version is identical to the old version, but it is infinitely more readable.
<div class=example><h3>Example 15.16. Output of <code>romantest83.py</code> against <code>roman83.py</code></h3><pre class=screen><samp>.............
----------------------------------------------------------------------
Ran 13 tests in 3.315s </span><span>&#x2460;</span><samp>

OK</span>   <span>&#x2461;</span></pre><div class=calloutlist>
<ol>
<li>This new, &#8220;verbose&#8221; version runs at exactly the same speed as the old version. In fact, the compiled pattern objects are the same, since the
<code>re.compile</code> function strips out all the stuff you added.
<li>This new, &#8220;verbose&#8221; version passes all the same tests as the old version. Nothing has changed, except that the programmer who comes back to
            this module in six months stands a fighting chance of understanding how the function works.
<h2 id="roman.postscript">15.4. Postscript</h2>
<p>A clever reader read the <a href="#roman.refactoring" title="15.3. Refactoring">previous section</a> and took it to the next level. The biggest headache (and performance drain) in the program as it is currently written is
   the regular expression, which is required because you have no other way of breaking down a Roman numeral. But there's only
   5000 of them; why don't you just build a lookup table once, then simply read that?  This idea gets even better when you realize
   that you don't need to use regular expressions at all. As you build the lookup table for converting integers to Roman numerals,
   you can build the reverse lookup table to convert Roman numerals to integers.
<p>And best of all, he already had a complete set of unit tests. He changed over half the code in the module, but the unit tests
stayed the same, so he could prove that his code worked just as well as the original.
<div class=example><h3>Example 15.17. <code>roman9.py</code></h3>
<p>This file is available in <code>py/roman/stage9/</code> in the examples directory.
<p>If you have not already done so, you can <a href="http://diveintopython3.org/download/diveintopython3-examples-5.4.zip" title="Download example scripts">download this and other examples</a> used in this book.
<pre><code>
#Define exceptions
class RomanError(Exception): pass
class OutOfRangeError(RomanError): pass
class NotIntegerError(RomanError): pass
class InvalidRomanNumeralError(RomanError): pass

#Roman numerals must be less than 5000
MAX_ROMAN_NUMERAL = 4999

#Define digit mapping
romanNumeralMap = (('M',  1000),
 ('CM', 900),
 ('D',  500),
 ('CD', 400),
 ('C',  100),
 ('XC', 90),
 ('L',  50),
 ('XL', 40),
 ('X',  10),
 ('IX', 9),
 ('V',  5),
 ('IV', 4),
 ('I',  1))

#Create tables for fast conversion of roman numerals.
#See fillLookupTables() below.
to_romanTable = [ None ]  # Skip an index since Roman numerals have no zero
from_romanTable = {}

def to_roman(n):
    """convert integer to Roman numeral"""
    if not (0 &lt; n &lt;= MAX_ROMAN_NUMERAL):
        raise OutOfRangeError, "number out of range (must be 1..%s)" % MAX_ROMAN_NUMERAL
    if int(n) &lt;> n:
        raise NotIntegerError, "non-integers can not be converted"
    return to_romanTable[n]

def from_roman(s):
    """convert Roman numeral to integer"""
    if not s:
        raise InvalidRomanNumeralError, "Input can not be blank"
    if not from_romanTable.has_key(s):
        raise InvalidRomanNumeralError, "Invalid Roman numeral: %s" % s
    return from_romanTable[s]

def to_romanDynamic(n):
    """convert integer to Roman numeral using dynamic programming"""
    result = ""
    for numeral, integer in romanNumeralMap:
        if n >= integer:
            result = numeral
            n -= integer
            break
    if n > 0:
        result += to_romanTable[n]
    return result

def fillLookupTables():
    """compute all the possible roman numerals"""
    #Save the values in two global tables to convert to and from integers.
    for integer in range(1, MAX_ROMAN_NUMERAL + 1):
        romanNumber = to_romanDynamic(integer)
        to_romanTable.append(romanNumber)
        from_romanTable[romanNumber] = integer

fillLookupTables()
</pre><p>So how fast is it?
<div class=example><h3>Example 15.18. Output of <code>romantest9.py</code> against <code>roman9.py</code></h3><pre class=screen>
<samp>
.............
----------------------------------------------------------------------
Ran 13 tests in 0.791s

OK
</span>
</pre><p>Remember, the best performance you ever got in the original version was 13 tests in 3.315 seconds. Of course, it's not entirely
a fair comparison, because this version will take longer to import (when it fills the lookup tables). But since import is
only done once, this is negligible in the long run.
<p>The moral of the story?
<div class=itemizedlist>
<ul>
<li>Simplicity is a virtue.
<li>Especially when regular expressions are involved.
<li>And unit tests can give you the confidence to do large-scale refactoring... even if you didn't write the original code.
</ul>
<h2 id="roman.summary">15.5. Summary</h2>
<p>Unit testing is a powerful concept which, if properly implemented, can both reduce maintenance costs and increase flexibility
   in any long-term project. It is also important to understand that unit testing is not a panacea, a Magic Problem Solver,
   or a silver bullet. Writing good test cases is hard, and keeping them up to date takes discipline (especially when customers
   are screaming for critical bug fixes). Unit testing is not a replacement for other forms of testing, including functional
   testing, integration testing, and user acceptance testing. But it is feasible, and it does work, and once you've seen it
   work, you'll wonder how you ever got along without it.
<p>This chapter covered a lot of ground, and much of it wasn't even Python-specific. There are unit testing frameworks for many languages, all of which require you to understand the same basic concepts:
<div class=highlights>
<div class=itemizedlist>
<ul>
<li>Designing test cases that are specific, automated, and independent
<li>Writing test cases <em>before</em> the code they are testing

<li>Writing tests that <a href="#roman.success" title="13.4. Testing for success">test good input</a> and check for proper results

<li>Writing tests that <a href="#roman.failure" title="13.5. Testing for failure">test bad input</a> and check for proper failures

<li>Writing and updating test cases to <a href="#roman.bugs" title="15.1. Handling bugs">illustrate bugs</a> or <a href="#roman.change" title="15.2. Handling changing requirements">reflect new requirements</a>
<li><a href="#roman.refactoring" title="15.3. Refactoring">Refactoring</a> mercilessly to improve performance, scalability, readability, maintainability, or whatever other -ility you're lacking

</ul>
<p>Additionally, you should be comfortable doing all of the following Python-specific things:
<div class=highlights>
<div class=itemizedlist>
<ul>
<li><a href="#roman.testtoromanknownvalues.example" title="Example 13.2. testToRomanKnownValues">Subclassing <code>unittest.TestCase</code></a> and writing methods for individual test cases

<li>Using <a href="#roman.testtoromanknownvalues.example" title="Example 13.2. testToRomanKnownValues"><code>assertEqual</code></a> to check that a function returns a known value

<li>Using <a href="#roman.tobadinput.example" title="Example 13.3. Testing bad input to to_roman"><code>assertRaises</code></a> to check that a function raises a known exception

<li>Calling <a href="#roman.stage1.output" title="Example 14.2. Output of romantest1.py against roman1.py"><code>unittest.main()</code></a> in your <code>if __name__</code> clause to run all your test cases at once

<li>Running unit tests in <a href="#roman.stage1.output" title="Example 14.2. Output of romantest1.py against roman1.py">verbose</a> or <a href="#roman.stage8.1.output" title="Example 15.12. Output of romantest81.py against roman81.py">regular</a> mode

</ul>
<div class=itemizedlist>
<h3>Further reading</h3>
<ul>
<li><a href="http://www.xprogramming.com/">XProgramming.com</a> has links to <a href="http://www.xprogramming.com/software.htm">download unit testing frameworks</a> for many different languages.

</ul>
<div class=chapter>
<h2 id="regression">Chapter 16. Functional Programming</h2>
<h2 id="regression.divein">16.1. Diving in</h2>
<p>In <a href="#roman" title="Chapter 13. Unit Testing">Chapter 13, <i>Unit Testing</i></a>, you learned about the philosophy of unit testing. In <a href="#roman1.5" title="Chapter 14. Test-First Programming">Chapter 14, <i>Test-First Programming</i></a>, you stepped through the implementation of basic unit tests in Python. In <a href="#roman2" title="Chapter 15. Refactoring">Chapter 15, <i>Refactoring</i></a>, you saw how unit testing makes large-scale refactoring easier. This chapter will build on those sample programs, but here
   we will focus more on advanced Python-specific techniques, rather than on unit testing itself.
<p>The following is a complete Python program that acts as a cheap and simple regression testing framework. It takes unit tests that you've written for individual
modules, collects them all into one big test suite, and runs them all at once. I actually use this script as part of the
build process for this book; I have unit tests for several of the example programs (not just the <code>roman.py</code> module featured in <a href="#roman" title="Chapter 13. Unit Testing">Chapter 13, <i>Unit Testing</i></a>), and the first thing my automated build script does is run this program to make sure all my examples still work. If this
regression test fails, the build immediately stops. I don't want to release non-working examples any more than you want to
download them and sit around scratching your head and yelling at your monitor and wondering why they don't work.
<div class=example><h3>Example 16.1. <code>regression.py</code></h3>
<p>If you have not already done so, you can <a href="http://diveintopython3.org/download/diveintopython3-examples-5.4.zip" title="Download example scripts">download this and other examples</a> used in this book.
<pre><code>
"""Regression testing framework

This module will search for scripts in the same directory named
XYZtest.py. Each such script should be a test suite that tests a
module through PyUnit. (As of Python 2.1, PyUnit is included in
the standard library as "unittest".)  This script will aggregate all
found test suites into one big test suite and run them all at once.
"""

import sys, os, re, unittest

def regressionTest():
    path = os.path.abspath(os.path.dirname(sys.argv[0]))   
    files = os.listdir(path)             
    test = re.compile("test\.py$", re.IGNORECASE)          
    files = filter(test.search, files)   
    filenameToModuleName = lambda f: os.path.splitext(f)[0]
    moduleNames = map(filenameToModuleName, files)         
    modules = map(__import__, moduleNames)                 
    load = unittest.defaultTestLoader.loadTestsFromModule  
    return unittest.TestSuite(map(load, modules))          

if __name__ == "__main__": 
    unittest.main(defaultTest="regressionTest")
</pre><p>Running this script in the same directory as the rest of the example scripts that come with this book will find all the unit
tests, named <code><var><code>module</code></var>test.py</code>, run them as a single test, and pass or fail them all at once.
<div class=example><h3>Example 16.2. Sample output of <code>regression.py</code></h3><pre class=screen>
<samp class=prompt>[you@localhost py]$ </samp>python regression.py -v
help should fail with no object ... ok           <span>&#x2460;</span><samp>
help should return known result for apihelper ... ok
help should honor collapse argument ... ok
help should honor spacing argument ... ok
buildConnectionString should fail with list input ... ok           </span><span>&#x2461;</span><samp>
buildConnectionString should fail with string input ... ok
buildConnectionString should fail with tuple input ... ok
buildConnectionString handles empty dictionary ... ok
buildConnectionString returns known result with known input ... ok
from_roman should only accept uppercase input ... ok                </span><span>&#x2462;</span><samp>
to_roman should always return uppercase ... ok
from_roman should fail with blank string ... ok
from_roman should fail with malformed antecedents ... ok
from_roman should fail with repeated pairs of numerals ... ok
from_roman should fail with too many repeated numerals ... ok
from_roman should give known result with known input ... ok
to_roman should give known result with known input ... ok
from_roman(to_roman(n))==n for all n ... ok
to_roman should fail with non-integer input ... ok
to_roman should fail with negative input ... ok
to_roman should fail with large input ... ok
to_roman should fail with 0 input ... ok
kgp a ref test ... ok
kgp b ref test ... ok
kgp c ref test ... ok
kgp d ref test ... ok
kgp e ref test ... ok
kgp f ref test ... ok
kgp g ref test ... ok

----------------------------------------------------------------------
Ran 29 tests in 2.799s

OK</span></pre><div class=calloutlist>
<ol>
<li>The first 5 tests are from <code>apihelpertest.py</code>, which tests the example script from <a href="#apihelper" title="Chapter 4. The Power Of Introspection">Chapter 4, <i>The Power Of Introspection</i></a>.
<li>The next 5 tests are from <code>odbchelpertest.py</code>, which tests the example script from <a href="#odbchelper" title="Chapter 2. Your First Python Program">Chapter 2, <i>Your First Python Program</i></a>.
<li>The rest are from <code>romantest.py</code>, which you studied in depth in <a href="#roman" title="Chapter 13. Unit Testing">Chapter 13, <i>Unit Testing</i></a>.
<h2 id="regression.path">16.2. Finding the path</h2>
<p>When running Python scripts from the command line, it is sometimes useful to know where the currently running script is located on disk.
<p>This is one of those obscure little tricks that is virtually impossible to figure out on your own, but simple to remember
once you see it. The key to it is <code>sys.argv</code>. As you saw in <a href="#kgp" title="Chapter 9. XML Processing">Chapter 9, <i>XML Processing</i></a>, this is a list that holds the list of command-line arguments. However, it also holds the name of the running script, exactly
as it was called from the command line, and this is enough information to determine its location.
<div class=example><h3>Example 16.3. <code>fullpath.py</code></h3>
<p>If you have not already done so, you can <a href="http://diveintopython3.org/download/diveintopython3-examples-5.4.zip" title="Download example scripts">download this and other examples</a> used in this book.
<pre><code>
import sys, os

print 'sys.argv[0] =', sys.argv[0]             <span>&#x2460;</span>
pathname = os.path.dirname(sys.argv[0])        <span>&#x2461;</span>
print 'path =', pathname
print 'full path =', os.path.abspath(pathname) <span>&#x2462;</span></pre><div class=calloutlist>
<ol>
<li>Regardless of how you run a script, <code>sys.argv[0]</code> will always contain the name of the script, exactly as it appears on the command line. This may or may not include any path
            information, as you'll see shortly.
<li><code>os.path.dirname</code> takes a filename as a string and returns the directory path portion. If the given filename does not include any path information,
<code>os.path.dirname</code> returns an empty string.
<li><code>os.path.abspath</code> is the key here. It takes a pathname, which can be partial or even blank, and returns a fully qualified pathname.
<p><code>os.path.abspath</code> deserves further explanation. It is very flexible; it can take any kind of pathname.
<div class=example><h3>Example 16.4. Further explanation of <code>os.path.abspath</code></h3><pre class=screen>
<samp class=prompt>>>> </samp><kbd>import os</kbd>
<samp class=prompt>>>> </samp><kbd>os.getcwd()</kbd>      <span>&#x2460;</span>
/home/you
<samp class=prompt>>>> </samp><kbd>os.path.abspath('')</kbd>                <span>&#x2461;</span>
/home/you
<samp class=prompt>>>> </samp><kbd>os.path.abspath('.ssh')</kbd>            <span>&#x2462;</span>
/home/you/.ssh
<samp class=prompt>>>> </samp><kbd>os.path.abspath('/home/you/.ssh')</kbd> <span>&#x2463;</span>
/home/you/.ssh
<samp class=prompt>>>> </samp><kbd>os.path.abspath('.ssh/../foo/')</kbd>    <span>&#x2464;</span>
/home/you/foo</pre><div class=calloutlist>
<ol>
<li><code>os.getcwd()</code> returns the current working directory.
<li>Calling <code>os.path.abspath</code> with an empty string returns the current working directory, same as <code>os.getcwd()</code>.
<li>Calling <code>os.path.abspath</code> with a partial pathname constructs a fully qualified pathname out of it, based on the current working directory.
<li>Calling <code>os.path.abspath</code> with a full pathname simply returns it.
<li><code>os.path.abspath</code> also <em>normalizes</em> the pathname it returns. Note that this example worked even though I don't actually have a 'foo' directory. <code>os.path.abspath</code> never checks your actual disk; this is all just string manipulation.
<table id="os.path.abspath.exist.note" class=note border="0" summary="">

<td rowspan="2" align="center" valign="top" width="1%"><img src="images/note.png" alt="Note" title="" width="24" height="24"><td colspan="2" align="left" valign="top" width="99%">The pathnames and filenames you pass to <code>os.path.abspath</code> do not need to exist.
<table id="os.path.normpath.note" class=note border="0" summary="">

<td rowspan="2" align="center" valign="top" width="1%"><img src="images/note.png" alt="Note" title="" width="24" height="24"><td colspan="2" align="left" valign="top" width="99%"><code>os.path.abspath</code> not only constructs full path names, it also normalizes them. That means that if you are in the <code>/usr/</code> directory, <code>os.path.abspath('bin/../local/bin')</code> will return <code>/usr/local/bin</code>. It normalizes the path by making it as simple as possible. If you just want to normalize a pathname like this without
      turning it into a full pathname, use <code>os.path.normpath</code> instead.
<div class=example><h3>Example 16.5. Sample output from <code>fullpath.py</code></h3><pre class=screen>
<samp class=prompt>[you@localhost py]$ </samp>python /home/you/diveintopython3/common/py/fullpath.py <span>&#x2460;</span>
<samp>sys.argv[0] = /home/you/diveintopython3/common/py/fullpath.py
path = /home/you/diveintopython3/common/py
full path = /home/you/diveintopython3/common/py</samp>
<samp class=prompt>[you@localhost diveintopython3]$ </samp>python common/py/fullpath.py               <span>&#x2461;</span>
<samp>sys.argv[0] = common/py/fullpath.py
path = common/py
full path = /home/you/diveintopython3/common/py</samp>
<samp class=prompt>[you@localhost diveintopython3]$ </samp>cd common/py
<samp class=prompt>[you@localhost py]$ </samp>python fullpath.py <span>&#x2462;</span>
<samp>sys.argv[0] = fullpath.py
path = 
full path = /home/you/diveintopython3/common/py</span></pre><div class=calloutlist>
<ol>
<li>In the first case, <code>sys.argv[0]</code> includes the full path of the script. You can then use the <code>os.path.dirname</code> function to strip off the script name and return the full directory name, and <code>os.path.abspath</code> simply returns what you give it.
<li>If the script is run by using a partial pathname, <code>sys.argv[0]</code> will still contain exactly what appears on the command line. <code>os.path.dirname</code> will then give you a partial pathname (relative to the current directory), and <code>os.path.abspath</code> will construct a full pathname from the partial pathname.
<li>If the script is run from the current directory without giving any path, <code>os.path.dirname</code> will simply return an empty string. Given an empty string, <code>os.path.abspath</code> returns the current directory, which is what you want, since the script was run from the current directory.
<table id="os.path.abspath.crossplatform.note" class=note border="0" summary="">

<td rowspan="2" align="center" valign="top" width="1%"><img src="images/note.png" alt="Note" title="" width="24" height="24"><td colspan="2" align="left" valign="top" width="99%">Like the other functions in the <code>os</code> and <code>os.path</code> modules, <code>os.path.abspath</code> is cross-platform. Your results will look slightly different than my examples if you're running on Windows (which uses backslash
      as a path separator) or Mac OS (which uses colons), but they'll still work. That's the whole point of the <code>os</code> module.
<p><b>Addendum. </b>One reader was dissatisfied with this solution, and wanted to be able to run all the unit tests in the current directory,
not the directory where <code>regression.py</code> is located. He suggests this approach instead:
<div class=example><h3 id="regression.path.cwd.example">Example 16.6. Running scripts in the current directory</h3><pre><code>import sys, os, re, unittest

def regressionTest():
    path = os.getcwd()       <span>&#x2460;</span>
    sys.path.append(path)    <span>&#x2461;</span>
    files = os.listdir(path) <span>&#x2462;</span>
</pre><div class=calloutlist>
<ol>
<li>Instead of setting <var>path</var> to the directory where the currently running script is located, you set it to the current working directory instead. This
            will be whatever directory you were in before you ran the script, which is not necessarily the same as the directory the script
            is in. (Read that sentence a few times until you get it.)
<li>Append this directory to the Python library search path, so that when you dynamically import the unit test modules later, Python can find them. You didn't need to do this when <var>path</var> was the directory of the currently running script, because Python always looks in that directory.
<li>The rest of the function is the same.
<p>This technique will allow you to re-use this <code>regression.py</code> script on multiple projects. Just put the script in a common directory, then change to the project's directory before running
   it. All of that project's unit tests will be found and tested, instead of the unit tests in the common directory where <code>regression.py</code> is located.
<h2 id="regression.filter">16.3. Filtering lists revisited</h2>
<p>You're already familiar with <a href="#apihelper.filter" title="4.5. Filtering Lists">using list comprehensions to filter lists</a>. There is another way to accomplish this same thing, which some people feel is more expressive.
<p>Python has a built-in <code>filter</code> function which takes two arguments, a function and a list, and returns a list.
<sup>[<a name="d0e35697" href="#ftn.d0e35697">7</a>]</sup>  The function passed as the first argument to <code>filter</code> must itself take one argument, and the list that <code>filter</code> returns will contain all the elements from the list passed to <code>filter</code> for which the function passed to <code>filter</code> returns true.
<p>Got all that?  It's not as difficult as it sounds.
<div class=example><h3>Example 16.7. Introducing <code>filter</code></h3><pre class=screen>
<samp class=prompt>>>> </samp><kbd>def odd(n):</kbd>                 <span>&#x2460;</span>
<samp class=prompt>...    </samp>return n % 2
<samp class=prompt>...    </samp>
<samp class=prompt>>>> </samp><kbd>li = [1, 2, 3, 5, 9, 10, 256, -3]</kbd>
<samp class=prompt>>>> </samp><kbd>filter(odd, li)</kbd>             <span>&#x2461;</span>
[1, 3, 5, 9, -3]
<samp class=prompt>>>> </samp><kbd>[e for e in li if odd(e)]</kbd>   <span>&#x2462;</span>
<samp class=prompt>>>> </samp><kbd>filteredList = []</kbd>
<samp class=prompt>>>> </samp><kbd>for n in li:</kbd>                <span>&#x2463;</span>
<samp class=prompt>...    </samp>if odd(n):
<samp class=prompt>...    </samp>    filteredList.append(n)
<samp class=prompt>...    </samp>
<samp class=prompt>>>> </samp><kbd>filteredList</kbd>
[1, 3, 5, 9, -3]</pre><div class=calloutlist>
<ol>
<li><code>odd</code> uses the built-in mod function &#8220;<code>%</code>&#8221; to return <code>True</code> if <var>n</var> is odd and <code>False</code> if <var>n</var> is even.
<li><code>filter</code> takes two arguments, a function (<code>odd</code>) and a list (<var>li</var>). It loops through the list and calls <code>odd</code> with each element. If <code>odd</code> returns a true value (remember, any non-zero value is true in Python), then the element is included in the returned list, otherwise it is filtered out. The result is a list of only the odd
            numbers from the original list, in the same order as they appeared in the original.
<li>You could accomplish the same thing using list comprehensions, as you saw in <a href="#apihelper.filter" title="4.5. Filtering Lists">Section 4.5, &#8220;Filtering Lists&#8221;</a>.
<li>You could also accomplish the same thing with a <code>for</code> loop. Depending on your programming background, this may seem more &#8220;straightforward&#8221;, but functions like <code>filter</code> are much more expressive. Not only is it easier to write, it's easier to read, too. Reading the <code>for</code> loop is like standing too close to a painting; you see all the details, but it may take a few seconds to be able to step
            back and see the bigger picture: &#8220;Oh, you're just filtering the list!&#8221;
<div class=example><h3>Example 16.8. <code>filter</code> in <code>regression.py</code></h3><pre><code>
    files = os.listdir(path)              <span>&#x2460;</span>
    test = re.compile("test\.py$", re.IGNORECASE)           <span>&#x2461;</span>
    files = filter(test.search, files)    <span>&#x2462;</span></pre><div class=calloutlist>
<ol>
<li>As you saw in <a href="#regression.path" title="16.2. Finding the path">Section 16.2, &#8220;Finding the path&#8221;</a>, <var>path</var> may contain the full or partial pathname of the directory of the currently running script, or it may contain an empty string
            if the script is being run from the current directory. Either way, <var>files</var> will end up with the names of the files in the same directory as this script you're running.
<li>This is a compiled regular expression. As you saw in <a href="#roman.refactoring" title="15.3. Refactoring">Section 15.3, &#8220;Refactoring&#8221;</a>, if you're going to use the same regular expression over and over, you should compile it for faster performance. The compiled
            object has a <code>search</code> method which takes a single argument, the string to search. If the regular expression matches the string, the <code>search</code> method returns a <code>Match</code> object containing information about the regular expression match; otherwise it returns <code>None</code>, the Python null value.
<li>For each element in the <var>files</var> list, you're going to call the <code>search</code> method of the compiled regular expression object, <var>test</var>. If the regular expression matches, the method will return a <code>Match</code> object, which Python considers to be true, so the element will be included in the list returned by <code>filter</code>. If the regular expression does not match, the <code>search</code> method will return <code>None</code>, which Python considers to be false, so the element will not be included.
<p><b>Historical note. </b>Versions of Python prior to 2.0 did not have <a href="#odbchelper.map" title="3.6. Mapping Lists">list comprehensions</a>, so you couldn't <a href="#apihelper.filter" title="4.5. Filtering Lists">filter using list comprehensions</a>; the <code>filter</code> function was the only game in town. Even with the introduction of list comprehensions in 2.0, some people still prefer the
old-style <code>filter</code> (and its companion function, <code>map</code>, which you'll see later in this chapter). Both techniques work at the moment, so which one you use is a matter of style.
There is discussion that <code>map</code> and <code>filter</code> might be deprecated in a future version of Python, but no decision has been made.
<div class=example><h3>Example 16.9. Filtering using list comprehensions instead</h3><pre><code>
    files = os.listdir(path)             
    test = re.compile("test\.py$", re.IGNORECASE)          
    files = [f for f in files if test.search(f)] <span>&#x2460;</span></pre><div class=calloutlist>
<ol>
<li>This will accomplish exactly the same result as using the <code>filter</code> function. Which way is more expressive?  That's up to you.
<h2 id="regression.map">16.4. Mapping lists revisited</h2>
<p>You're already familiar with using <a href="#odbchelper.map" title="3.6. Mapping Lists">list comprehensions</a> to map one list into another. There is another way to accomplish the same thing, using the built-in <code>map</code> function. It works much the same way as the <a href="#regression.filter" title="16.3. Filtering lists revisited"><code>filter</code></a> function.
<div class=example><h3>Example 16.10. Introducing <code>map</code></h3><pre class=screen>
<samp class=prompt>>>> </samp><kbd>def double(n):</kbd>
<samp class=prompt>...    </samp>return n*2
<samp class=prompt>...    </samp>
<samp class=prompt>>>> </samp><kbd>li = [1, 2, 3, 5, 9, 10, 256, -3]</kbd>
<samp class=prompt>>>> </samp><kbd>map(double, li)</kbd>     <span>&#x2460;</span>
[2, 4, 6, 10, 18, 20, 512, -6]
<samp class=prompt>>>> </samp><kbd>[double(n) for n in li]</kbd>               <span>&#x2461;</span>
[2, 4, 6, 10, 18, 20, 512, -6]
<samp class=prompt>>>> </samp><kbd>newlist = []</kbd>
<samp class=prompt>>>> </samp><kbd>for n in li:</kbd>        <span>&#x2462;</span>
<samp class=prompt>...    </samp>newlist.append(double(n))
<samp class=prompt>...    </samp>
<samp class=prompt>>>> </samp><kbd>newlist</kbd>
[2, 4, 6, 10, 18, 20, 512, -6]</pre><div class=calloutlist>
<ol>
<li><code>map</code> takes a function and a list<sup>[<a name="d0e36079" href="#ftn.d0e36079">8</a>]</sup> and returns a new list by calling the function with each element of the list in order. In this case, the function simply
            multiplies each element by 2.
<li>You could accomplish the same thing with a list comprehension. List comprehensions were first introduced in Python 2.0; <code>map</code> has been around forever.
<li>You could, if you insist on thinking like a Visual Basic programmer, use a <code>for</code> loop to accomplish the same thing.
<div class=example><h3>Example 16.11. <code>map</code> with lists of mixed datatypes</h3><pre class=screen>
<samp class=prompt>>>> </samp><kbd>li = [5, 'a', (2, 'b')]</kbd>
<samp class=prompt>>>> </samp><kbd>map(double, li)</kbd>     <span>&#x2460;</span>
[10, 'aa', (2, 'b', 2, 'b')]</pre><div class=calloutlist>
<ol>
<li>As a side note, I'd like to point out that <code>map</code> works just as well with lists of mixed datatypes, as long as the function you're using correctly handles each type. In this
            case, the <code>double</code> function simply multiplies the given argument by 2, and Python Does The Right Thing depending on the datatype of the argument. For integers, this means actually multiplying it by 2; for
            strings, it means concatenating the string with itself; for tuples, it means making a new tuple that has all of the elements
            of the original, then all of the elements of the original again.
<p>All right, enough play time. Let's look at some real code.
<div class=example><h3>Example 16.12. <code>map</code> in <code>regression.py</code></h3><pre><code>
    filenameToModuleName = lambda f: os.path.splitext(f)[0] <span>&#x2460;</span>
    moduleNames = map(filenameToModuleName, files)          <span>&#x2461;</span></pre><div class=calloutlist>
<ol>
<li>As you saw in <a href="#apihelper.lambda" title="4.7. Using lambda Functions">Section 4.7, &#8220;Using lambda Functions&#8221;</a>, <code>lambda</code> defines an inline function. And as you saw in <a href="#splittingpathnames.example" title="Example 6.17. Splitting Pathnames">Example 6.17, &#8220;Splitting Pathnames&#8221;</a>, <code>os.path.splitext</code> takes a filename and returns a tuple <code>(<var>name</var>, <var>extension</var>)</code>. So <code>filenameToModuleName</code> is a function which will take a filename and strip off the file extension, and return just the name.
<li>Calling <code>map</code> takes each filename listed in <var>files</var>, passes it to the function <code>filenameToModuleName</code>, and returns a list of the return values of each of those function calls. In other words, you strip the file extension off
            of each filename, and store the list of all those stripped filenames in <var>moduleNames</var>.
<p>As you'll see in the rest of the chapter, you can extend this type of data-centric thinking all the way to the final goal,
which is to define and execute a single test suite that contains the tests from all of those individual test suites.
<h2 id="regression.datacentric">16.5. Data-centric programming</h2>
<p>By now you're probably scratching your head wondering why this is better than using <code>for</code> loops and straight function calls. And that's a perfectly valid question. Mostly, it's a matter of perspective. Using
<code>map</code> and <code>filter</code> forces you to center your thinking around your data.
<p>In this case, you started with no data at all; the first thing you did was <a href="#regression.path" title="16.2. Finding the path">get the directory path</a> of the current script, and got a list of files in that directory. That was the bootstrap, and it gave you real data to work
with: a list of filenames.
<p>However, you knew you didn't care about all of those files, only the ones that were actually test suites. You had <em>too much data</em>, so you needed to <code>filter</code> it. How did you know which data to keep?  You needed a test to decide, so you defined one and passed it to the <code>filter</code> function. In this case you used a regular expression to decide, but the concept would be the same regardless of how you
constructed the test.
<p>Now you had the filenames of each of the test suites (and only the test suites, since everything else had been filtered out),
but you really wanted module names instead. You had the right amount of data, but it was <em>in the wrong format</em>. So you defined a function that would transform a single filename into a module name, and you mapped that function onto
the entire list. From one filename, you can get a module name; from a list of filenames, you can get a list of module names.
<p>Instead of <code>filter</code>, you could have used a <code>for</code> loop with an <code>if</code> statement. Instead of <code>map</code>, you could have used a <code>for</code> loop with a function call. But using <code>for</code> loops like that is busywork. At best, it simply wastes time; at worst, it introduces obscure bugs. For instance, you need
to figure out how to test for the condition &#8220;is this file a test suite?&#8221; anyway; that's the application-specific logic, and no language can write that for us. But once you've figured that out,
do you really want go to all the trouble of defining a new empty list and writing a <code>for</code> loop and an <code>if</code> statement and manually calling <code>append</code> to add each element to the new list if it passes the condition and then keeping track of which variable holds the new filtered
data and which one holds the old unfiltered data?  Why not just define the test condition, then let Python do the rest of that work for us?
<p>Oh sure, you could try to be fancy and delete elements in place without creating a new list. But you've been burned by that
before. Trying to modify a data structure that you're looping through can be tricky. You delete an element, then loop to
the next element, and suddenly you've skipped one. Is Python one of the languages that works that way?  How long would it take you to figure it out?  Would you remember for certain whether
it was safe the next time you tried?  Programmers spend so much time and make so many mistakes dealing with purely technical
issues like this, and it's all pointless. It doesn't advance your program at all; it's just busywork.
<p>I resisted list comprehensions when I first learned Python, and I resisted <code>filter</code> and <code>map</code> even longer. I insisted on making my life more difficult, sticking to the familiar way of <code>for</code> loops and <code>if</code> statements and step-by-step code-centric programming. And my Python programs looked a lot like Visual Basic programs, detailing every step of every operation in every function. And they had all the same types of little problems
and obscure bugs. And it was all pointless.
<p>Let it all go. Busywork code is not important. Data is important. And data is not difficult. It's only data. If you have
too much, filter it. If it's not what you want, map it. Focus on the data; leave the busywork behind.
<h2 id="regression.import">16.6. Dynamically importing modules</h2>
<p>OK, enough philosophizing. Let's talk about dynamically importing modules.
<p>First, let's look at how you normally import modules. The <code>import <var>module</var></code> syntax looks in the search path for the named module and imports it by name. You can even import multiple modules at once
this way, with a comma-separated list. You did this on the very first line of this chapter's script.
<div class=example><h3>Example 16.13. Importing multiple modules at once</h3><pre><code>
import sys, os, re, unittest <span>&#x2460;</span>
</pre><div class=calloutlist>
<ol>
<li>This imports four modules at once: <code>sys</code> (for system functions and access to the command line parameters), <code>os</code> (for operating system functions like directory listings), <code>re</code> (for regular expressions), and <code>unittest</code> (for unit testing).
<p>Now let's do the same thing, but with dynamic imports.
<div class=example><h3>Example 16.14. Importing modules dynamically</h3><pre class=screen>
<samp class=prompt>>>> </samp><kbd>sys = __import__('sys')</kbd>           <span>&#x2460;</span>
<samp class=prompt>>>> </samp><kbd>os = __import__('os')</kbd>
<samp class=prompt>>>> </samp><kbd>re = __import__('re')</kbd>
<samp class=prompt>>>> </samp><kbd>unittest = __import__('unittest')</kbd>
<samp class=prompt>>>> </samp><kbd>sys</kbd>             <span>&#x2461;</span>
<samp class=prompt>>>> </samp><kbd>&lt;module 'sys' (built-in)></kbd>
<samp class=prompt>>>> </samp><kbd>os</kbd>
<samp class=prompt>>>> </samp><kbd>&lt;module 'os' from '/usr/local/lib/python2.2/os.pyc'></kbd>
</pre><div class=calloutlist>
<ol>
<li>The built-in <code>__import__</code> function accomplishes the same goal as using the <code>import</code> statement, but it's an actual function, and it takes a string as an argument.
<li>The variable <var>sys</var> is now the <code>sys</code> module, just as if you had said <code>import sys</code>. The variable <var>os</var> is now the <code>os</code> module, and so forth.
<p>So <code>__import__</code> imports a module, but takes a string argument to do it. In this case the module you imported was just a hard-coded string,
but it could just as easily be a variable, or the result of a function call. And the variable that you assign the module
to doesn't need to match the module name, either. You could import a series of modules and assign them to a list.
<div class=example><h3>Example 16.15. Importing a list of modules dynamically</h3><pre class=screen>
<samp class=prompt>>>> </samp><kbd>moduleNames = ['sys', 'os', 're', 'unittest']</kbd> <span>&#x2460;</span>
<samp class=prompt>>>> </samp><kbd>moduleNames</kbd>
['sys', 'os', 're', 'unittest']
<samp class=prompt>>>> </samp><kbd>modules = map(__import__, moduleNames)</kbd>        <span>&#x2461;</span>
<samp class=prompt>>>> </samp><kbd>modules</kbd>   <span>&#x2462;</span>
<samp>[&lt;module 'sys' (built-in)>,
&lt;module 'os' from 'c:\Python22\lib\os.pyc'>,
&lt;module 're' from 'c:\Python22\lib\re.pyc'>,
&lt;module 'unittest' from 'c:\Python22\lib\unittest.pyc'>]</samp>
<samp class=prompt>>>> </samp><kbd>modules[0].version</kbd>          <span>&#x2463;</span>
'2.2.2 (#37, Nov 26 2002, 10:24:37) [MSC 32 bit (Intel)]'
<samp class=prompt>>>> </samp><kbd>import sys</kbd>
<samp class=prompt>>>> </samp><kbd>sys.version</kbd>
'2.2.2 (#37, Nov 26 2002, 10:24:37) [MSC 32 bit (Intel)]'
</pre><div class=calloutlist>
<ol>
<li><var>moduleNames</var> is just a list of strings. Nothing fancy, except that the strings happen to be names of modules that you could import, if
            you wanted to.
<li>Surprise, you wanted to import them, and you did, by mapping the <code>__import__</code> function onto the list. Remember, this takes each element of the list (<var>moduleNames</var>) and calls the function (<code>__import__</code>) over and over, once with each element of the list, builds a list of the return values, and returns the result.
<li>So now from a list of strings, you've created a list of actual modules. (Your paths may be different, depending on your operating
            system, where you installed Python, the phase of the moon, etc.)
<li>To drive home the point that these are real modules, let's look at some module attributes. Remember, <var>modules[0]</var> <em>is</em> the <code>sys</code> module, so <var>modules[0].version</var> <em>is</em> <var>sys.version</var>. All the other attributes and methods of these modules are also available. There's nothing magic about the <code>import</code> statement, and there's nothing magic about modules. Modules are objects. Everything is an object.
<p>Now you should be able to put this all together and figure out what most of this chapter's code sample is doing.
<h2 id="regression.alltogether">16.7. Putting it all together</h2>
<p>You've learned enough now to deconstruct the first seven lines of this chapter's code sample: reading a directory and importing
   selected modules within it.
<div class=example><h3>Example 16.16. The <code>regressionTest</code> function</h3><pre><code>
def regressionTest():
    path = os.path.abspath(os.path.dirname(sys.argv[0]))   
    files = os.listdir(path)             
    test = re.compile("test\.py$", re.IGNORECASE)          
    files = filter(test.search, files)   
    filenameToModuleName = lambda f: os.path.splitext(f)[0]
    moduleNames = map(filenameToModuleName, files)         
    modules = map(__import__, moduleNames)                 
load = unittest.defaultTestLoader.loadTestsFromModule  
return unittest.TestSuite(map(load, modules))          
</pre><p>Let's look at it line by line, interactively. Assume that the current directory is <code>c:\diveintopython3\py</code>, which contains the examples that come with this book, including this chapter's script. As you saw in <a href="#regression.path" title="16.2. Finding the path">Section 16.2, &#8220;Finding the path&#8221;</a>, the script directory will end up in the <var>path</var> variable, so let's start hard-code that and go from there.
<div class=example><h3>Example 16.17. Step 1: Get all the files</h3><pre class=screen>
<samp class=prompt>>>> </samp><kbd>import sys, os, re, unittest</kbd>
<samp class=prompt>>>> </samp><kbd>path = r'c:\diveintopython3\py'</kbd>
<samp class=prompt>>>> </samp><kbd>files = os.listdir(path)             </kbd>
<samp class=prompt>>>> </samp><kbd>files</kbd> <span>&#x2460;</span>
<samp>['BaseHTMLProcessor.py', 'LICENSE.txt', 'apihelper.py', 'apihelpertest.py',
'argecho.py', 'autosize.py', 'builddialectexamples.py', 'dialect.py',
'fileinfo.py', 'fullpath.py', 'kgptest.py', 'makerealworddoc.py',
'odbchelper.py', 'odbchelpertest.py', 'parsephone.py', 'piglatin.py',
'plural.py', 'pluraltest.py', 'pyfontify.py', 'regression.py', 'roman.py', 'romantest.py',
'uncurly.py', 'unicode2koi8r.py', 'urllister.py', 'kgp', 'plural', 'roman',
'colorize.py']</span>
</pre><div class=calloutlist>
<ol>
<li><var>files</var> is a list of all the files and directories in the script's directory. (If you've been running some of the examples already,
            you may also see some <code>.pyc</code> files in there as well.)
<div class=example><h3>Example 16.18. Step 2: Filter to find the files you care about</h3><pre class=screen>
<samp class=prompt>>>> </samp><kbd>test = re.compile("test\.py$", re.IGNORECASE)</kbd>           <span>&#x2460;</span>
<samp class=prompt>>>> </samp><kbd>files = filter(test.search, files)</kbd>    <span>&#x2461;</span>
<samp class=prompt>>>> </samp><kbd>files</kbd>               <span>&#x2462;</span>
['apihelpertest.py', 'kgptest.py', 'odbchelpertest.py', 'pluraltest.py', 'romantest.py']
</pre><div class=calloutlist>
<ol>
<li>This regular expression will match any string that ends with <code>test.py</code>. Note that you need to escape the period, since a period in a regular expression usually means &#8220;match any single character&#8221;, but you actually want to match a literal period instead.
<li>The compiled regular expression acts like a function, so you can use it to filter the large list of files and directories,
            to find the ones that match the regular expression.
<li>And you're left with the list of unit testing scripts, because they were the only ones named <code>SOMETHINGtest.py</code>.
<div class=example><h3>Example 16.19. Step 3: Map filenames to module names</h3><pre class=screen>
<samp class=prompt>>>> </samp><kbd>filenameToModuleName = lambda f: os.path.splitext(f)[0]</kbd> <span>&#x2460;</span>
<samp class=prompt>>>> </samp><kbd>filenameToModuleName('romantest.py')</kbd>  <span>&#x2461;</span>
'romantest'
<samp class=prompt>>>> </samp><kbd>filenameToModuleName('odchelpertest.py')</kbd>
'odbchelpertest'
<samp class=prompt>>>> </samp><kbd>moduleNames = map(filenameToModuleName, files)</kbd>          <span>&#x2462;</span>
<samp class=prompt>>>> </samp><kbd>moduleNames</kbd>         <span>&#x2463;</span>
['apihelpertest', 'kgptest', 'odbchelpertest', 'pluraltest', 'romantest']
</pre><div class=calloutlist>
<ol>
<li>As you saw in <a href="#apihelper.lambda" title="4.7. Using lambda Functions">Section 4.7, &#8220;Using lambda Functions&#8221;</a>, <code>lambda</code> is a quick-and-dirty way of creating an inline, one-line function. This one takes a filename with an extension and returns
            just the filename part, using the standard library function <code>os.path.splitext</code> that you saw in <a href="#splittingpathnames.example" title="Example 6.17. Splitting Pathnames">Example 6.17, &#8220;Splitting Pathnames&#8221;</a>.
<li><var>filenameToModuleName</var> is a function. There's nothing magic about <code>lambda</code> functions as opposed to regular functions that you define with a <code>def</code> statement. You can call the <var>filenameToModuleName</var> function like any other, and it does just what you wanted it to do: strips the file extension off of its argument.
<li>Now you can apply this function to each file in the list of unit test files, using <code>map</code>.
<li>And the result is just what you wanted: a list of modules, as strings.
<div class=example><h3>Example 16.20. Step 4: Mapping module names to modules</h3><pre class=screen>
<samp class=prompt>>>> </samp><kbd>modules = map(__import__, moduleNames)</kbd><span>&#x2460;</span>
<samp class=prompt>>>> </samp><kbd>modules</kbd>             <span>&#x2461;</span>
<samp>[&lt;module 'apihelpertest' from 'apihelpertest.py'>,
&lt;module 'kgptest' from 'kgptest.py'>,
&lt;module 'odbchelpertest' from 'odbchelpertest.py'>,
&lt;module 'pluraltest' from 'pluraltest.py'>,
&lt;module 'romantest' from 'romantest.py'>]</samp>
<samp class=prompt>>>> </samp><kbd>modules[-1]</kbd>         <span>&#x2462;</span>
&lt;module 'romantest' from 'romantest.py'>
</pre><div class=calloutlist>
<ol>
<li>As you saw in <a href="#regression.import" title="16.6. Dynamically importing modules">Section 16.6, &#8220;Dynamically importing modules&#8221;</a>, you can use a combination of <code>map</code> and <code>__import__</code> to map a list of module names (as strings) into actual modules (which you can call or access like any other module).
            
<li><var>modules</var> is now a list of modules, fully accessible like any other module.
<li>The last module in the list <em>is</em> the <code>romantest</code> module, just as if you had said <code>import romantest</code>.
<div class=example><h3>Example 16.21. Step 5: Loading the modules into a test suite</h3><pre class=screen>
<samp class=prompt>>>> </samp><kbd>load = unittest.defaultTestLoader.loadTestsFromModule  </kbd>
<samp class=prompt>>>> </samp><kbd>map(load, modules)</kbd>   <span>&#x2460;</span>
<samp>[&lt;unittest.TestSuite tests=[
  &lt;unittest.TestSuite tests=[&lt;apihelpertest.BadInput testMethod=testNoObject>]>,
  &lt;unittest.TestSuite tests=[&lt;apihelpertest.KnownValues testMethod=testApiHelper>]>,
  &lt;unittest.TestSuite tests=[
    &lt;apihelpertest.ParamChecks testMethod=testCollapse>, 
    &lt;apihelpertest.ParamChecks testMethod=testSpacing>]>, 
    ...
  ]
]</samp>
<samp class=prompt>>>> </samp><kbd>unittest.TestSuite(map(load, modules))</kbd> <span>&#x2461;</span>
</pre><div class=calloutlist>
<ol>
<li>These are real module objects. Not only can you access them like any other module, instantiate classes and call functions,
            you can also introspect into the module to figure out which classes and functions it has in the first place. That's what
            the <code>loadTestsFromModule</code> method does: it introspects into each module and returns a <code>unittest.TestSuite</code> object for each module. Each <code>TestSuite</code> object actually contains a list of <code>TestSuite</code> objects, one for each <code>TestCase</code> class in your module, and each of those <code>TestSuite</code> objects contains a list of tests, one for each test method in your module.
<li>Finally, you wrap the list of <code>TestSuite</code> objects into one big test suite. The <code>unittest</code> module has no problem traversing this tree of nested test suites within test suites; eventually it gets down to an individual
            test method and executes it, verifies that it passes or fails, and moves on to the next one.
<p>This introspection process is what the <code>unittest</code> module usually does for us. Remember that magic-looking <code>unittest.main()</code> function that our individual test modules called to kick the whole thing off?  <code>unittest.main()</code> actually creates an instance of <code>unittest.TestProgram</code>, which in turn creates an instance of a <code>unittest.defaultTestLoader</code> and loads it up with the module that called it. (How does it get a reference to the module that called it if you don't give
it one?  By using the equally-magic <code>__import__('__main__')</code> command, which dynamically imports the currently-running module. I could write a book on all the tricks and techniques used
in the <code>unittest</code> module, but then I'd never finish this one.)
<div class=example><h3>Example 16.22. Step 6: Telling <code>unittest</code> to use your test suite</h3><pre><code>
if __name__ == "__main__": 
    unittest.main(defaultTest="regressionTest") <span>&#x2460;</span>
</pre><div class=calloutlist>
<ol>
<li>Instead of letting the <code>unittest</code> module do all its magic for us, you've done most of it yourself. You've created a function (<code>regressionTest</code>) that imports the modules yourself, calls <code>unittest.defaultTestLoader</code> yourself, and wraps it all up in a test suite. Now all you need to do is tell <code>unittest</code> that, instead of looking for tests and building a test suite in the usual way, it should just call the <code>regressionTest</code> function, which returns a ready-to-use <code>TestSuite</code>.
<h2 id="regression.summary">16.8. Summary</h2>
<p>The <code>regression.py</code> program and its output should now make perfect sense.
<p>You should now feel comfortable doing all of these things:
<div class=itemizedlist>
<ul>
<li>Manipulating <a href="#regression.path" title="16.2. Finding the path">path information</a> from the command line.

<li>Filtering lists <a href="#regression.filter" title="16.3. Filtering lists revisited">using <code>filter</code></a> instead of list comprehensions.

<li>Mapping lists <a href="#regression.map" title="16.4. Mapping lists revisited">using <code>map</code></a> instead of list comprehensions.

<li>Dynamically <a href="#regression.import" title="16.6. Dynamically importing modules">importing modules</a>.

</ul>
<div class=footnotes><br><hr width="100" align="left">
<div class=footnote>
<p><sup>[<a name="ftn.d0e35697" href="#d0e35697">7</a>] </sup>Technically, the second argument to <code>filter</code> can be any sequence, including lists, tuples, and custom classes that act like lists by defining the <code>__getitem__</code> special method. If possible, <code>filter</code> will return the same datatype as you give it, so filtering a list returns a list, but filtering a tuple returns a tuple.
<div class=footnote>
<p><sup>[<a name="ftn.d0e36079" href="#d0e36079">8</a>] </sup>Again, I should point out that <code>map</code> can take a list, a tuple, or any object that acts like a sequence. See previous footnote about <code>filter</code>.
<div class=chapter>
<h2 id="plural">Chapter 17. Dynamic functions</h2>
<h2 id="plural.divein">17.1. Diving in</h2>
<p>I want to talk about plural nouns. Also, functions that return other functions, advanced regular expressions, and generators.
   Generators are new in Python 2.3. But first, let's talk about how to make plural nouns.
<p>If you haven't read <a href="#re" title="Chapter 7. Regular Expressions">Chapter 7, <i>Regular Expressions</i></a>, now would be a good time. This chapter assumes you understand the basics of regular expressions, and quickly descends into
more advanced uses.
<p>English is a schizophrenic language that borrows from a lot of other languages, and the rules for making singular nouns into
plural nouns are varied and complex. There are rules, and then there are exceptions to those rules, and then there are exceptions
to the exceptions.
<p>If you grew up in an English-speaking country or learned English in a formal school setting, you're probably familiar with
the basic rules:
<div class=orderedlist>
<ol>
<li>If a word ends in S, X, or Z, add ES. &#8220;Bass&#8221; becomes &#8220;basses&#8221;, &#8220;fax&#8221; becomes &#8220;faxes&#8221;, and &#8220;waltz&#8221; becomes &#8220;waltzes&#8221;.

<li>If a word ends in a noisy H, add ES; if it ends in a silent H, just add S. What's a noisy H?  One that gets combined with
      other letters to make a sound that you can hear. So &#8220;coach&#8221; becomes &#8220;coaches&#8221; and &#8220;rash&#8221; becomes &#8220;rashes&#8221;, because you can hear the CH and SH sounds when you say them. But &#8220;cheetah&#8221; becomes &#8220;cheetahs&#8221;, because the H is silent.

<li>If a word ends in Y that sounds like I, change the Y to IES; if the Y is combined with a vowel to sound like something else,
      just add S. So &#8220;vacancy&#8221; becomes &#8220;vacancies&#8221;, but &#8220;day&#8221; becomes &#8220;days&#8221;.

<li>If all else fails, just add S and hope for the best.
</ol>
<p>(I know, there are a lot of exceptions. &#8220;Man&#8221; becomes &#8220;men&#8221; and &#8220;woman&#8221; becomes &#8220;women&#8221;, but &#8220;human&#8221; becomes &#8220;humans&#8221;. &#8220;Mouse&#8221; becomes &#8220;mice&#8221; and &#8220;louse&#8221; becomes &#8220;lice&#8221;, but &#8220;house&#8221; becomes &#8220;houses&#8221;. &#8220;Knife&#8221; becomes &#8220;knives&#8221; and &#8220;wife&#8221; becomes &#8220;wives&#8221;, but &#8220;lowlife&#8221; becomes &#8220;lowlifes&#8221;. And don't even get me started on words that are their own plural, like &#8220;sheep&#8221;, &#8220;deer&#8221;, and &#8220;haiku&#8221;.)
<p>Other languages are, of course, completely different.
<p>Let's design a module that pluralizes nouns. Start with just English nouns, and just these four rules, but keep in mind that
you'll inevitably need to add more rules, and you may eventually need to add more languages.
<h2 id="plural.stage1">17.2. <code>plural.py</code>, stage 1</h2>
<p>So you're looking at words, which at least in English are strings of characters. And you have rules that say you need to
   find different combinations of characters, and then do different things to them. This sounds like a job for regular expressions.
<div class=example><h3>Example 17.1. <code>plural1.py</code></h3><pre><code>
import re

def plural(noun):          
    if re.search('[sxz]$', noun):             <span>&#x2460;</span>
        return re.sub('$', 'es', noun)        <span>&#x2461;</span>
    elif re.search('[^aeioudgkprt]h$', noun):
        return re.sub('$', 'es', noun)       
    elif re.search('[^aeiou]y$', noun):      
        return re.sub('y$', 'ies', noun)     
    else:
        return noun + 's'  
</pre><div class=calloutlist>
<ol>
<li>OK, this is a regular expression, but it uses a syntax you didn't see in <a href="#re" title="Chapter 7. Regular Expressions">Chapter 7, <i>Regular Expressions</i></a>. The square brackets mean &#8220;match exactly one of these characters&#8221;. So <code>[sxz]</code> means &#8220;<code>s</code>, or <code>x</code>, or <code>z</code>&#8221;, but only one of them. The <code>$</code> should be familiar; it matches the end of string. So you're checking to see if <var>noun</var> ends with <code>s</code>, <code>x</code>, or <code>z</code>.
<li>This <code>re.sub</code> function performs regular expression-based string substitutions. Let's look at it in more detail.
<div class=example><h3>Example 17.2. Introducing <code>re.sub</code></h3><pre class=screen>
<samp class=prompt>>>> </samp><kbd>import re</kbd>
<samp class=prompt>>>> </samp><kbd>re.search('[abc]', 'Mark')</kbd>   <span>&#x2460;</span>
&lt;_sre.SRE_Match object at 0x001C1FA8>
<samp class=prompt>>>> </samp><kbd>re.sub('[abc]', 'o', 'Mark')</kbd> <span>&#x2461;</span>
'Mork'
<samp class=prompt>>>> </samp><kbd>re.sub('[abc]', 'o', 'rock')</kbd> <span>&#x2462;</span>
'rook'
<samp class=prompt>>>> </samp><kbd>re.sub('[abc]', 'o', 'caps')</kbd> <span>&#x2463;</span>
'oops'
</pre><div class=calloutlist>
<ol>
<li>Does the string <code>Mark</code> contain <code>a</code>, <code>b</code>, or <code>c</code>?  Yes, it contains <code>a</code>.
<li>OK, now find <code>a</code>, <code>b</code>, or <code>c</code>, and replace it with <code>o</code>. <code>Mark</code> becomes <code>Mork</code>.
<li>The same function turns <code>rock</code> into <code>rook</code>.
<li>You might think this would turn <code>caps</code> into <code>oaps</code>, but it doesn't. <code>re.sub</code> replaces <em>all</em> of the matches, not just the first one. So this regular expression turns <code>caps</code> into <code>oops</code>, because both the <code>c</code> and the <code>a</code> get turned into <code>o</code>.
<div class=example><h3>Example 17.3. Back to <code>plural1.py</code></h3><pre><code>
import re

def plural(noun):          
    if re.search('[sxz]$', noun):            
        return re.sub('$', 'es', noun)        <span>&#x2460;</span>
    elif re.search('[^aeioudgkprt]h$', noun): <span>&#x2461;</span>
        return re.sub('$', 'es', noun)        <span>&#x2462;</span>
    elif re.search('[^aeiou]y$', noun):      
        return re.sub('y$', 'ies', noun)     
    else:
        return noun + 's'  
</pre><div class=calloutlist>
<ol>
<li>Back to the <code>plural</code> function. What are you doing?  You're replacing the end of string with <code>es</code>. In other words, adding <code>es</code> to the string. You could accomplish the same thing with string concatenation, for example <code>noun + 'es'</code>, but I'm using regular expressions for everything, for consistency, for reasons that will become clear later in the chapter.
<li>Look closely, this is another new variation. The <code>^</code> as the first character inside the square brackets means something special: negation. <code>[^abc]</code> means &#8220;any single character <em>except</em> <code>a</code>, <code>b</code>, or <code>c</code>&#8221;. So <code>[^aeioudgkprt]</code> means any character except <code>a</code>, <code>e</code>, <code>i</code>, <code>o</code>, <code>u</code>, <code>d</code>, <code>g</code>, <code>k</code>, <code>p</code>, <code>r</code>, or <code>t</code>. Then that character needs to be followed by <code>h</code>, followed by end of string. You're looking for words that end in H where the H can be heard.
<li>Same pattern here: match words that end in Y, where the character before the Y is <em>not</em> <code>a</code>, <code>e</code>, <code>i</code>, <code>o</code>, or <code>u</code>. You're looking for words that end in Y that sounds like I.
<div class=example><h3>Example 17.4. More on negation regular expressions</h3><pre class=screen>
<samp class=prompt>>>> </samp><kbd>import re</kbd>
<samp class=prompt>>>> </samp><kbd>re.search('[^aeiou]y$', 'vacancy')</kbd> <span>&#x2460;</span>
&lt;_sre.SRE_Match object at 0x001C1FA8>
<samp class=prompt>>>> </samp><kbd>re.search('[^aeiou]y$', 'boy')</kbd>     <span>&#x2461;</span>
<samp class=prompt>>>> </samp><kbd></kbd>
<samp class=prompt>>>> </samp><kbd>re.search('[^aeiou]y$', 'day')</kbd>
<samp class=prompt>>>> </samp><kbd></kbd>
<samp class=prompt>>>> </samp><kbd>re.search('[^aeiou]y$', 'pita')</kbd>    <span>&#x2462;</span>
<samp class=prompt>>>> </samp><kbd></kbd>
</pre><div class=calloutlist>
<ol>
<li><code>vacancy</code> matches this regular expression, because it ends in <code>cy</code>, and <code>c</code> is not <code>a</code>, <code>e</code>, <code>i</code>, <code>o</code>, or <code>u</code>.
<li><code>boy</code> does not match, because it ends in <code>oy</code>, and you specifically said that the character before the <code>y</code> could not be <code>o</code>. <code>day</code> does not match, because it ends in <code>ay</code>.
<li><code>pita</code> does not match, because it does not end in <code>y</code>.
<div class=example><h3>Example 17.5. More on <code>re.sub</code></h3><pre class=screen>
<samp class=prompt>>>> </samp><kbd>re.sub('y$', 'ies', 'vacancy')</kbd>              <span>&#x2460;</span>
'vacancies'
<samp class=prompt>>>> </samp><kbd>re.sub('y$', 'ies', 'agency')</kbd>
'agencies'
<samp class=prompt>>>> </samp><kbd>re.sub('([^aeiou])y$', r'\1ies', 'vacancy')</kbd> <span>&#x2461;</span>
'vacancies'
</pre><div class=calloutlist>
<ol>
<li>This regular expression turns <code>vacancy</code> into <code>vacancies</code> and <code>agency</code> into <code>agencies</code>, which is what you wanted. Note that it would also turn <code>boy</code> into <code>boies</code>, but that will never happen in the function because you did that <code>re.search</code> first to find out whether you should do this <code>re.sub</code>.
<li>Just in passing, I want to point out that it is possible to combine these two regular expressions (one to find out if the
            rule applies, and another to actually apply it) into a single regular expression. Here's what that would look like. Most
            of it should look familiar: you're using a remembered group, which you learned in <a href="#re.phone" title="7.6. Case study: Parsing Phone Numbers">Section 7.6, &#8220;Case study: Parsing Phone Numbers&#8221;</a>, to remember the character before the <code>y</code>. Then in the substitution string, you use a new syntax, <code>\1</code>, which means &#8220;hey, that first group you remembered?  put it here&#8221;. In this case, you remember the <code>c</code> before the <code>y</code>, and then when you do the substitution, you substitute <code>c</code> in place of <code>c</code>, and <code>ies</code> in place of <code>y</code>. (If you have more than one remembered group, you can use <code>\2</code> and <code>\3</code> and so on.)
<p>Regular expression substitutions are extremely powerful, and the <code>\1</code> syntax makes them even more powerful. But combining the entire operation into one regular expression is also much harder
to read, and it doesn't directly map to the way you first described the pluralizing rules. You originally laid out rules
like &#8220;if the word ends in S, X, or Z, then add ES&#8221;. And if you look at this function, you have two lines of code that say &#8220;if the word ends in S, X, or Z, then add ES&#8221;. It doesn't get much more direct than that.
<h2 id="plural.stage2">17.3. <code>plural.py</code>, stage 2</h2>
<p>Now you're going to add a level of abstraction. You started by defining a list of rules: if this, then do that, otherwise
   go to the next rule. Let's temporarily complicate part of the program so you can simplify another part.
<div class=example><h3>Example 17.6. <code>plural2.py</code></h3><pre><code>
import re

def match_sxz(noun):        
    return re.search('[sxz]$', noun)          

def apply_sxz(noun):        
    return re.sub('$', 'es', noun)            

def match_h(noun):          
    return re.search('[^aeioudgkprt]h$', noun)

def apply_h(noun):          
    return re.sub('$', 'es', noun)            

def match_y(noun):          
    return re.search('[^aeiou]y$', noun)      
        
def apply_y(noun):          
    return re.sub('y$', 'ies', noun)          

def match_default(noun):    
    return 1                
        
def apply_default(noun):    
    return noun + 's'       

rules = ((match_sxz, apply_sxz),
         (match_h, apply_h),
         (match_y, apply_y),
         (match_default, apply_default)
         ) <span>&#x2460;</span>

def plural(noun):           
    for matchesRule, applyRule in rules:       <span>&#x2461;</span>
        if matchesRule(noun):<span>&#x2462;</span>
            return applyRule(noun)             <span>&#x2463;</span>
</pre><div class=calloutlist>
<ol>
<li>This version looks more complicated (it's certainly longer), but it does exactly the same thing: try to match four different
            rules, in order, and apply the appropriate regular expression when a match is found. The difference is that each individual
            match and apply rule is defined in its own function, and the functions are then listed in this <var>rules</var> variable, which is a tuple of tuples.
<li>Using a <code>for</code> loop, you can pull out the match and apply rules two at a time (one match, one apply) from the <var>rules</var> tuple. On the first iteration of the <code>for</code> loop, <var>matchesRule</var> will get <code>match_sxz</code>, and <var>applyRule</var> will get <code>apply_sxz</code>. On the second iteration (assuming you get that far), <var>matchesRule</var> will be assigned <code>match_h</code>, and <var>applyRule</var> will be assigned <code>apply_h</code>.
<li>Remember that <a href="#odbchelper.objects" title="2.4. Everything Is an Object">everything in Python is an object</a>, including functions. <var>rules</var> contains actual functions; not names of functions, but actual functions. When they get assigned in the <code>for</code> loop, then <var>matchesRule</var> and <var>applyRule</var> are actual functions that you can call. So on the first iteration of the <code>for</code> loop, this is equivalent to calling <code>matches_sxz(noun)</code>.
<li>On the first iteration of the <code>for</code> loop, this is equivalent to calling <code>apply_sxz(noun)</code>, and so forth.
<p>If this additional level of abstraction is confusing, try unrolling the function to see the equivalence. This <code>for</code> loop is equivalent to the following:
<div class=example><h3>Example 17.7. Unrolling the <code>plural</code> function</h3><pre><code>
def plural(noun):
    if match_sxz(noun):
        return apply_sxz(noun)
    if match_h(noun):
        return apply_h(noun)
    if match_y(noun):
        return apply_y(noun)
    if match_default(noun):
        return apply_default(noun)
</pre><p>The benefit here is that that <code>plural</code> function is now simplified. It takes a list of rules, defined elsewhere, and iterates through them in a generic fashion.
Get a match rule; does it match?  Then call the apply rule. The rules could be defined anywhere, in any way. The <code>plural</code> function doesn't care.
<p>Now, was adding this level of abstraction worth it?  Well, not yet. Let's consider what it would take to add a new rule to
the function. Well, in the previous example, it would require adding an <code>if</code> statement to the <code>plural</code> function. In this example, it would require adding two functions, <code>match_foo</code> and <code>apply_foo</code>, and then updating the <var>rules</var> list to specify where in the order the new match and apply functions should be called relative to the other rules.
<p>This is really just a stepping stone to the next section. Let's move on.
<h2 id="plural.stage3">17.4. <code>plural.py</code>, stage 3</h2>
<p>Defining separate named functions for each match and apply rule isn't really necessary. You never call them directly; you
   define them in the <var>rules</var> list and call them through there. Let's streamline the rules definition by anonymizing those functions.
<div class=example><h3>Example 17.8. <code>plural3.py</code></h3><pre><code>
import re

rules = \
  (
    (
     lambda word: re.search('[sxz]$', word),
     lambda word: re.sub('$', 'es', word)
    ),
    (
     lambda word: re.search('[^aeioudgkprt]h$', word),
     lambda word: re.sub('$', 'es', word)
    ),
    (
     lambda word: re.search('[^aeiou]y$', word),
     lambda word: re.sub('y$', 'ies', word)
    ),
    (
     lambda word: re.search('$', word),
     lambda word: re.sub('$', 's', word)
    )
   )       <span>&#x2460;</span>

def plural(noun):           
    for matchesRule, applyRule in rules:       <span>&#x2461;</span>
        if matchesRule(noun):                 
            return applyRule(noun)            
</pre><div class=calloutlist>
<ol>
<li>This is the same set of rules as you defined in stage 2. The only difference is that instead of defining named functions
            like <code>match_sxz</code> and <code>apply_sxz</code>, you have &#8220;inlined&#8221; those function definitions directly into the <var>rules</var> list itself, using <a href="#apihelper.lambda" title="4.7. Using lambda Functions">lambda functions</a>.
<li>Note that the <code>plural</code> function hasn't changed at all. It iterates through a set of rule functions, checks the first rule, and if it returns a
            true value, calls the second rule and returns the value. Same as above, word for word. The only difference is that the rule
            functions were defined inline, anonymously, using lambda functions. But the <code>plural</code> function doesn't care how they were defined; it just gets a list of rules and blindly works through them.
<p>Now to add a new rule, all you need to do is define the functions directly in the <var>rules</var> list itself: one match rule, and one apply rule. But defining the rule functions inline like this makes it very clear that
you have some unnecessary duplication here. You have four pairs of functions, and they all follow the same pattern. The
match function is a single call to <code>re.search</code>, and the apply function is a single call to <code>re.sub</code>. Let's factor out these similarities.
<h2 id="plural.stage4">17.5. <code>plural.py</code>, stage 4</h2>
<p>Let's factor out the duplication in the code so that defining new rules can be easier.
<div class=example><h3 id="plural.stage4.example.1">Example 17.9. <code>plural4.py</code></h3><pre><code>
import re

def buildMatchAndApplyFunctions((pattern, search, replace)):  
    matchFunction = lambda word: re.search(pattern, word)      <span>&#x2460;</span>
    applyFunction = lambda word: re.sub(search, replace, word) <span>&#x2461;</span>
    return (matchFunction, applyFunction)    <span>&#x2462;</span>
</pre><div class=calloutlist>
<ol>
<li><code>buildMatchAndApplyFunctions</code> is a function that builds other functions dynamically. It takes <var>pattern</var>, <var>search</var> and <var>replace</var> (actually it takes a tuple, but more on that in a minute), and you can build the match function using the <code>lambda</code> syntax to be a function that takes one parameter (<var>word</var>) and calls <code>re.search</code> with the <var>pattern</var> that was passed to the <code>buildMatchAndApplyFunctions</code> function, and the <var>word</var> that was passed to the match function you're building. Whoa.
<li>Building the apply function works the same way. The apply function is a function that takes one parameter, and calls <code>re.sub</code> with the <var>search</var> and <var>replace</var> parameters that were passed to the <code>buildMatchAndApplyFunctions</code> function, and the <var>word</var> that was passed to the apply function you're building. This technique of using the values of outside parameters within a
            dynamic function is called <em>closures</em>. You're essentially defining constants within the apply function you're building: it takes one parameter (<var>word</var>), but it then acts on that plus two other values (<var>search</var> and <var>replace</var>) which were set when you defined the apply function.
<li>Finally, the <code>buildMatchAndApplyFunctions</code> function returns a tuple of two values: the two functions you just created. The constants you defined within those functions
            (<var>pattern</var> within <var>matchFunction</var>, and <var>search</var> and <var>replace</var> within <var>applyFunction</var>) stay with those functions, even after you return from <code>buildMatchAndApplyFunctions</code>. That's insanely cool.
<p>If this is incredibly confusing (and it should be, this is weird stuff), it may become clearer when you see how to use it.
<div class=example><h3>Example 17.10. <code>plural4.py</code> continued</h3><pre><code>
patterns = \
  (
    ('[sxz]$', '$', 'es'),
    ('[^aeioudgkprt]h$', '$', 'es'),
    ('(qu|[^aeiou])y$', 'y$', 'ies'),
    ('$', '$', 's')
  )             <span>&#x2460;</span>
rules = map(buildMatchAndApplyFunctions, patterns)  <span>&#x2461;</span>
</pre><div class=calloutlist>
<ol>
<li>Our pluralization rules are now defined as a series of strings (not functions). The first string is the regular expression
            that you would use in <code>re.search</code> to see if this rule matches; the second and third are the search and replace expressions you would use in <code>re.sub</code> to actually apply the rule to turn a noun into its plural.
<li>This line is magic. It takes the list of strings in <var>patterns</var> and turns them into a list of functions. How?  By mapping the strings to the <code>buildMatchAndApplyFunctions</code> function, which just happens to take three strings as parameters and return a tuple of two functions. This means that <var>rules</var> ends up being exactly the same as the previous example: a list of tuples, where each tuple is a pair of functions, where
            the first function is the match function that calls <code>re.search</code>, and the second function is the apply function that calls <code>re.sub</code>.
<p>I swear I am not making this up: <var>rules</var> ends up with exactly the same list of functions as the previous example. Unroll the <var>rules</var> definition, and you'll get this:
<div class=example><h3>Example 17.11. Unrolling the rules definition</h3><pre><code>
rules = \
  (
    (
     lambda word: re.search('[sxz]$', word),
     lambda word: re.sub('$', 'es', word)
    ),
    (
     lambda word: re.search('[^aeioudgkprt]h$', word),
     lambda word: re.sub('$', 'es', word)
    ),
    (
     lambda word: re.search('[^aeiou]y$', word),
     lambda word: re.sub('y$', 'ies', word)
    ),
    (
     lambda word: re.search('$', word),
     lambda word: re.sub('$', 's', word)
    )
   )      
</pre><div class=example><h3 id="plural.finishing.up">Example 17.12. <code>plural4.py</code>, finishing up</h3><pre><code>
def plural(noun):                
    for matchesRule, applyRule in rules:            <span>&#x2460;</span>
        if matchesRule(noun):    
            return applyRule(noun)                 
</pre><div class=calloutlist>
<ol>
<li>Since the <var>rules</var> list is the same as the previous example, it should come as no surprise that the <code>plural</code> function hasn't changed. Remember, it's completely generic; it takes a list of rule functions and calls them in order. 
            It doesn't care how the rules are defined. In <a href="#plural.stage2" title="17.3. plural.py, stage 2">stage 2</a>, they were defined as seperate named functions. In <a href="#plural.stage3" title="17.4. plural.py, stage 3">stage 3</a>, they were defined as anonymous <code>lambda</code> functions. Now in stage 4, they are built dynamically by mapping the <code>buildMatchAndApplyFunctions</code> function onto a list of raw strings. Doesn't matter; the <code>plural</code> function still works the same way.
<p>Just in case that wasn't mind-blowing enough, I must confess that there was a subtlety in the definition of <code>buildMatchAndApplyFunctions</code> that I skipped over. Let's go back and take another look.
<div class=example><h3>Example 17.13. Another look at <code>buildMatchAndApplyFunctions</code></h3><pre><code>
def buildMatchAndApplyFunctions((pattern, search, replace)):   <span>&#x2460;</span>
</pre><div class=calloutlist>
<ol>
<li>Notice the double parentheses?  This function doesn't actually take three parameters; it actually takes one parameter, a tuple
            of three elements. But the tuple is expanded when the function is called, and the three elements of the tuple are each assigned
            to different variables: <var>pattern</var>, <var>search</var>, and <var>replace</var>. Confused yet?  Let's see it in action.
<div class=example><h3>Example 17.14. Expanding tuples when calling functions</h3><pre class=screen>
<samp class=prompt>>>> </samp><kbd>def foo((a, b, c)):</kbd>
<samp class=prompt>...    </samp>print c
<samp class=prompt>...    </samp>print b
<samp class=prompt>...    </samp>print a
<samp class=prompt>>>> </samp><kbd>parameters = ('apple', 'bear', 'catnap')</kbd>
<samp class=prompt>>>> </samp><kbd>foo(parameters)</kbd> <span>&#x2460;</span>
catnap
bear
apple
</pre><div class=calloutlist>
<ol>
<li>The proper way to call the function <code>foo</code> is with a tuple of three elements. When the function is called, the elements are assigned to different local variables within
<code>foo</code>.
<p>Now let's go back and see why this auto-tuple-expansion trick was necessary. <var>patterns</var> was a list of tuples, and each tuple had three elements. When you called <code>map(buildMatchAndApplyFunctions, patterns)</code>, that means that <code>buildMatchAndApplyFunctions</code> is <em>not</em> getting called with three parameters. Using <code>map</code> to map a single list onto a function always calls the function with a single parameter: each element of the list. In the
   case of <var>patterns</var>, each element of the list is a tuple, so <code>buildMatchAndApplyFunctions</code> always gets called with the tuple, and you use the auto-tuple-expansion trick in the definition of <code>buildMatchAndApplyFunctions</code> to assign the elements of that tuple to named variables that you can work with.
<h2 id="plural.stage5">17.6. <code>plural.py</code>, stage 5</h2>
<p>You've factored out all the duplicate code and added enough abstractions so that the pluralization rules are defined in a
   list of strings. The next logical step is to take these strings and put them in a separate file, where they can be maintained
   separately from the code that uses them.
<p>First, let's create a text file that contains the rules you want. No fancy data structures, just space- (or tab-)delimited
strings in three columns. You'll call it <code>rules.en</code>; &#8220;en&#8221; stands for English. These are the rules for pluralizing English nouns. You could add other rule files for other languages
later.
<div class=example><h3>Example 17.15. <code>rules.en</code></h3><pre><code>
[sxz]$$               es
[^aeioudgkprt]h$        $               es
[^aeiou]y$              y$              ies
$     $               s
</pre><p>Now let's see how you can use this rules file.
<div class=example><h3>Example 17.16. <code>plural5.py</code></h3><pre><code>
import re
import string               

def buildRule((pattern, search, replace)):    
    return lambda word: re.search(pattern, word) and re.sub(search, replace, word) <span>&#x2460;</span>

def plural(noun, language='en'):           <span>&#x2461;</span>
    lines = file('rules.%s' % language).readlines()          <span>&#x2462;</span>
    patterns = map(string.split, lines)    <span>&#x2463;</span>
    rules = map(buildRule, patterns)       <span>&#x2464;</span>
    for rule in rules:  
        result = rule(noun)                <span>&#x2465;</span>
        if result: return result          
</pre><div class=calloutlist>
<ol>
<li>You're still using the closures technique here (building a function dynamically that uses variables defined outside the function),
            but now you've combined the separate match and apply functions into one. (The reason for this change will become clear in
            the next section.)  This will let you accomplish the same thing as having two functions, but you'll need to call it differently,
            as you'll see in a minute.
<li>Our <code>plural</code> function now takes an optional second parameter, <var>language</var>, which defaults to <code>en</code>.
<li>You use the <var>language</var> parameter to construct a filename, then open the file and read the contents into a list. If <var>language</var> is <code>en</code>, then you'll open the <code>rules.en</code> file, read the entire thing, break it up by carriage returns, and return a list. Each line of the file will be one element
            in the list.
<li>As you saw, each line in the file really has three values, but they're separated by whitespace (tabs or spaces, it makes no
            difference). Mapping the <code>string.split</code> function onto this list will create a new list where each element is a tuple of three strings. So a line like <code>[sxz]$ $ es</code> will be broken up into the tuple <code>('[sxz]$', '$', 'es')</code>. This means that <var>patterns</var> will end up as a list of tuples, just like you hard-coded it in <a href="#plural.stage4" title="17.5. plural.py, stage 4">stage 4</a>.
<li>If <var>patterns</var> is a list of tuples, then <var>rules</var> will be a list of the functions created dynamically by each call to <code>buildRule</code>. Calling <code>buildRule(('[sxz]$', '$', 'es'))</code> returns a function that takes a single parameter, <var>word</var>. When this returned function is called, it will execute <code>re.search('[sxz]$', word) and re.sub('$', 'es', word)</code>.
<li>Because you're now building a combined match-and-apply function, you need to call it differently. Just call the function,
            and if it returns something, then that's the plural; if it returns nothing (<code>None</code>), then the rule didn't match and you need to try another rule.
<p>So the improvement here is that you've completely separated the pluralization rules into an external file. Not only can the
file be maintained separately from the code, but you've set up a naming scheme where the same <code>plural</code> function can use different rule files, based on the <var>language</var> parameter.
<p>The downside here is that you're reading that file every time you call the <code>plural</code> function. I thought I could get through this entire book without using the phrase &#8220;left as an exercise for the reader&#8221;, but here you go: building a caching mechanism for the language-specific rule files that auto-refreshes itself if the rule
files change between calls <em>is left as an exercise for the reader</em>. Have fun.
<h2 id="plural.stage6">17.7. <code>plural.py</code>, stage 6</h2>
<p>Now you're ready to talk about generators.
<div class=example><h3>Example 17.17. <code>plural6.py</code></h3><pre><code>
import re

def rules(language):           
    for line in file('rules.%s' % language):     
        pattern, search, replace = line.split()  
        yield lambda word: re.search(pattern, word) and re.sub(search, replace, word)

def plural(noun, language='en'):      
    for applyRule in rules(language): 
        result = applyRule(noun)      
        if result: return result      
</pre><p>This uses a technique called generators, which I'm not even going to try to explain until you look at a simpler example first.
<div class=example><h3 id="plural.introducing.generators">Example 17.18. Introducing generators</h3><pre class=screen>
<samp class=prompt>>>> </samp><kbd>def make_counter(x):</kbd>
<samp class=prompt>...    </samp>print 'entering make_counter'
<samp class=prompt>...    </samp>while 1:
<samp class=prompt>...    </samp>    yield x               <span>&#x2460;</span>
<samp class=prompt>...    </samp>    print 'incrementing x'
<samp class=prompt>...    </samp>    x = x + 1
<samp class=prompt>...    </samp>
<samp class=prompt>>>> </samp><kbd>counter = make_counter(2)</kbd> <span>&#x2461;</span>
<samp class=prompt>>>> </samp><kbd>counter</kbd> <span>&#x2462;</span>
&lt;generator object at 0x001C9C10>
<samp class=prompt>>>> </samp><kbd>counter.next()</kbd>            <span>&#x2463;</span>
<samp>entering make_counter
2</samp>
<samp class=prompt>>>> </samp><kbd>counter.next()</kbd>            <span>&#x2464;</span>
<samp>incrementing x
3</samp>
<samp class=prompt>>>> </samp><kbd>counter.next()</kbd>            <span>&#x2465;</span>
<samp>incrementing x
4</span>
</pre><div class=calloutlist>
<ol>
<li>The presence of the <code>yield</code> keyword in <code>make_counter</code> means that this is not a normal function. It is a special kind of function which generates values one at a time. You can
            think of it as a resumable function. Calling it will return a generator that can be used to generate successive values of
<var>x</var>.
<li>To create an instance of the <code>make_counter</code> generator, just call it like any other function. Note that this does not actually execute the function code. You can tell
            this because the first line of <code>make_counter</code> is a <code>print</code> statement, but nothing has been printed yet.
<li>The <code>make_counter</code> function returns a generator object.
<li>The first time you call the <code>next()</code> method on the generator object, it executes the code in <code>make_counter</code> up to the first <code>yield</code> statement, and then returns the value that was yielded. In this case, that will be <code>2</code>, because you originally created the generator by calling <code>make_counter(2)</code>.
<li>Repeatedly calling <code>next()</code> on the generator object <em>resumes where you left off</em> and continues until you hit the next <code>yield</code> statement. The next line of code waiting to be executed is the <code>print</code> statement that prints <code>incrementing x</code>, and then after that the <code>x = x + 1</code> statement that actually increments it. Then you loop through the <code>while</code> loop again, and the first thing you do is <code>yield x</code>, which returns the current value of <var>x</var> (now 3).
<li>The second time you call <code>counter.next()</code>, you do all the same things again, but this time <var>x</var> is now <code>4</code>. And so forth. Since <code>make_counter</code> sets up an infinite loop, you could theoretically do this forever, and it would just keep incrementing <var>x</var> and spitting out values. But let's look at more productive uses of generators instead.
<div class=example><h3 id="plural.fib.example">Example 17.19. Using generators instead of recursion</h3><pre><code>
def fibonacci(max):
    a, b = 0, 1       <span>&#x2460;</span>
    while a &lt; max:
        yield a       <span>&#x2461;</span>
        a, b = b, a+b <span>&#x2462;</span>
</pre><div class=calloutlist>
<ol>
<li>The Fibonacci sequence is a sequence of numbers where each number is the sum of the two numbers before it. It starts with
<code>0</code> and <code>1</code>, goes up slowly at first, then more and more rapidly. To start the sequence, you need two variables: <var>a</var> starts at <code>0</code>, and <var>b</var> starts at <code>1</code>.
<li><var>a</var> is the current number in the sequence, so yield it.
<li><var>b</var> is the next number in the sequence, so assign that to <var>a</var>, but also calculate the next value (<code>a+b</code>) and assign that to <var>b</var> for later use. Note that this happens in parallel; if <var>a</var> is <code>3</code> and <var>b</var> is <code>5</code>, then <code>a, b = b, a+b</code> will set <var>a</var> to <code>5</code> (the previous value of <var>b</var>) and <var>b</var> to <code>8</code> (the sum of the previous values of <var>a</var> and <var>b</var>).
<p>So you have a function that spits out successive Fibonacci numbers. Sure, you could do that with recursion, but this way
is easier to read. Also, it works well with <code>for</code> loops.
<div class=example><h3>Example 17.20. Generators in <code>for</code> loops</h3><pre class=screen>
<samp class=prompt>>>> </samp><kbd>for n in fibonacci(1000):</kbd> <span>&#x2460;</span>
<samp class=prompt>...    </samp>print n,              <span>&#x2461;</span>
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987
</pre><div class=calloutlist>
<ol>
<li>You can use a generator like <code>fibonacci</code> in a <code>for</code> loop directly. The <code>for</code> loop will create the generator object and successively call the <code>next()</code> method to get values to assign to the <code>for</code> loop index variable (<var>n</var>).
<li>Each time through the <code>for</code> loop, <var>n</var> gets a new value from the <code>yield</code> statement in <code>fibonacci</code>, and all you do is print it out. Once <code>fibonacci</code> runs out of numbers (<var>a</var> gets bigger than <var>max</var>, which in this case is <code>1000</code>), then the <code>for</code> loop exits gracefully.
<p>OK, let's go back to the <code>plural</code> function and see how you're using this.
<div class=example><h3>Example 17.21. Generators that generate dynamic functions</h3><pre><code>
def rules(language):           
    for line in file('rules.%s' % language):      <span>&#x2460;</span>
        pattern, search, replace = line.split()   <span>&#x2461;</span>
        yield lambda word: re.search(pattern, word) and re.sub(search, replace, word) <span>&#x2462;</span>

def plural(noun, language='en'):      
    for applyRule in rules(language):  <span>&#x2463;</span>
        result = applyRule(noun)      
        if result: return result      
</pre><div class=calloutlist>
<ol>
<li><code>for line in file(...)</code> is a common idiom for reading lines from a file, one line at a time. It works because <em><code>file</code> actually returns a generator</em> whose <code>next()</code> method returns the next line of the file. That is so insanely cool, I wet myself just thinking about it.
<li>No magic here. Remember that the lines of the rules file have three values separated by whitespace, so <code>line.split()</code> returns a tuple of 3 values, and you assign those values to 3 local variables.
<li><em>And then you yield.</em>  What do you yield?  A function, built dynamically with <code>lambda</code>, that is actually a closure (it uses the local variables <var>pattern</var>, <var>search</var>, and <var>replace</var> as constants). In other words, <code>rules</code> is a generator that spits out rule functions.
<li>Since <code>rules</code> is a generator, you can use it directly in a <code>for</code> loop. The first time through the <code>for</code> loop, you will call the <code>rules</code> function, which will open the rules file, read the first line out of it, dynamically build a function that matches and applies
            the first rule defined in the rules file, and yields the dynamically built function. The second time through the <code>for</code> loop, you will pick up where you left off in <code>rules</code> (which was in the middle of the <code>for line in file(...)</code> loop), read the second line of the rules file, dynamically build another function that matches and applies the second rule
            defined in the rules file, and yields it. And so forth.
<p>What have you gained over <a href="#plural.stage5" title="17.6. plural.py, stage 5">stage 5</a>?  In stage 5, you read the entire rules file and built a list of all the possible rules before you even tried the first one.
Now with generators, you can do everything lazily: you open the first and read the first rule and create a function to try
it, but if that works you don't ever read the rest of the file or create any other functions.
<div class=itemizedlist>
<h3>Further reading</h3>
<ul>
<li><a href="http://www.python.org/peps/pep-0255.html">PEP 255</a> defines generators.

<li><a href="http://www.activestate.com/ASPN/Python/Cookbook/" title="growing archive of annotated code samples">Python Cookbook</a> has <a href="http://www.google.com/search?q=generators+cookbook+site:aspn.activestate.com">many more examples of generators</a>.

</ul>
<h2 id="plural.summary">17.8. Summary</h2>
<p>You talked about several different advanced techniques in this chapter. Not all of them are appropriate for every situation.
<p>You should now be comfortable with all of these techniques:
<div class=itemizedlist>
<ul>
<li>Performing <a href="#plural.stage1" title="17.2. plural.py, stage 1">string substitution with regular expressions</a>.

<li>Treating <a href="#plural.stage2" title="17.3. plural.py, stage 2">functions as objects</a>, storing them in lists, assigning them to variables, and calling them through those variables.

<li>Building <a href="#plural.stage3" title="17.4. plural.py, stage 3">dynamic functions with <code>lambda</code></a>.

<li>Building <a href="#plural.stage4" title="17.5. plural.py, stage 4">closures</a>, dynamic functions that contain surrounding variables as constants.

<li>Building <a href="#plural.stage6" title="17.7. plural.py, stage 6">generators</a>, resumable functions that perform incremental logic and return different values each time you call them.

</ul>
<p>Adding abstractions, building functions dynamically, building closures, and using generators can all make your code simpler,
more readable, and more flexible. But they can also end up making it more difficult to debug later. It's up to you to find
the right balance between simplicity and power.
<div class=chapter>
<h2 id="soundex">Chapter 18. Performance Tuning</h2>
<p>Performance tuning is a many-splendored thing. Just because Python is an interpreted language doesn't mean you shouldn't worry about code optimization. But don't worry about it <em>too</em> much.
<h2 id="soundex.divein">18.1. Diving in</h2>
<p>There are so many pitfalls involved in optimizing your code, it's hard to know where to start.
<p>Let's start here: <em>are you sure you need to do it at all?</em>  Is your code really so bad?  Is it worth the time to tune it?  Over the lifetime of your application, how much time is going
to be spent running that code, compared to the time spent waiting for a remote database server, or waiting for user input?
<p>Second, <em>are you sure you're done coding?</em>  Premature optimization is like spreading frosting on a half-baked cake. You spend hours or days (or more) optimizing your
code for performance, only to discover it doesn't do what you need it to do. That's time down the drain.
<p>This is not to say that code optimization is worthless, but you need to look at the whole system and decide whether it's the
best use of your time. Every minute you spend optimizing code is a minute you're not spending adding new features, or writing
documentation, or playing with your kids, or writing unit tests.
<p>Oh yes, unit tests. It should go without saying that you need a complete set of unit tests before you begin performance tuning.
The last thing you need is to introduce new bugs while fiddling with your algorithms.
<p>With these caveats in place, let's look at some techniques for optimizing Python code. The code in question is an implementation of the Soundex algorithm. Soundex was a method used in the early 20th century
for categorizing surnames in the United States census. It grouped similar-sounding names together, so even if a name was
misspelled, researchers had a chance of finding it. Soundex is still used today for much the same reason, although of course
we use computerized database servers now. Most database servers include a Soundex function.
<p>There are several subtle variations of the Soundex algorithm. This is the one used in this chapter:
<div class=orderedlist>
<ol>
<li>Keep the first letter of the name as-is.
<li>Convert the remaining letters to digits, according to a specific table:
<div class=itemizedlist>
<ul>
<li>B, F, P, and V become 1.
<li>C, G, J, K, Q, S, X, and Z become 2.
<li>D and T become 3.
<li>L becomes 4.
<li>M and N become 5.
<li>R becomes 6.
<li>All other letters become 9.
</ul>

<li>Remove consecutive duplicates.
<li>Remove all 9s altogether.
<li>If the result is shorter than four characters (the first letter plus three digits), pad the result with trailing zeros.
<li>if the result is longer than four characters, discard everything after the fourth character.
</ol>
<p>For example, my name, <code>Pilgrim</code>, becomes P942695. That has no consecutive duplicates, so nothing to do there. Then you remove the 9s, leaving P4265. That's
too long, so you discard the excess character, leaving P426.
<p>Another example: <code>Woo</code> becomes W99, which becomes W9, which becomes W, which gets padded with zeros to become W000.
<p>Here's a first attempt at a Soundex function:
<div class=example><h3>Example 18.1. <code>soundex/stage1/soundex1a.py</code></h3>
<p>If you have not already done so, you can <a href="http://diveintopython3.org/download/diveintopython3-examples-5.4.zip" title="Download example scripts">download this and other examples</a> used in this book.
<pre><code>
import string, re

charToSoundex = {"A": "9",
                 "B": "1",
                 "C": "2",
                 "D": "3",
                 "E": "9",
                 "F": "1",
                 "G": "2",
                 "H": "9",
                 "I": "9",
                 "J": "2",
                 "K": "2",
                 "L": "4",
                 "M": "5",
                 "N": "5",
                 "O": "9",
                 "P": "1",
                 "Q": "2",
                 "R": "6",
                 "S": "2",
                 "T": "3",
                 "U": "9",
                 "V": "1",
                 "W": "9",
                 "X": "2",
                 "Y": "9",
                 "Z": "2"}

def soundex(source):
    "convert string to Soundex equivalent"

    # Soundex requirements:
    # source string must be at least 1 character
    # and must consist entirely of letters
    allChars = string.uppercase + string.lowercase
    if not re.search('^[%s]+$' % allChars, source):
        return "0000"

    # Soundex algorithm:
    # 1. make first character uppercase
    source = source[0].upper() + source[1:]
    
    # 2. translate all other characters to Soundex digits
    digits = source[0]
    for s in source[1:]:
        s = s.upper()
        digits += charToSoundex[s]

    # 3. remove consecutive duplicates
    digits2 = digits[0]
    for d in digits[1:]:
        if digits2[-1] != d:
            digits2 += d
        
    # 4. remove all "9"s
    digits3 = re.sub('9', '', digits2)
    
    # 5. pad end with "0"s to 4 characters
    while len(digits3) &lt; 4:
        digits3 += "0"
        
    # 6. return first 4 characters
    return digits3[:4]

if __name__ == '__main__':
    from timeit import Timer
    names = ('Woo', 'Pilgrim', 'Flingjingwaller')
    for name in names:
        statement = "soundex('%s')" % name
        t = Timer(statement, "from __main__ import soundex")
        print name.ljust(15), soundex(name), min(t.repeat())
</pre><div class=itemizedlist>
<h3>Further Reading on Soundex</h3>
<ul>
<li><a href="http://www.avotaynu.com/soundex.html">Soundexing and Genealogy</a> gives a chronology of the evolution of the Soundex and its regional variations.

</ul>
<h2 id="soundex.timeit">18.2. Using the <code>timeit</code> Module</h2>
<p>The most important thing you need to know about optimizing Python code is that you shouldn't write your own timing function.
<p>Timing short pieces of code is incredibly complex. How much processor time is your computer devoting to running this code?
Are there things running in the background?  Are you sure?  Every modern computer has background processes running, some all
the time, some intermittently. Cron jobs fire off at consistent intervals; background services occasionally &#8220;wake up&#8221; to do useful things like check for new mail, connect to instant messaging servers, check for application updates, scan for
viruses, check whether a disk has been inserted into your CD drive in the last 100 nanoseconds, and so on. Before you start
your timing tests, turn everything off and disconnect from the network. Then turn off all the things you forgot to turn off
the first time, then turn off the service that's incessantly checking whether the network has come back yet, then ...
<p>And then there's the matter of the variations introduced by the timing framework itself. Does the Python interpreter cache method name lookups?  Does it cache code block compilations?  Regular expressions?  Will your code have
side effects if run more than once?  Don't forget that you're dealing with small fractions of a second, so small mistakes
in your timing framework will irreparably skew your results.
<p>The Python community has a saying: &#8220;Python comes with batteries included.&#8221;  Don't write your own timing framework. Python 2.3 comes with a perfectly good one called <code>timeit</code>.
<div class=example><h3>Example 18.2. Introducing <code>timeit</code></h3>
<p>If you have not already done so, you can <a href="http://diveintopython3.org/download/diveintopython3-examples-5.4.zip" title="Download example scripts">download this and other examples</a> used in this book.
<pre class=screen>
<samp class=prompt>>>> </samp><kbd>import timeit</kbd>
<samp class=prompt>>>> </samp><kbd>t = timeit.Timer("soundex.soundex('Pilgrim')",</kbd>
<samp class=prompt>...    </samp>"import soundex")   <span>&#x2460;</span>
<samp class=prompt>>>> </samp><kbd>t.timeit()</kbd>              <span>&#x2461;</span>
8.21683733547
<samp class=prompt>>>> </samp><kbd>t.repeat(3, 2000000)</kbd>    <span>&#x2462;</span>
[16.48319309109, 16.46128984923, 16.44203948912]
</pre><div class=calloutlist>
<ol>
<li>The <code>timeit</code> module defines one class, <code>Timer</code>, which takes two arguments. Both arguments are strings. The first argument is the statement you wish to time; in this case,
            you are timing a call to the Soundex function within the <code>soundex</code> with an argument of <code>'Pilgrim'</code>. The second argument to the <code>Timer</code> class is the import statement that sets up the environment for the statement. Internally, <code>timeit</code> sets up an isolated virtual environment, manually executes the setup statement (importing the <code>soundex</code> module), then manually compiles and executes the timed statement (calling the Soundex function).
<li>Once you have the <code>Timer</code> object, the easiest thing to do is call <code>timeit()</code>, which calls your function 1 million times and returns the number of seconds it took to do it.
<li>The other major method of the <code>Timer</code> object is <code>repeat()</code>, which takes two optional arguments. The first argument is the number of times to repeat the entire test, and the second
            argument is the number of times to call the timed statement within each test. Both arguments are optional, and they default
            to <code>3</code> and <code>1000000</code> respectively. The <code>repeat()</code> method returns a list of the times each test cycle took, in seconds.
<blockquote class="note FIXME">
<p><span>&#x261E;</span>You can use the <code>timeit</code> module on the command line to test an existing Python program, without modifying the code. See <a href="http://docs.python.org/lib/node396.html">http://docs.python.org/lib/node396.html</a> for documentation on the command-line flags.
<p>Note that <code>repeat()</code> returns a list of times. The times will almost never be identical, due to slight variations in how much processor time the
Python interpreter is getting (and those pesky background processes that you can't get rid of). Your first thought might be to
say &#8220;Let's take the average and call that The True Number.&#8221;
<p>In fact, that's almost certainly wrong. The tests that took longer didn't take longer because of variations in your code
or in the Python interpreter; they took longer because of those pesky background processes, or other factors outside of the Python interpreter that you can't fully eliminate. If the different timing results differ by more than a few percent, you still
have too much variability to trust the results. Otherwise, take the minimum time and discard the rest.
<p>Python has a handy <code>min</code> function that takes a list and returns the smallest value:
<pre class=screen>
<samp class=prompt>>>> </samp><kbd>min(t.repeat(3, 1000000))</kbd>
8.22203948912
</pre><blockquote class="note FIXME">
<p><span>&#x261E;</span>The <code>timeit</code> module only works if you already know what piece of code you need to optimize. If you have a larger Python program and don't know where your performance problems are, check out <a href="http://docs.python.org/lib/module-hotshot.html">the <code>hotshot</code> module.</a><h2 id="soundex.stage1">18.3. Optimizing Regular Expressions</h2>
<p>The first thing the Soundex function checks is whether the input is a non-empty string of letters. What's the best way to
   do this?
<p>If you answered &#8220;regular expressions&#8221;, go sit in the corner and contemplate your bad instincts. Regular expressions are almost never the right answer; they should
be avoided whenever possible. Not only for performance reasons, but simply because they're difficult to debug and maintain.
Also for performance reasons.
<p>This code fragment from <code>soundex/stage1/soundex1a.py</code> checks whether the function argument <var>source</var> is a word made entirely of letters, with at least one letter (not the empty string):
<pre><code>
    allChars = string.uppercase + string.lowercase
    if not re.search('^[%s]+$' % allChars, source):
        return "0000"
</pre><p>How does <code>soundex1a.py</code> perform?  For convenience, the <code>__main__</code> section of the script contains this code that calls the <code>timeit</code> module, sets up a timing test with three different names, tests each name three times, and displays the minimum time for
each:
<pre><code>
if __name__ == '__main__':
    from timeit import Timer
    names = ('Woo', 'Pilgrim', 'Flingjingwaller')
    for name in names:
        statement = "soundex('%s')" % name
        t = Timer(statement, "from __main__ import soundex")
        print name.ljust(15), soundex(name), min(t.repeat())
</pre><p>So how does <code>soundex1a.py</code> perform with this regular expression?
<pre class=screen>
<samp class=prompt>C:\samples\soundex\stage1></samp>python soundex1a.py
<samp>Woo             W000 19.3356647283
Pilgrim         P426 24.0772053431
Flingjingwaller F452 35.0463220884</span>
</pre><p>As you might expect, the algorithm takes significantly longer when called with longer names. There will be a few things we
can do to narrow that gap (make the function take less relative time for longer input), but the nature of the algorithm dictates
that it will never run in constant time.
<p>The other thing to keep in mind is that we are testing a representative sample of names. <code>Woo</code> is a kind of trivial case, in that it gets shorted down to a single letter and then padded with zeros. <code>Pilgrim</code> is a normal case, of average length and a mixture of significant and ignored letters. <code>Flingjingwaller</code> is extraordinarily long and contains consecutive duplicates. Other tests might also be helpful, but this hits a good range
of different cases.
<p>So what about that regular expression?  Well, it's inefficient. Since the expression is testing for ranges of characters
(<code>A-Z</code> in uppercase, and <code>a-z</code> in lowercase), we can use a shorthand regular expression syntax. Here is <code>soundex/stage1/soundex1b.py</code>:
<pre><code>
    if not re.search('^[A-Za-z]+$', source):
        return "0000"
</pre><p><code>timeit</code> says <code>soundex1b.py</code> is slightly faster than <code>soundex1a.py</code>, but nothing to get terribly excited about:
<pre class=screen>
<samp class=prompt>C:\samples\soundex\stage1></samp>python soundex1b.py
<samp>Woo             W000 17.1361133887
Pilgrim         P426 21.8201693232
Flingjingwaller F452 32.7262294509</span>
</pre><p>We saw in <a href="#roman.refactoring" title="15.3. Refactoring">Section 15.3, &#8220;Refactoring&#8221;</a> that regular expressions can be compiled and reused for faster results. Since this regular expression never changes across
function calls, we can compile it once and use the compiled version. Here is <code>soundex/stage1/soundex1c.py</code>:
<pre><code>
isOnlyChars = re.compile('^[A-Za-z]+$').search
def soundex(source):
    if not isOnlyChars(source):
        return "0000"
</pre><p>Using a compiled regular expression in <code>soundex1c.py</code> is significantly faster:
<pre class=screen>
<samp class=prompt>C:\samples\soundex\stage1></samp>python soundex1c.py
<samp>Woo             W000 14.5348347346
Pilgrim         P426 19.2784703084
Flingjingwaller F452 30.0893873383</span>
</pre><p>But is this the wrong path?  The logic here is simple: the input <var>source</var> needs to be non-empty, and it needs to be composed entirely of letters. Wouldn't it be faster to write a loop checking each
character, and do away with regular expressions altogether?
<p>Here is <code>soundex/stage1/soundex1d.py</code>:
<pre><code>
    if not source:
        return "0000"
    for c in source:
        if not ('A' &lt;= c &lt;= 'Z') and not ('a' &lt;= c &lt;= 'z'):
            return "0000"
</pre><p>It turns out that this technique in <code>soundex1d.py</code> is <em>not</em> faster than using a compiled regular expression (although it is faster than using a non-compiled regular expression):
<pre class=screen>
<samp class=prompt>C:\samples\soundex\stage1></samp>python soundex1d.py
<samp>Woo             W000 15.4065058548
Pilgrim         P426 22.2753567842
Flingjingwaller F452 37.5845122774</span>
</pre><p>Why isn't <code>soundex1d.py</code> faster?  The answer lies in the interpreted nature of Python. The regular expression engine is written in C, and compiled to run natively on your computer. On the other hand, this
loop is written in Python, and runs through the Python interpreter. Even though the loop is relatively simple, it's not simple enough to make up for the overhead of being interpreted.
Regular expressions are never the right answer... except when they are.
<p>It turns out that Python offers an obscure string method. You can be excused for not knowing about it, since it's never been mentioned in this book.
The method is called <code>isalpha()</code>, and it checks whether a string contains only letters.
<p>This is <code>soundex/stage1/soundex1e.py</code>:
<pre><code>
    if (not source) and (not source.isalpha()):
        return "0000"
</pre><p>How much did we gain by using this specific method in <code>soundex1e.py</code>?  Quite a bit.
<pre class=screen>
<samp class=prompt>C:\samples\soundex\stage1></samp>python soundex1e.py
<samp>Woo             W000 13.5069504644
Pilgrim         P426 18.2199394057
Flingjingwaller F452 28.9975225902</span>
</pre><div class=example><h3>Example 18.3. Best Result So Far: <code>soundex/stage1/soundex1e.py</code></h3><pre><code>
import string, re

charToSoundex = {"A": "9",
                 "B": "1",
                 "C": "2",
                 "D": "3",
                 "E": "9",
                 "F": "1",
                 "G": "2",
                 "H": "9",
                 "I": "9",
                 "J": "2",
                 "K": "2",
                 "L": "4",
                 "M": "5",
                 "N": "5",
                 "O": "9",
                 "P": "1",
                 "Q": "2",
                 "R": "6",
                 "S": "2",
                 "T": "3",
                 "U": "9",
                 "V": "1",
                 "W": "9",
                 "X": "2",
                 "Y": "9",
                 "Z": "2"}

def soundex(source):
    if (not source) and (not source.isalpha()):
        return "0000"
    source = source[0].upper() + source[1:]
    digits = source[0]
    for s in source[1:]:
        s = s.upper()
        digits += charToSoundex[s]
    digits2 = digits[0]
    for d in digits[1:]:
        if digits2[-1] != d:
            digits2 += d
    digits3 = re.sub('9', '', digits2)
    while len(digits3) &lt; 4:
        digits3 += "0"
    return digits3[:4]

if __name__ == '__main__':
    from timeit import Timer
    names = ('Woo', 'Pilgrim', 'Flingjingwaller')
    for name in names:
        statement = "soundex('%s')" % name
        t = Timer(statement, "from __main__ import soundex")
        print name.ljust(15), soundex(name), min(t.repeat())
</pre><h2 id="soundex.stage2">18.4. Optimizing Dictionary Lookups</h2>
<p>The second step of the Soundex algorithm is to convert characters to digits in a specific pattern. What's the best way to
   do this?
<p>The most obvious solution is to define a dictionary with individual characters as keys and their corresponding digits as values,
and do dictionary lookups on each character. This is what we have in <code>soundex/stage1/soundex1c.py</code> (the current best result so far):
<pre><code>
charToSoundex = {"A": "9",
                 "B": "1",
                 "C": "2",
                 "D": "3",
                 "E": "9",
                 "F": "1",
                 "G": "2",
                 "H": "9",
                 "I": "9",
                 "J": "2",
                 "K": "2",
                 "L": "4",
                 "M": "5",
                 "N": "5",
                 "O": "9",
                 "P": "1",
                 "Q": "2",
                 "R": "6",
                 "S": "2",
                 "T": "3",
                 "U": "9",
                 "V": "1",
                 "W": "9",
                 "X": "2",
                 "Y": "9",
                 "Z": "2"}

def soundex(source):
    # ... input check omitted for brevity ...
    source = source[0].upper() + source[1:]
    digits = source[0]
    for s in source[1:]:
        s = s.upper()
        digits += charToSoundex[s]
</pre><p>You timed <code>soundex1c.py</code> already; this is how it performs:
<pre class=screen>
<samp class=prompt>C:\samples\soundex\stage1></samp>python soundex1c.py
<samp>Woo             W000 14.5341678901
Pilgrim         P426 19.2650071448
Flingjingwaller F452 30.1003563302</span>
</pre><p>This code is straightforward, but is it the best solution?  Calling <code>upper()</code> on each individual character seems inefficient; it would probably be better to call <code>upper()</code> once on the entire string.
<p>Then there's the matter of incrementally building the <var>digits</var> string. Incrementally building strings like this is horribly inefficient; internally, the Python interpreter needs to create a new string each time through the loop, then discard the old one.
<p>Python is good at lists, though. It can treat a string as a list of characters automatically. And lists are easy to combine into
strings again, using the string method <code>join()</code>.
<p>Here is <code>soundex/stage2/soundex2a.py</code>, which converts letters to digits by using &#8614; and <code>lambda</code>:
<pre><code>
def soundex(source):
    # ...
    source = source.upper()
    digits = source[0] + "".join(map(lambda c: charToSoundex[c], source[1:]))
</pre><p>Surprisingly, <code>soundex2a.py</code> is not faster:
<pre class=screen>
<samp class=prompt>C:\samples\soundex\stage2></samp>python soundex2a.py
<samp>Woo             W000 15.0097526362
Pilgrim         P426 19.254806407
Flingjingwaller F452 29.3790847719</span>
</pre><p>The overhead of the anonymous <code>lambda</code> function kills any performance you gain by dealing with the string as a list of characters.
<p><code>soundex/stage2/soundex2b.py</code> uses a list comprehension instead of &#8614; and <code>lambda</code>:
<pre><code>
    source = source.upper()
    digits = source[0] + "".join([charToSoundex[c] for c in source[1:]])
</pre><p>Using a list comprehension in <code>soundex2b.py</code> is faster than using &#8614; and <code>lambda</code> in <code>soundex2a.py</code>, but still not faster than the original code (incrementally building a string in <code>soundex1c.py</code>):
<pre class=screen>
<samp class=prompt>C:\samples\soundex\stage2></samp>python soundex2b.py
<samp>Woo             W000 13.4221324219
Pilgrim         P426 16.4901234654
Flingjingwaller F452 25.8186157738</span>
</pre><p>It's time for a radically different approach. Dictionary lookups are a general purpose tool. Dictionary keys can be any
length string (or many other data types), but in this case we are only dealing with single-character keys <em>and</em> single-character values. It turns out that Python has a specialized function for handling exactly this situation: the <code>string.maketrans</code> function.
<p>This is <code>soundex/stage2/soundex2c.py</code>:
<pre><code>
allChar = string.uppercase + string.lowercase
charToSoundex = string.maketrans(allChar, "91239129922455912623919292" * 2)
def soundex(source):
    # ...
    digits = source[0].upper() + source[1:].translate(charToSoundex)
</pre><p>What the heck is going on here?  <code>string.maketrans</code> creates a translation matrix between two strings: the first argument and the second argument. In this case, the first argument
is the string <code>ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz</code>, and the second argument is the string <code>9123912992245591262391929291239129922455912623919292</code>. See the pattern?  It's the same conversion pattern we were setting up longhand with a dictionary. A maps to 9, B maps
to 1, C maps to 2, and so forth. But it's not a dictionary; it's a specialized data structure that you can access using the
string method <code>translate</code>, which translates each character into the corresponding digit, according to the matrix defined by <code>string.maketrans</code>.
<p><code>timeit</code> shows that <code>soundex2c.py</code> is significantly faster than defining a dictionary and looping through the input and building the output incrementally:
<pre class=screen>
<samp class=prompt>C:\samples\soundex\stage2></samp>python soundex2c.py
<samp>Woo             W000 11.437645008
Pilgrim         P426 13.2825062962
Flingjingwaller F452 18.5570110168</span>
</pre><p>You're not going to get much better than that. Python has a specialized function that does exactly what you want to do; use it and move on.
<div class=example><h3>Example 18.4. Best Result So Far: <code>soundex/stage2/soundex2c.py</code></h3><pre><code>
import string, re

allChar = string.uppercase + string.lowercase
charToSoundex = string.maketrans(allChar, "91239129922455912623919292" * 2)
isOnlyChars = re.compile('^[A-Za-z]+$').search

def soundex(source):
    if not isOnlyChars(source):
        return "0000"
    digits = source[0].upper() + source[1:].translate(charToSoundex)
    digits2 = digits[0]
    for d in digits[1:]:
        if digits2[-1] != d:
            digits2 += d
    digits3 = re.sub('9', '', digits2)
    while len(digits3) &lt; 4:
        digits3 += "0"
    return digits3[:4]

if __name__ == '__main__':
    from timeit import Timer
    names = ('Woo', 'Pilgrim', 'Flingjingwaller')
    for name in names:
        statement = "soundex('%s')" % name
        t = Timer(statement, "from __main__ import soundex")
        print name.ljust(15), soundex(name), min(t.repeat())
</pre><h2 id="soundex.stage3">18.5. Optimizing List Operations</h2>
<p>The third step in the Soundex algorithm is eliminating consecutive duplicate digits. What's the best way to do this?
<p>Here's the code we have so far, in <code>soundex/stage2/soundex2c.py</code>:
<pre><code>
    digits2 = digits[0]
    for d in digits[1:]:
        if digits2[-1] != d:
            digits2 += d
</pre><p>Here are the performance results for <code>soundex2c.py</code>:
<pre class=screen>
<samp class=prompt>C:\samples\soundex\stage2></samp>python soundex2c.py
<samp>Woo             W000 12.6070768771
Pilgrim         P426 14.4033353401
Flingjingwaller F452 19.7774882003</span>
</pre><p>The first thing to consider is whether it's efficient to check <var>digits[-1]</var> each time through the loop. Are list indexes expensive?  Would we be better off maintaining the last digit in a separate
variable, and checking that instead?
<p>To answer this question, here is <code>soundex/stage3/soundex3a.py</code>:
<pre><code>
    digits2 = ''
    last_digit = ''
    for d in digits:
        if d != last_digit:
            digits2 += d
            last_digit = d
</pre><p><code>soundex3a.py</code> does not run any faster than <code>soundex2c.py</code>, and may even be slightly slower (although it's not enough of a difference to say for sure):
<pre class=screen>
<samp class=prompt>C:\samples\soundex\stage3></samp>python soundex3a.py
<samp>Woo             W000 11.5346048171
Pilgrim         P426 13.3950636184
Flingjingwaller F452 18.6108927252</span>
</pre><p>Why isn't <code>soundex3a.py</code> faster?  It turns out that list indexes in Python are extremely efficient. Repeatedly accessing <var>digits2[-1]</var> is no problem at all. On the other hand, manually maintaining the last seen digit in a separate variable means we have <em>two</em> variable assignments for each digit we're storing, which wipes out any small gains we might have gotten from eliminating
the list lookup.
<p>Let's try something radically different. If it's possible to treat a string as a list of characters, it should be possible
to use a list comprehension to iterate through the list. The problem is, the code needs access to the previous character
in the list, and that's not easy to do with a straightforward list comprehension.
<p>However, it is possible to create a list of index numbers using the built-in <code>range()</code> function, and use those index numbers to progressively search through the list and pull out each character that is different
from the previous character. That will give you a list of characters, and you can use the string method <code>join()</code> to reconstruct a string from that.
<p>Here is <code>soundex/stage3/soundex3b.py</code>:
<pre><code>
    digits2 = "".join([digits[i] for i in range(len(digits))
     if i == 0 or digits[i-1] != digits[i]])
</pre><p>Is this faster?  In a word, no.
<pre class=screen>
<samp class=prompt>C:\samples\soundex\stage3></samp>python soundex3b.py
<samp>Woo             W000 14.2245271396
Pilgrim         P426 17.8337165757
Flingjingwaller F452 25.9954005327</span>
</pre><p>It's possible that the techniques so far as have been &#8220;string-centric&#8221;. Python can convert a string into a list of characters with a single command: <code>list('abc')</code> returns <code>['a', 'b', 'c']</code>. Furthermore, lists can be <em>modified in place</em> very quickly. Instead of incrementally building a new list (or string) out of the source string, why not move elements around
within a single list?
<p>Here is <code>soundex/stage3/soundex3c.py</code>, which modifies a list in place to remove consecutive duplicate elements:
<pre><code>
    digits = list(source[0].upper() + source[1:].translate(charToSoundex))
    i=0
    for item in digits:
        if item==digits[i]: continue
        i+=1
        digits[i]=item
    del digits[i+1:]
    digits2 = "".join(digits)
</pre><p>Is this faster than <code>soundex3a.py</code> or <code>soundex3b.py</code>?  No, in fact it's the slowest method yet:
<pre class=screen>
<samp class=prompt>C:\samples\soundex\stage3></samp>python soundex3c.py
<samp>Woo             W000 14.1662554878
Pilgrim         P426 16.0397885765
Flingjingwaller F452 22.1789341942</span>
</pre><p>We haven't made any progress here at all, except to try and rule out several &#8220;clever&#8221; techniques. The fastest code we've seen so far was the original, most straightforward method (<code>soundex2c.py</code>). Sometimes it doesn't pay to be clever.
<div class=example><h3>Example 18.5. Best Result So Far: <code>soundex/stage2/soundex2c.py</code></h3><pre><code>
import string, re

allChar = string.uppercase + string.lowercase
charToSoundex = string.maketrans(allChar, "91239129922455912623919292" * 2)
isOnlyChars = re.compile('^[A-Za-z]+$').search

def soundex(source):
    if not isOnlyChars(source):
        return "0000"
    digits = source[0].upper() + source[1:].translate(charToSoundex)
    digits2 = digits[0]
    for d in digits[1:]:
        if digits2[-1] != d:
            digits2 += d
    digits3 = re.sub('9', '', digits2)
    while len(digits3) &lt; 4:
        digits3 += "0"
    return digits3[:4]

if __name__ == '__main__':
    from timeit import Timer
    names = ('Woo', 'Pilgrim', 'Flingjingwaller')
    for name in names:
        statement = "soundex('%s')" % name
        t = Timer(statement, "from __main__ import soundex")
        print name.ljust(15), soundex(name), min(t.repeat())
</pre><h2 id="soundex.stage4">18.6. Optimizing String Manipulation</h2>
<p>The final step of the Soundex algorithm is padding short results with zeros, and truncating long results. What is the best
   way to do this?
<p>This is what we have so far, taken from <code>soundex/stage2/soundex2c.py</code>:
<pre><code>
    digits3 = re.sub('9', '', digits2)
    while len(digits3) &lt; 4:
        digits3 += "0"
    return digits3[:4]
</pre><p>These are the results for <code>soundex2c.py</code>:
<pre class=screen>
<samp class=prompt>C:\samples\soundex\stage2></samp>python soundex2c.py
<samp>Woo             W000 12.6070768771
Pilgrim         P426 14.4033353401
Flingjingwaller F452 19.7774882003</span>
</pre><p>The first thing to consider is replacing that regular expression with a loop. This code is from <code>soundex/stage4/soundex4a.py</code>:
<pre><code>
    digits3 = ''
    for d in digits2:
        if d != '9':
            digits3 += d
</pre><p>Is <code>soundex4a.py</code> faster?  Yes it is:
<pre class=screen>
<samp class=prompt>C:\samples\soundex\stage4></samp>python soundex4a.py
<samp>Woo             W000 6.62865531792
Pilgrim         P426 9.02247576158
Flingjingwaller F452 13.6328416042</span>
</pre><p>But wait a minute. A loop to remove characters from a string?  We can use a simple string method for that. Here's <code>soundex/stage4/soundex4b.py</code>:
<pre><code>
    digits3 = digits2.replace('9', '')
</pre><p>Is <code>soundex4b.py</code> faster?  That's an interesting question. It depends on the input:
<pre class=screen>
<samp class=prompt>C:\samples\soundex\stage4></samp>python soundex4b.py
<samp>Woo             W000 6.75477414029
Pilgrim         P426 7.56652144337
Flingjingwaller F452 10.8727729362</span>
</pre><p>The string method in <code>soundex4b.py</code> is faster than the loop for most names, but it's actually slightly slower than <code>soundex4a.py</code> in the trivial case (of a very short name). Performance optimizations aren't always uniform; tuning that makes one case
faster can sometimes make other cases slower. In this case, the majority of cases will benefit from the change, so let's
leave it at that, but the principle is an important one to remember.
<p>Last but not least, let's examine the final two steps of the algorithm: padding short results with zeros, and truncating long
results to four characters. The code you see in <code>soundex4b.py</code> does just that, but it's horribly inefficient. Take a look at <code>soundex/stage4/soundex4c.py</code> to see why:
<pre><code>
    digits3 += '000'
    return digits3[:4]
</pre><p>Why do we need a <code>while</code> loop to pad out the result?  We know in advance that we're going to truncate the result to four characters, and we know that
we already have at least one character (the initial letter, which is passed unchanged from the original <var>source</var> variable). That means we can simply add three zeros to the output, then truncate it. Don't get stuck in a rut over the
exact wording of the problem; looking at the problem slightly differently can lead to a simpler solution.
<p>How much speed do we gain in <code>soundex4c.py</code> by dropping the <code>while</code> loop?  It's significant:
<pre class=screen>
<samp class=prompt>C:\samples\soundex\stage4></samp>python soundex4c.py
<samp>Woo             W000 4.89129791636
Pilgrim         P426 7.30642134685
Flingjingwaller F452 10.689832367</span>
</pre><p>Finally, there is still one more thing you can do to these three lines of code to make them faster: you can combine them into
one line. Take a look at <code>soundex/stage4/soundex4d.py</code>:
<pre><code>
    return (digits2.replace('9', '') + '000')[:4]
</pre><p>Putting all this code on one line in <code>soundex4d.py</code> is barely faster than <code>soundex4c.py</code>:
<pre class=screen>
<samp class=prompt>C:\samples\soundex\stage4></samp>python soundex4d.py
<samp>Woo             W000 4.93624105857
Pilgrim         P426 7.19747593619
Flingjingwaller F452 10.5490700634</span>
</pre><p>It is also significantly less readable, and for not much performance gain. Is that worth it?  I hope you have good comments.
Performance isn't everything. Your optimization efforts must always be balanced against threats to your program's readability
and maintainability.
<h2 id="soundex.summary">18.7. Summary</h2>
<p>This chapter has illustrated several important aspects of performance tuning in Python, and performance tuning in general.
<div class=itemizedlist>
<ul>
<li>If you need to choose between regular expressions and writing a loop, choose regular expressions. The regular expression
      engine is compiled in C and runs natively on your computer; your loop is written in Python and runs through the Python interpreter.

<li>If you need to choose between regular expressions and string methods, choose string methods. Both are compiled in C, so choose
      the simpler one.

<li>General-purpose dictionary lookups are fast, but specialtiy functions such as <code>string.maketrans</code> and string methods such as <code>isalpha()</code> are faster. If Python has a custom-tailored function for you, use it.

<li>Don't be too clever. Sometimes the most obvious algorithm is also the fastest.
<li>Don't sweat it too much. Performance isn't everything.
</ul>
<p>I can't emphasize that last point strongly enough. Over the course of this chapter, you made this function three times faster
and saved 20 seconds over 1 million function calls. Great. Now think: over the course of those million function calls, how
many seconds will your surrounding application wait for a database connection?  Or wait for disk I/O?  Or wait for user input?
Don't spend too much time over-optimizing one algorithm, or you'll ignore obvious improvements somewhere else. Develop an
instinct for the sort of code that Python runs well, correct obvious blunders if you find them, and leave the rest alone.
</body>
</html>
